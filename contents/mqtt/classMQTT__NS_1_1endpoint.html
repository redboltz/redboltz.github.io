<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mqtt_cpp: MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mqtt_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMQTT__NS.html">MQTT_NS</a></li><li class="navelem"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMQTT__NS_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classMQTT__NS_1_1endpoint__inherit__graph.png" border="0" usemap="#aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" id="aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="5,124,212,180"/>
<area shape="rect" title=" " alt="" coords="23,5,194,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classMQTT__NS_1_1endpoint__coll__graph.png" border="0" usemap="#aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" id="aMQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,124,212,180"/>
<area shape="rect" title=" " alt="" coords="23,5,194,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a480c9e07ff13bcbed796378425633074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> = std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a> ec)&gt;</td></tr>
<tr class="separator:a480c9e07ff13bcbed796378425633074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525c3f23b3eb6818ad591f88eb8ecc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> = typename <a class="el" href="structMQTT__NS_1_1packet__id__type.html">packet_id_type</a>&lt; PacketIdBytes &gt;::type</td></tr>
<tr class="separator:a9525c3f23b3eb6818ad591f88eb8ecc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29470cf9cad5cb1756a24f582d5f8f58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a29470cf9cad5cb1756a24f582d5f8f58">endpoint</a> (as::io_context &amp;ioc, <a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> version=<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>, bool async_send_store=false)</td></tr>
<tr class="memdesc:a29470cf9cad5cb1756a24f582d5f8f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for client.  <a href="classMQTT__NS_1_1endpoint.html#a29470cf9cad5cb1756a24f582d5f8f58">More...</a><br /></td></tr>
<tr class="separator:a29470cf9cad5cb1756a24f582d5f8f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0414917b1c36359b10cde35938bb5a"><td class="memTemplParams" colspan="2">template&lt;typename Socket &gt; </td></tr>
<tr class="memitem:afe0414917b1c36359b10cde35938bb5a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afe0414917b1c36359b10cde35938bb5a">endpoint</a> (as::io_context &amp;ioc, std::shared_ptr&lt; Socket &gt; <a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">socket</a>, <a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> version=<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>, bool async_send_store=false)</td></tr>
<tr class="memdesc:afe0414917b1c36359b10cde35938bb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for server. socket should have already been connected with another endpoint.  <a href="classMQTT__NS_1_1endpoint.html#afe0414917b1c36359b10cde35938bb5a">More...</a><br /></td></tr>
<tr class="separator:afe0414917b1c36359b10cde35938bb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb31e631081e8aa9885498b00902e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a91cb31e631081e8aa9885498b00902e8">endpoint</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:a91cb31e631081e8aa9885498b00902e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4b283fc6b3a22f6302851c8ada488a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aef4b283fc6b3a22f6302851c8ada488a">endpoint</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aef4b283fc6b3a22f6302851c8ada488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16684404a6edf1f58d07938b60fbaf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa16684404a6edf1f58d07938b60fbaf0">operator=</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:aa16684404a6edf1f58d07938b60fbaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a2506a09708a2de1e5d3aa8bbf275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9f4a2506a09708a2de1e5d3aa8bbf275">operator=</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9f4a2506a09708a2de1e5d3aa8bbf275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a83b22497e0a2b8adfd9012f4fc3a25bf">clean_session</a> () const</td></tr>
<tr class="memdesc:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean session.  <a href="classMQTT__NS_1_1endpoint.html#a83b22497e0a2b8adfd9012f4fc3a25bf">More...</a><br /></td></tr>
<tr class="separator:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced2510df92ce5eb5c0276a6445fb49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aeced2510df92ce5eb5c0276a6445fb49">clean_start</a> () const</td></tr>
<tr class="memdesc:aeced2510df92ce5eb5c0276a6445fb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean start.  <a href="classMQTT__NS_1_1endpoint.html#aeced2510df92ce5eb5c0276a6445fb49">More...</a><br /></td></tr>
<tr class="separator:aeced2510df92ce5eb5c0276a6445fb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4449eb06a51355c995f0a1a5bbfe9c1e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4449eb06a51355c995f0a1a5bbfe9c1e">get_total_bytes_received</a> () const</td></tr>
<tr class="memdesc:a4449eb06a51355c995f0a1a5bbfe9c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_total_bytes_received  <a href="classMQTT__NS_1_1endpoint.html#a4449eb06a51355c995f0a1a5bbfe9c1e">More...</a><br /></td></tr>
<tr class="separator:a4449eb06a51355c995f0a1a5bbfe9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34fd1beb49cba6b069a544aadbf878c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae34fd1beb49cba6b069a544aadbf878c">get_total_bytes_sent</a> () const</td></tr>
<tr class="memdesc:ae34fd1beb49cba6b069a544aadbf878c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_total_bytes_sent  <a href="classMQTT__NS_1_1endpoint.html#ae34fd1beb49cba6b069a544aadbf878c">More...</a><br /></td></tr>
<tr class="separator:ae34fd1beb49cba6b069a544aadbf878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfd0bd245770caa1ef8e03a76aa64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acabfd0bd245770caa1ef8e03a76aa64f">set_auto_pub_response</a> (bool b=true, bool async=true)</td></tr>
<tr class="memdesc:acabfd0bd245770caa1ef8e03a76aa64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set auto publish response mode.  <a href="classMQTT__NS_1_1endpoint.html#acabfd0bd245770caa1ef8e03a76aa64f">More...</a><br /></td></tr>
<tr class="separator:acabfd0bd245770caa1ef8e03a76aa64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff4c5e845c5b4d5904bcf0a11eca37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abff4c5e845c5b4d5904bcf0a11eca37c">set_auto_replace_topic_alias_send</a> (bool b=true)</td></tr>
<tr class="separator:abff4c5e845c5b4d5904bcf0a11eca37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab936aa635400f77eeaff109656ffbf0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab936aa635400f77eeaff109656ffbf0c">set_packet_bulk_read_limit</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="separator:ab936aa635400f77eeaff109656ffbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b1d2e8898e9cda6f8f4441ce663408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a71b1d2e8898e9cda6f8f4441ce663408">set_props_bulk_read_limit</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="separator:a71b1d2e8898e9cda6f8f4441ce663408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce134b027d9313ef79bf622659ed45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4ce134b027d9313ef79bf622659ed45d">start_session</a> (any session_life_keeper=any())</td></tr>
<tr class="memdesc:a4ce134b027d9313ef79bf622659ed45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">start session with a connected endpoint.  <a href="classMQTT__NS_1_1endpoint.html#a4ce134b027d9313ef79bf622659ed45d">More...</a><br /></td></tr>
<tr class="separator:a4ce134b027d9313ef79bf622659ed45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122a797f9904c13a8fbde624dec9fb9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:a2122a797f9904c13a8fbde624dec9fb9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2122a797f9904c13a8fbde624dec9fb9">publish</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:a2122a797f9904c13a8fbde624dec9fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#a2122a797f9904c13a8fbde624dec9fb9">More...</a><br /></td></tr>
<tr class="separator:a2122a797f9904c13a8fbde624dec9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac638b33a024c3288baaf9a69928b147a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:ac638b33a024c3288baaf9a69928b147a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac638b33a024c3288baaf9a69928b147a">subscribe</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:ac638b33a024c3288baaf9a69928b147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ac638b33a024c3288baaf9a69928b147a">More...</a><br /></td></tr>
<tr class="separator:ac638b33a024c3288baaf9a69928b147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfdc7647cee774547f857f0a65e9c32"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:acdfdc7647cee774547f857f0a65e9c32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acdfdc7647cee774547f857f0a65e9c32">unsubscribe</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:acdfdc7647cee774547f857f0a65e9c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#acdfdc7647cee774547f857f0a65e9c32">More...</a><br /></td></tr>
<tr class="separator:acdfdc7647cee774547f857f0a65e9c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3d3198305da5ba6b9d3c0f6e4a0168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168">disconnect</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a> reason=<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442a31fe45844c214ec5ad8d824be3709a8d">v5::disconnect_reason_code::normal_disconnection</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a5c3d3198305da5ba6b9d3c0f6e4a0168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
  <a href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168">More...</a><br /></td></tr>
<tr class="separator:a5c3d3198305da5ba6b9d3c0f6e4a0168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340f9768dfcb465f5a368244d27d8dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac">force_disconnect</a> ()</td></tr>
<tr class="memdesc:a340f9768dfcb465f5a368244d27d8dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br  />
  <a href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac">More...</a><br /></td></tr>
<tr class="separator:a340f9768dfcb465f5a368244d27d8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac4e03f9b9971fd33264806b98b512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae0ac4e03f9b9971fd33264806b98b512">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts={}, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={}, any life_keeper={})</td></tr>
<tr class="memdesc:ae0ac4e03f9b9971fd33264806b98b512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ae0ac4e03f9b9971fd33264806b98b512">More...</a><br /></td></tr>
<tr class="separator:ae0ac4e03f9b9971fd33264806b98b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9841d7e52b11cbcfee2800edb253af81"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a9841d7e52b11cbcfee2800edb253af81"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; as::is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9841d7e52b11cbcfee2800edb253af81">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, ConstBufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, any life_keeper)</td></tr>
<tr class="memdesc:a9841d7e52b11cbcfee2800edb253af81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a9841d7e52b11cbcfee2800edb253af81">More...</a><br /></td></tr>
<tr class="separator:a9841d7e52b11cbcfee2800edb253af81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8003e60961de0b10342ec68b694b3108"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8003e60961de0b10342ec68b694b3108"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; as::is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8003e60961de0b10342ec68b694b3108">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, ConstBufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, any life_keeper)</td></tr>
<tr class="memdesc:a8003e60961de0b10342ec68b694b3108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a8003e60961de0b10342ec68b694b3108">More...</a><br /></td></tr>
<tr class="separator:a8003e60961de0b10342ec68b694b3108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9545e8a331cea70f0c24203fbe669ce6"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a9545e8a331cea70f0c24203fbe669ce6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt; BufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9545e8a331cea70f0c24203fbe669ce6">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, BufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts={}, any life_keeper={})</td></tr>
<tr class="memdesc:a9545e8a331cea70f0c24203fbe669ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a9545e8a331cea70f0c24203fbe669ce6">More...</a><br /></td></tr>
<tr class="separator:a9545e8a331cea70f0c24203fbe669ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3340717ebfd97f44b62d3adfc506d0"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:adb3340717ebfd97f44b62d3adfc506d0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt; BufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adb3340717ebfd97f44b62d3adfc506d0">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, BufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, any life_keeper={})</td></tr>
<tr class="memdesc:adb3340717ebfd97f44b62d3adfc506d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#adb3340717ebfd97f44b62d3adfc506d0">More...</a><br /></td></tr>
<tr class="separator:adb3340717ebfd97f44b62d3adfc506d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad928c00260f7a2cce1740ac0f5aaf70e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad928c00260f7a2cce1740ac0f5aaf70e">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:ad928c00260f7a2cce1740ac0f5aaf70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ad928c00260f7a2cce1740ac0f5aaf70e">More...</a><br /></td></tr>
<tr class="separator:ad928c00260f7a2cce1740ac0f5aaf70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd2e73406ab3cdff507839d70334b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad3bd2e73406ab3cdff507839d70334b0">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:ad3bd2e73406ab3cdff507839d70334b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ad3bd2e73406ab3cdff507839d70334b0">More...</a><br /></td></tr>
<tr class="separator:ad3bd2e73406ab3cdff507839d70334b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5755ae7555bda911f5d0d4fe07b50941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5755ae7555bda911f5d0d4fe07b50941">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a5755ae7555bda911f5d0d4fe07b50941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a5755ae7555bda911f5d0d4fe07b50941">More...</a><br /></td></tr>
<tr class="separator:a5755ae7555bda911f5d0d4fe07b50941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81ba461fc8ab3dbd506f1037b49ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aad81ba461fc8ab3dbd506f1037b49ba8">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:aad81ba461fc8ab3dbd506f1037b49ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#aad81ba461fc8ab3dbd506f1037b49ba8">More...</a><br /></td></tr>
<tr class="separator:aad81ba461fc8ab3dbd506f1037b49ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8ba5667cc5728610463506a98a23b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afa8ba5667cc5728610463506a98a23b3">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_filter, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:afa8ba5667cc5728610463506a98a23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#afa8ba5667cc5728610463506a98a23b3">More...</a><br /></td></tr>
<tr class="separator:afa8ba5667cc5728610463506a98a23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b9cdc305a9de72a91ea23ff500101a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a64b9cdc305a9de72a91ea23ff500101a">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_filter, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a64b9cdc305a9de72a91ea23ff500101a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a64b9cdc305a9de72a91ea23ff500101a">More...</a><br /></td></tr>
<tr class="separator:a64b9cdc305a9de72a91ea23ff500101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9780e37643be9f3d0acc95b95c4c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af0b9780e37643be9f3d0acc95b95c4c8">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:af0b9780e37643be9f3d0acc95b95c4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#af0b9780e37643be9f3d0acc95b95c4c8">More...</a><br /></td></tr>
<tr class="separator:af0b9780e37643be9f3d0acc95b95c4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a6af2f4557e8cdd830c05810a9c1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a18a6af2f4557e8cdd830c05810a9c1b4">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a18a6af2f4557e8cdd830c05810a9c1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a18a6af2f4557e8cdd830c05810a9c1b4">More...</a><br /></td></tr>
<tr class="separator:a18a6af2f4557e8cdd830c05810a9c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840b82d26af00c23dd41a492d47dd64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2840b82d26af00c23dd41a492d47dd64">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a2840b82d26af00c23dd41a492d47dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a2840b82d26af00c23dd41a492d47dd64">More...</a><br /></td></tr>
<tr class="separator:a2840b82d26af00c23dd41a492d47dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6073e6c1a564756c1cb350f20650b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af6073e6c1a564756c1cb350f20650b95">pingreq</a> ()</td></tr>
<tr class="memdesc:af6073e6c1a564756c1cb350f20650b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>.  <a href="classMQTT__NS_1_1endpoint.html#af6073e6c1a564756c1cb350f20650b95">More...</a><br /></td></tr>
<tr class="separator:af6073e6c1a564756c1cb350f20650b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9163ebce3564d4bbcdb45ca6ca3718f7">pingresp</a> ()</td></tr>
<tr class="memdesc:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>.  <a href="classMQTT__NS_1_1endpoint.html#a9163ebce3564d4bbcdb45ca6ca3718f7">More...</a><br /></td></tr>
<tr class="separator:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976536019598132e1eefc9bf74da3ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a976536019598132e1eefc9bf74da3ddd">auth</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edefa260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a976536019598132e1eefc9bf74da3ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>.  <a href="classMQTT__NS_1_1endpoint.html#a976536019598132e1eefc9bf74da3ddd">More...</a><br /></td></tr>
<tr class="separator:a976536019598132e1eefc9bf74da3ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2604ecbd5ea98e18e6ec41fd21911b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2604ecbd5ea98e18e6ec41fd21911b18">connect</a> (std::string const &amp;client_id, optional&lt; std::string &gt; const &amp;user_name, optional&lt; std::string &gt; const &amp;password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a2604ecbd5ea98e18e6ec41fd21911b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a2604ecbd5ea98e18e6ec41fd21911b18">More...</a><br /></td></tr>
<tr class="separator:a2604ecbd5ea98e18e6ec41fd21911b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8262e0105321d1757e165f6468447f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac8262e0105321d1757e165f6468447f6">connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:ac8262e0105321d1757e165f6468447f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#ac8262e0105321d1757e165f6468447f6">More...</a><br /></td></tr>
<tr class="separator:ac8262e0105321d1757e165f6468447f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5330b0b2c4a29a8c61663cd9a3e67d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aee5330b0b2c4a29a8c61663cd9a3e67d">connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:aee5330b0b2c4a29a8c61663cd9a3e67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#aee5330b0b2c4a29a8c61663cd9a3e67d">More...</a><br /></td></tr>
<tr class="separator:aee5330b0b2c4a29a8c61663cd9a3e67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd636fb096675d2d760b96f6bd0aa51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7cd636fb096675d2d760b96f6bd0aa51">puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7da260ca9dd8a4577fc00b7bd5810298076">v5::puback_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a7cd636fb096675d2d760b96f6bd0aa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#a7cd636fb096675d2d760b96f6bd0aa51">More...</a><br /></td></tr>
<tr class="separator:a7cd636fb096675d2d760b96f6bd0aa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88387690236c708daac8083a7f6be68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab88387690236c708daac8083a7f6be68">pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4ca260ca9dd8a4577fc00b7bd5810298076">v5::pubrec_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:ab88387690236c708daac8083a7f6be68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send packet.  <a href="classMQTT__NS_1_1endpoint.html#ab88387690236c708daac8083a7f6be68">More...</a><br /></td></tr>
<tr class="separator:ab88387690236c708daac8083a7f6be68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13def035f0198369cf98e29460fee09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a13def035f0198369cf98e29460fee09f">pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55cea260ca9dd8a4577fc00b7bd5810298076">v5::pubrel_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={}, any life_keeper={})</td></tr>
<tr class="memdesc:a13def035f0198369cf98e29460fee09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#a13def035f0198369cf98e29460fee09f">More...</a><br /></td></tr>
<tr class="separator:a13def035f0198369cf98e29460fee09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af445953a02866e9eea2b4397c33162cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af445953a02866e9eea2b4397c33162cb">pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903a260ca9dd8a4577fc00b7bd5810298076">v5::pubcomp_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:af445953a02866e9eea2b4397c33162cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#af445953a02866e9eea2b4397c33162cb">More...</a><br /></td></tr>
<tr class="separator:af445953a02866e9eea2b4397c33162cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b833460c24968c8d8a898ad4862cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a36b833460c24968c8d8a898ad4862cf3">suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a36b833460c24968c8d8a898ad4862cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a36b833460c24968c8d8a898ad4862cf3">More...</a><br /></td></tr>
<tr class="separator:a36b833460c24968c8d8a898ad4862cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ade37f6ff8e6d538f39f126869ec64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a76ade37f6ff8e6d538f39f126869ec64">suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a76ade37f6ff8e6d538f39f126869ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a76ade37f6ff8e6d538f39f126869ec64">More...</a><br /></td></tr>
<tr class="separator:a76ade37f6ff8e6d538f39f126869ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1fad6ceb5599d28d1f97c0d2053d129a">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a1fad6ceb5599d28d1f97c0d2053d129a">More...</a><br /></td></tr>
<tr class="separator:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a22ff11f06c2a3d1a4cf40963fdd606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7a22ff11f06c2a3d1a4cf40963fdd606">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:a7a22ff11f06c2a3d1a4cf40963fdd606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a7a22ff11f06c2a3d1a4cf40963fdd606">More...</a><br /></td></tr>
<tr class="separator:a7a22ff11f06c2a3d1a4cf40963fdd606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b2098ddcb6c4aeb2946fb8484e391b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa5b2098ddcb6c4aeb2946fb8484e391b">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={})</td></tr>
<tr class="memdesc:aa5b2098ddcb6c4aeb2946fb8484e391b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#aa5b2098ddcb6c4aeb2946fb8484e391b">More...</a><br /></td></tr>
<tr class="separator:aa5b2098ddcb6c4aeb2946fb8484e391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6acc15cef8803299cacf874319818b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:aa6acc15cef8803299cacf874319818b2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa6acc15cef8803299cacf874319818b2">async_publish</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:aa6acc15cef8803299cacf874319818b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#aa6acc15cef8803299cacf874319818b2">More...</a><br /></td></tr>
<tr class="separator:aa6acc15cef8803299cacf874319818b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4f14e205e649f130db4903e43b7e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aca4f14e205e649f130db4903e43b7e4b">async_disconnect</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:aca4f14e205e649f130db4903e43b7e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="classMQTT__NS_1_1endpoint.html#aca4f14e205e649f130db4903e43b7e4b">More...</a><br /></td></tr>
<tr class="separator:aca4f14e205e649f130db4903e43b7e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ace4ba483c42831c1977004604041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7e3ace4ba483c42831c1977004604041">async_disconnect</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a> reason, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a7e3ace4ba483c42831c1977004604041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="classMQTT__NS_1_1endpoint.html#a7e3ace4ba483c42831c1977004604041">More...</a><br /></td></tr>
<tr class="separator:a7e3ace4ba483c42831c1977004604041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f03591552db167ed61e36844952515"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:ad4f03591552db167ed61e36844952515"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad4f03591552db167ed61e36844952515">async_subscribe</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:ad4f03591552db167ed61e36844952515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ad4f03591552db167ed61e36844952515">More...</a><br /></td></tr>
<tr class="separator:ad4f03591552db167ed61e36844952515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df77c087e7798f781497460d3f54b3b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Params&gt; </td></tr>
<tr class="memitem:a4df77c087e7798f781497460d3f54b3b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ! std::is_convertible&lt; std::decay_t&lt; T &gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4df77c087e7798f781497460d3f54b3b">async_unsubscribe</a> (T &amp;&amp;t, Params &amp;&amp;... params)</td></tr>
<tr class="memdesc:a4df77c087e7798f781497460d3f54b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4df77c087e7798f781497460d3f54b3b">More...</a><br /></td></tr>
<tr class="separator:a4df77c087e7798f781497460d3f54b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f239b956aea0c6d2472898d9e48a95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1f239b956aea0c6d2472898d9e48a95a">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a1f239b956aea0c6d2472898d9e48a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a1f239b956aea0c6d2472898d9e48a95a">More...</a><br /></td></tr>
<tr class="separator:a1f239b956aea0c6d2472898d9e48a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5172d1d85911e893bb5c932dd8635e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3e5172d1d85911e893bb5c932dd8635e">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a3e5172d1d85911e893bb5c932dd8635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a3e5172d1d85911e893bb5c932dd8635e">More...</a><br /></td></tr>
<tr class="separator:a3e5172d1d85911e893bb5c932dd8635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86556113db679faa0d369ee79b08846e"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a86556113db679faa0d369ee79b08846e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; as::is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a86556113db679faa0d369ee79b08846e">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, ConstBufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts={}, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a86556113db679faa0d369ee79b08846e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a86556113db679faa0d369ee79b08846e">More...</a><br /></td></tr>
<tr class="separator:a86556113db679faa0d369ee79b08846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b04a5dea51912ebbd56130ca29c4c"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac48b04a5dea51912ebbd56130ca29c4c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; as::is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac48b04a5dea51912ebbd56130ca29c4c">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, ConstBufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ac48b04a5dea51912ebbd56130ca29c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ac48b04a5dea51912ebbd56130ca29c4c">More...</a><br /></td></tr>
<tr class="separator:ac48b04a5dea51912ebbd56130ca29c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58a19525c5613bab04f867a8f03c392"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:af58a19525c5613bab04f867a8f03c392"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt; BufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af58a19525c5613bab04f867a8f03c392">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, BufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts={}, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:af58a19525c5613bab04f867a8f03c392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#af58a19525c5613bab04f867a8f03c392">More...</a><br /></td></tr>
<tr class="separator:af58a19525c5613bab04f867a8f03c392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4860fe4156611c9dad32bec9f5a01"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:ac8d4860fe4156611c9dad32bec9f5a01"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt; BufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac8d4860fe4156611c9dad32bec9f5a01">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, BufferSequence contents, <a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a> pubopts, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ac8d4860fe4156611c9dad32bec9f5a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ac8d4860fe4156611c9dad32bec9f5a01">More...</a><br /></td></tr>
<tr class="separator:ac8d4860fe4156611c9dad32bec9f5a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1333ea0e561e36c321be73a787fa2919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1333ea0e561e36c321be73a787fa2919">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a1333ea0e561e36c321be73a787fa2919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a1333ea0e561e36c321be73a787fa2919">More...</a><br /></td></tr>
<tr class="separator:a1333ea0e561e36c321be73a787fa2919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef18f9c0b493ea572d7f4b4d2b5df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5fef18f9c0b493ea572d7f4b4d2b5df2">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a5fef18f9c0b493ea572d7f4b4d2b5df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a5fef18f9c0b493ea572d7f4b4d2b5df2">More...</a><br /></td></tr>
<tr class="separator:a5fef18f9c0b493ea572d7f4b4d2b5df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb9163e7bada6110d8ff0df2baae20b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aedb9163e7bada6110d8ff0df2baae20b">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:aedb9163e7bada6110d8ff0df2baae20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#aedb9163e7bada6110d8ff0df2baae20b">More...</a><br /></td></tr>
<tr class="separator:aedb9163e7bada6110d8ff0df2baae20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c16c80d9d84ddc70f4980f6afe8c46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9c16c80d9d84ddc70f4980f6afe8c46e">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a9c16c80d9d84ddc70f4980f6afe8c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a9c16c80d9d84ddc70f4980f6afe8c46e">More...</a><br /></td></tr>
<tr class="separator:a9c16c80d9d84ddc70f4980f6afe8c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680b73d11c2c572229e4ea14290754ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a680b73d11c2c572229e4ea14290754ff">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a680b73d11c2c572229e4ea14290754ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a680b73d11c2c572229e4ea14290754ff">More...</a><br /></td></tr>
<tr class="separator:a680b73d11c2c572229e4ea14290754ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087cd4e62c27a5237abda417e8e0e173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a087cd4e62c27a5237abda417e8e0e173">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_filter, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a087cd4e62c27a5237abda417e8e0e173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a087cd4e62c27a5237abda417e8e0e173">More...</a><br /></td></tr>
<tr class="separator:a087cd4e62c27a5237abda417e8e0e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962fd8bbf17d0fd0a3b248d671773e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a962fd8bbf17d0fd0a3b248d671773e72">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a962fd8bbf17d0fd0a3b248d671773e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a962fd8bbf17d0fd0a3b248d671773e72">More...</a><br /></td></tr>
<tr class="separator:a962fd8bbf17d0fd0a3b248d671773e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10735355ed752fbbb16387c7ed9df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0d10735355ed752fbbb16387c7ed9df7">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a0d10735355ed752fbbb16387c7ed9df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a0d10735355ed752fbbb16387c7ed9df7">More...</a><br /></td></tr>
<tr class="separator:a0d10735355ed752fbbb16387c7ed9df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e95060da3a5d7a13aa5d43092466c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a69e95060da3a5d7a13aa5d43092466c2">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a69e95060da3a5d7a13aa5d43092466c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a69e95060da3a5d7a13aa5d43092466c2">More...</a><br /></td></tr>
<tr class="separator:a69e95060da3a5d7a13aa5d43092466c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e4e8a6bdb4695b46fd1b5832ecb0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a67e4e8a6bdb4695b46fd1b5832ecb0ed">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a67e4e8a6bdb4695b46fd1b5832ecb0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a67e4e8a6bdb4695b46fd1b5832ecb0ed">More...</a><br /></td></tr>
<tr class="separator:a67e4e8a6bdb4695b46fd1b5832ecb0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a732620985bd2c8157d8f229340b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0a8a732620985bd2c8157d8f229340b4">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a0a8a732620985bd2c8157d8f229340b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a0a8a732620985bd2c8157d8f229340b4">More...</a><br /></td></tr>
<tr class="separator:a0a8a732620985bd2c8157d8f229340b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e71a3aefd8b250395525aef1b1d1b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2e71a3aefd8b250395525aef1b1d1b9d">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a2e71a3aefd8b250395525aef1b1d1b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a2e71a3aefd8b250395525aef1b1d1b9d">More...</a><br /></td></tr>
<tr class="separator:a2e71a3aefd8b250395525aef1b1d1b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99285a401ee98b3804ea885120ae9c5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a99285a401ee98b3804ea885120ae9c5c">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_filter, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a99285a401ee98b3804ea885120ae9c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a99285a401ee98b3804ea885120ae9c5c">More...</a><br /></td></tr>
<tr class="separator:a99285a401ee98b3804ea885120ae9c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322f1c786c076732089751285538cb9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a322f1c786c076732089751285538cb9c">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_filter, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a322f1c786c076732089751285538cb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a322f1c786c076732089751285538cb9c">More...</a><br /></td></tr>
<tr class="separator:a322f1c786c076732089751285538cb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f9119d138c26741f081ad806562ac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a51f9119d138c26741f081ad806562ac5">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_filter, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a51f9119d138c26741f081ad806562ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a51f9119d138c26741f081ad806562ac5">More...</a><br /></td></tr>
<tr class="separator:a51f9119d138c26741f081ad806562ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1041054526b376ede83e0e4f278f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aaf1041054526b376ede83e0e4f278f59">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_filter, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:aaf1041054526b376ede83e0e4f278f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aaf1041054526b376ede83e0e4f278f59">More...</a><br /></td></tr>
<tr class="separator:aaf1041054526b376ede83e0e4f278f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc80eca694c8a00cdcd016690c7954a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acdc80eca694c8a00cdcd016690c7954a">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:acdc80eca694c8a00cdcd016690c7954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#acdc80eca694c8a00cdcd016690c7954a">More...</a><br /></td></tr>
<tr class="separator:acdc80eca694c8a00cdcd016690c7954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d5e6673351a33f52a9a2d217e53e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adc3d5e6673351a33f52a9a2d217e53e6">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:adc3d5e6673351a33f52a9a2d217e53e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#adc3d5e6673351a33f52a9a2d217e53e6">More...</a><br /></td></tr>
<tr class="separator:adc3d5e6673351a33f52a9a2d217e53e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f22eafbd2caad2b8d56357d85f2ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a44f22eafbd2caad2b8d56357d85f2ac2">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a44f22eafbd2caad2b8d56357d85f2ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a44f22eafbd2caad2b8d56357d85f2ac2">More...</a><br /></td></tr>
<tr class="separator:a44f22eafbd2caad2b8d56357d85f2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35975e5f3bd9046f1d5689e2ddd951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2a35975e5f3bd9046f1d5689e2ddd951">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a2a35975e5f3bd9046f1d5689e2ddd951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a2a35975e5f3bd9046f1d5689e2ddd951">More...</a><br /></td></tr>
<tr class="separator:a2a35975e5f3bd9046f1d5689e2ddd951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ff54f16c07bb6e6774e646cbc27004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac5ff54f16c07bb6e6774e646cbc27004">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ac5ff54f16c07bb6e6774e646cbc27004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ac5ff54f16c07bb6e6774e646cbc27004">More...</a><br /></td></tr>
<tr class="separator:ac5ff54f16c07bb6e6774e646cbc27004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d9472baa8d936ae9733d78e82aae03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a94d9472baa8d936ae9733d78e82aae03">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a94d9472baa8d936ae9733d78e82aae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a94d9472baa8d936ae9733d78e82aae03">More...</a><br /></td></tr>
<tr class="separator:a94d9472baa8d936ae9733d78e82aae03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba980320a69c7855ec39c0d4c54be63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acba980320a69c7855ec39c0d4c54be63">async_pingreq</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:acba980320a69c7855ec39c0d4c54be63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet.  <a href="classMQTT__NS_1_1endpoint.html#acba980320a69c7855ec39c0d4c54be63">More...</a><br /></td></tr>
<tr class="separator:acba980320a69c7855ec39c0d4c54be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4faf45939505b6d22cac4d77e809d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0fe4faf45939505b6d22cac4d77e809d">async_pingresp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a0fe4faf45939505b6d22cac4d77e809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a0fe4faf45939505b6d22cac4d77e809d">More...</a><br /></td></tr>
<tr class="separator:a0fe4faf45939505b6d22cac4d77e809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e539eda565875dc30417b615077f1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2e539eda565875dc30417b615077f1ff">async_auth</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edefa260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a2e539eda565875dc30417b615077f1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet.  <a href="classMQTT__NS_1_1endpoint.html#a2e539eda565875dc30417b615077f1ff">More...</a><br /></td></tr>
<tr class="separator:a2e539eda565875dc30417b615077f1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1baca693ccbf7db65f7bbcfded853f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4a1baca693ccbf7db65f7bbcfded853f">async_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a4a1baca693ccbf7db65f7bbcfded853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a4a1baca693ccbf7db65f7bbcfded853f">More...</a><br /></td></tr>
<tr class="separator:a4a1baca693ccbf7db65f7bbcfded853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb11c2c933459f4c890b45ad8679891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2cb11c2c933459f4c890b45ad8679891">async_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a2cb11c2c933459f4c890b45ad8679891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a2cb11c2c933459f4c890b45ad8679891">More...</a><br /></td></tr>
<tr class="separator:a2cb11c2c933459f4c890b45ad8679891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f66cc8f3ac1196a2b7f87d26ec8edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a58f66cc8f3ac1196a2b7f87d26ec8edb">async_connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a58f66cc8f3ac1196a2b7f87d26ec8edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a58f66cc8f3ac1196a2b7f87d26ec8edb">More...</a><br /></td></tr>
<tr class="separator:a58f66cc8f3ac1196a2b7f87d26ec8edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac453a08e11e70495e424b71d83101b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac453a08e11e70495e424b71d83101b27">async_connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ac453a08e11e70495e424b71d83101b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ac453a08e11e70495e424b71d83101b27">More...</a><br /></td></tr>
<tr class="separator:ac453a08e11e70495e424b71d83101b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73">async_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73">More...</a><br /></td></tr>
<tr class="separator:ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6673ec20b1891e470a713fd6800660da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6673ec20b1891e470a713fd6800660da">async_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a> reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a6673ec20b1891e470a713fd6800660da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#a6673ec20b1891e470a713fd6800660da">More...</a><br /></td></tr>
<tr class="separator:a6673ec20b1891e470a713fd6800660da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f707530ee64a9cac7211fe64cce3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad3f707530ee64a9cac7211fe64cce3d3">async_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ad3f707530ee64a9cac7211fe64cce3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="classMQTT__NS_1_1endpoint.html#ad3f707530ee64a9cac7211fe64cce3d3">More...</a><br /></td></tr>
<tr class="separator:ad3f707530ee64a9cac7211fe64cce3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2df5ccbf0bffea0df3f2462cfb7acab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab2df5ccbf0bffea0df3f2462cfb7acab">async_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a> reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ab2df5ccbf0bffea0df3f2462cfb7acab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="classMQTT__NS_1_1endpoint.html#ab2df5ccbf0bffea0df3f2462cfb7acab">More...</a><br /></td></tr>
<tr class="separator:ab2df5ccbf0bffea0df3f2462cfb7acab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2baa14e7b1373f3f918176c1d66f9e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac2baa14e7b1373f3f918176c1d66f9e6">async_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ac2baa14e7b1373f3f918176c1d66f9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#ac2baa14e7b1373f3f918176c1d66f9e6">More...</a><br /></td></tr>
<tr class="separator:ac2baa14e7b1373f3f918176c1d66f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613e6b9b53f025422aaac81529a1c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af613e6b9b53f025422aaac81529a1c30">async_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a> reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props={}, any life_keeper={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:af613e6b9b53f025422aaac81529a1c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#af613e6b9b53f025422aaac81529a1c30">More...</a><br /></td></tr>
<tr class="separator:af613e6b9b53f025422aaac81529a1c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a89add1bcd55da883a487c0b8fb06a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3a89add1bcd55da883a487c0b8fb06a3">async_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a3a89add1bcd55da883a487c0b8fb06a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#a3a89add1bcd55da883a487c0b8fb06a3">More...</a><br /></td></tr>
<tr class="separator:a3a89add1bcd55da883a487c0b8fb06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33d2b8ae33769fea3124cb6891fbaa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae33d2b8ae33769fea3124cb6891fbaa2">async_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a> reason_code, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ae33d2b8ae33769fea3124cb6891fbaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#ae33d2b8ae33769fea3124cb6891fbaa2">More...</a><br /></td></tr>
<tr class="separator:ae33d2b8ae33769fea3124cb6891fbaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc5e59f1c48ab211a60a9ace01e5658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3cc5e59f1c48ab211a60a9ace01e5658">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a3cc5e59f1c48ab211a60a9ace01e5658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a3cc5e59f1c48ab211a60a9ace01e5658">More...</a><br /></td></tr>
<tr class="separator:a3cc5e59f1c48ab211a60a9ace01e5658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada90956428632c33b6a9a5f81d874b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7ada90956428632c33b6a9a5f81d874b">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a7ada90956428632c33b6a9a5f81d874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a7ada90956428632c33b6a9a5f81d874b">More...</a><br /></td></tr>
<tr class="separator:a7ada90956428632c33b6a9a5f81d874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cab1c916e9b1a451ded59e12f12e5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a51cab1c916e9b1a451ded59e12f12e5c">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a51cab1c916e9b1a451ded59e12f12e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a51cab1c916e9b1a451ded59e12f12e5c">More...</a><br /></td></tr>
<tr class="separator:a51cab1c916e9b1a451ded59e12f12e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb007ffeabe2f2c69048485ce06931a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afb007ffeabe2f2c69048485ce06931a7">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:afb007ffeabe2f2c69048485ce06931a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#afb007ffeabe2f2c69048485ce06931a7">More...</a><br /></td></tr>
<tr class="separator:afb007ffeabe2f2c69048485ce06931a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46adb55ce6aab5dc2b5be8cecd7af9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af46adb55ce6aab5dc2b5be8cecd7af9e">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:af46adb55ce6aab5dc2b5be8cecd7af9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#af46adb55ce6aab5dc2b5be8cecd7af9e">More...</a><br /></td></tr>
<tr class="separator:af46adb55ce6aab5dc2b5be8cecd7af9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9b2c41518efec0c532166ecd1dee62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2c9b2c41518efec0c532166ecd1dee62">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a2c9b2c41518efec0c532166ecd1dee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a2c9b2c41518efec0c532166ecd1dee62">More...</a><br /></td></tr>
<tr class="separator:a2c9b2c41518efec0c532166ecd1dee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df35344e3cba6367b410a4bb6832a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6df35344e3cba6367b410a4bb6832a56">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a6df35344e3cba6367b410a4bb6832a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a6df35344e3cba6367b410a4bb6832a56">More...</a><br /></td></tr>
<tr class="separator:a6df35344e3cba6367b410a4bb6832a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c6ef4a06f30e02a1d111808dd44bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab4c6ef4a06f30e02a1d111808dd44bc6">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a> props, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:ab4c6ef4a06f30e02a1d111808dd44bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ab4c6ef4a06f30e02a1d111808dd44bc6">More...</a><br /></td></tr>
<tr class="separator:ab4c6ef4a06f30e02a1d111808dd44bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bce36b9aed6dcf1766f499e5810610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a03bce36b9aed6dcf1766f499e5810610">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func={})</td></tr>
<tr class="memdesc:a03bce36b9aed6dcf1766f499e5810610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send ununsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a03bce36b9aed6dcf1766f499e5810610">More...</a><br /></td></tr>
<tr class="separator:a03bce36b9aed6dcf1766f499e5810610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5859b47639e05d71bc5727c90747a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acc5859b47639e05d71bc5727c90747a6">clear_stored_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:acc5859b47639e05d71bc5727c90747a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stored publish message that has packet_id.  <a href="classMQTT__NS_1_1endpoint.html#acc5859b47639e05d71bc5727c90747a6">More...</a><br /></td></tr>
<tr class="separator:acc5859b47639e05d71bc5727c90747a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad0b9951be47e922c919275e08dc1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3cad0b9951be47e922c919275e08dc1a">for_each_store</a> (std::function&lt; void(char const *, std::size_t)&gt; const &amp;f)</td></tr>
<tr class="memdesc:a3cad0b9951be47e922c919275e08dc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="classMQTT__NS_1_1endpoint.html#a3cad0b9951be47e922c919275e08dc1a">More...</a><br /></td></tr>
<tr class="separator:a3cad0b9951be47e922c919275e08dc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f5b67e45a7591a1ddb6f241999570d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac9f5b67e45a7591a1ddb6f241999570d">for_each_store</a> (std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;)&gt; const &amp;f)</td></tr>
<tr class="memdesc:ac9f5b67e45a7591a1ddb6f241999570d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="classMQTT__NS_1_1endpoint.html#ac9f5b67e45a7591a1ddb6f241999570d">More...</a><br /></td></tr>
<tr class="separator:ac9f5b67e45a7591a1ddb6f241999570d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3205579946e26234a9aa094d6f88a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adf3205579946e26234a9aa094d6f88a7">for_each_store_with_life_keeper</a> (std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;, any)&gt; const &amp;f)</td></tr>
<tr class="memdesc:adf3205579946e26234a9aa094d6f88a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="classMQTT__NS_1_1endpoint.html#adf3205579946e26234a9aa094d6f88a7">More...</a><br /></td></tr>
<tr class="separator:adf3205579946e26234a9aa094d6f88a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa3f4cdeb5c5ad02c0d7af643b5f47343">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structMQTT__NS_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="classMQTT__NS_1_1endpoint.html#aa3f4cdeb5c5ad02c0d7af643b5f47343">More...</a><br /></td></tr>
<tr class="separator:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b2f21d533b51d1975ce7e9c5d5a3f"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a894b2f21d533b51d1975ce7e9c5d5a3f">acquire_unique_packet_id_no_except</a> ()</td></tr>
<tr class="memdesc:a894b2f21d533b51d1975ce7e9c5d5a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the new unique packet id. If all packet ids are already in use, then returns nullopt After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="classMQTT__NS_1_1endpoint.html#a894b2f21d533b51d1975ce7e9c5d5a3f">More...</a><br /></td></tr>
<tr class="separator:a894b2f21d533b51d1975ce7e9c5d5a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36d39d8679fe97e5a68c4163f483d27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad36d39d8679fe97e5a68c4163f483d27">register_packet_id</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:ad36d39d8679fe97e5a68c4163f483d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="classMQTT__NS_1_1endpoint.html#ad36d39d8679fe97e5a68c4163f483d27">More...</a><br /></td></tr>
<tr class="separator:ad36d39d8679fe97e5a68c4163f483d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d90ba2b897d685115ef4cc6bd58175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a65d90ba2b897d685115ef4cc6bd58175">release_packet_id</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a65d90ba2b897d685115ef4cc6bd58175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packet_id.  <a href="classMQTT__NS_1_1endpoint.html#a65d90ba2b897d685115ef4cc6bd58175">More...</a><br /></td></tr>
<tr class="separator:a65d90ba2b897d685115ef4cc6bd58175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a5640a4575a7a3e0a603cfa88f2e43"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ab2a5640a4575a7a3e0a603cfa88f2e43"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab2a5640a4575a7a3e0a603cfa88f2e43">restore_serialized_message</a> (Iterator b, Iterator e)</td></tr>
<tr class="memdesc:ab2a5640a4575a7a3e0a603cfa88f2e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#ab2a5640a4575a7a3e0a603cfa88f2e43">More...</a><br /></td></tr>
<tr class="separator:ab2a5640a4575a7a3e0a603cfa88f2e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac884bd8af142285b71bc2897975a048a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac884bd8af142285b71bc2897975a048a">restore_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper={})</td></tr>
<tr class="memdesc:ac884bd8af142285b71bc2897975a048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#ac884bd8af142285b71bc2897975a048a">More...</a><br /></td></tr>
<tr class="separator:ac884bd8af142285b71bc2897975a048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0689df35a3c8957419b12947cb63fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa0689df35a3c8957419b12947cb63fcb">restore_serialized_message</a> (<a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper={})</td></tr>
<tr class="memdesc:aa0689df35a3c8957419b12947cb63fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#aa0689df35a3c8957419b12947cb63fcb">More...</a><br /></td></tr>
<tr class="separator:aa0689df35a3c8957419b12947cb63fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb659a33611b7f11ef1235bd89ef9b32"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:acb659a33611b7f11ef1235bd89ef9b32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acb659a33611b7f11ef1235bd89ef9b32">restore_v5_serialized_message</a> (Iterator b, Iterator e)</td></tr>
<tr class="memdesc:acb659a33611b7f11ef1235bd89ef9b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#acb659a33611b7f11ef1235bd89ef9b32">More...</a><br /></td></tr>
<tr class="separator:acb659a33611b7f11ef1235bd89ef9b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2f6e697216d4990716362e2eeb67a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae0b2f6e697216d4990716362e2eeb67a">restore_v5_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper={})</td></tr>
<tr class="memdesc:ae0b2f6e697216d4990716362e2eeb67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#ae0b2f6e697216d4990716362e2eeb67a">More...</a><br /></td></tr>
<tr class="separator:ae0b2f6e697216d4990716362e2eeb67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96100c7687e83ebc8d20c9233df8f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af96100c7687e83ebc8d20c9233df8f0d">restore_v5_serialized_message</a> (<a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper={})</td></tr>
<tr class="memdesc:af96100c7687e83ebc8d20c9233df8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#af96100c7687e83ebc8d20c9233df8f0d">More...</a><br /></td></tr>
<tr class="separator:af96100c7687e83ebc8d20c9233df8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f7bd5e20ee86fd6cf074789cdcd5a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a30f7bd5e20ee86fd6cf074789cdcd5a9">restore_serialized_message</a> (<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt; msg, any life_keeper={})</td></tr>
<tr class="separator:a30f7bd5e20ee86fd6cf074789cdcd5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec75bdff202818927aae75bd6f78f3cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec75bdff202818927aae75bd6f78f3cc">send_store_message</a> (<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt; msg, any life_keeper)</td></tr>
<tr class="separator:aec75bdff202818927aae75bd6f78f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f40d9ba27c7e49036dfa898275908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a062f40d9ba27c7e49036dfa898275908">async_send_store_message</a> (<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt; msg, any life_keeper, <a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> func)</td></tr>
<tr class="separator:a062f40d9ba27c7e49036dfa898275908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0e603f71edda56ae521b30915fd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a34b0e603f71edda56ae521b30915fd30">connected</a> () const</td></tr>
<tr class="memdesc:a34b0e603f71edda56ae521b30915fd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check connection status.  <a href="classMQTT__NS_1_1endpoint.html#a34b0e603f71edda56ae521b30915fd30">More...</a><br /></td></tr>
<tr class="separator:a34b0e603f71edda56ae521b30915fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f494250e701522b452b81f335cd0921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4f494250e701522b452b81f335cd0921">underlying_connected</a> () const</td></tr>
<tr class="memdesc:a4f494250e701522b452b81f335cd0921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check underlying layer connection status.  <a href="classMQTT__NS_1_1endpoint.html#a4f494250e701522b452b81f335cd0921">More...</a><br /></td></tr>
<tr class="separator:a4f494250e701522b452b81f335cd0921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a873f5a741b43e9356a07f9d2251a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab4a873f5a741b43e9356a07f9d2251a3">async_read_next_message</a> (any session_life_keeper)</td></tr>
<tr class="memdesc:ab4a873f5a741b43e9356a07f9d2251a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);.  <a href="classMQTT__NS_1_1endpoint.html#ab4a873f5a741b43e9356a07f9d2251a3">More...</a><br /></td></tr>
<tr class="separator:ab4a873f5a741b43e9356a07f9d2251a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e234aade0059fc4fec26a2eeb50123b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3e234aade0059fc4fec26a2eeb50123b">set_max_queue_send_count</a> (std::size_t count)</td></tr>
<tr class="memdesc:a3e234aade0059fc4fec26a2eeb50123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1.  <a href="classMQTT__NS_1_1endpoint.html#a3e234aade0059fc4fec26a2eeb50123b">More...</a><br /></td></tr>
<tr class="separator:a3e234aade0059fc4fec26a2eeb50123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64befa073dd4949ec5554f25dafa52c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a64befa073dd4949ec5554f25dafa52c2">set_max_queue_send_size</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="memdesc:a64befa073dd4949ec5554f25dafa52c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0.  <a href="classMQTT__NS_1_1endpoint.html#a64befa073dd4949ec5554f25dafa52c2">More...</a><br /></td></tr>
<tr class="separator:a64befa073dd4949ec5554f25dafa52c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0700fc3a40284d20867e0b19eb16165b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0700fc3a40284d20867e0b19eb16165b">get_protocol_version</a> () const</td></tr>
<tr class="separator:a0700fc3a40284d20867e0b19eb16165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873a631af560eac356e15cd9355aba75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a873a631af560eac356e15cd9355aba75">socket</a> () const</td></tr>
<tr class="separator:a873a631af560eac356e15cd9355aba75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6012673eaa3dae1f6e69eaed4a3bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a75e6012673eaa3dae1f6e69eaed4a3bd">socket</a> ()</td></tr>
<tr class="separator:a75e6012673eaa3dae1f6e69eaed4a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3b0cbbcf288e8c5ce7b05a22883a5b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7a3b0cbbcf288e8c5ce7b05a22883a5b">get_executor</a> ()</td></tr>
<tr class="separator:a7a3b0cbbcf288e8c5ce7b05a22883a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ede24be64bef669c080a153b9871dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8ede24be64bef669c080a153b9871dd0">set_pingresp_timeout</a> (std::chrono::steady_clock::duration tim)</td></tr>
<tr class="memdesc:a8ede24be64bef669c080a153b9871dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingresp timeout.  <a href="classMQTT__NS_1_1endpoint.html#a8ede24be64bef669c080a153b9871dd0">More...</a><br /></td></tr>
<tr class="separator:a8ede24be64bef669c080a153b9871dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2e8f4c5b51c8c4397be8653f51ab21d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2e8f4c5b51c8c4397be8653f51ab21d5">on_close</a> () noexcept=0</td></tr>
<tr class="memdesc:a2e8f4c5b51c8c4397be8653f51ab21d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="classMQTT__NS_1_1endpoint.html#a2e8f4c5b51c8c4397be8653f51ab21d5">More...</a><br /></td></tr>
<tr class="separator:a2e8f4c5b51c8c4397be8653f51ab21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4959bf399d4547e51d46d695163b3fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab4959bf399d4547e51d46d695163b3fa">on_error</a> (<a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a> ec) noexcept=0</td></tr>
<tr class="memdesc:ab4959bf399d4547e51d46d695163b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handler.  <a href="classMQTT__NS_1_1endpoint.html#ab4959bf399d4547e51d46d695163b3fa">More...</a><br /></td></tr>
<tr class="separator:ab4959bf399d4547e51d46d695163b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a9292a0ab9a7ebf01125a06cef605d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a95a9292a0ab9a7ebf01125a06cef605d">on_pre_send</a> () noexcept=0</td></tr>
<tr class="memdesc:a95a9292a0ab9a7ebf01125a06cef605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-send handler This handler is called when any mqtt control packet is decided to send.  <a href="classMQTT__NS_1_1endpoint.html#a95a9292a0ab9a7ebf01125a06cef605d">More...</a><br /></td></tr>
<tr class="separator:a95a9292a0ab9a7ebf01125a06cef605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1d76146fcd753a95592e908faa9ab7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="attributes_8hpp.html#a27e44ba0a30f7987ed61228826f1a1e7">MQTT_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4f1d76146fcd753a95592e908faa9ab7">on_mqtt_message_processed</a> (any session_life_keeper)</td></tr>
<tr class="memdesc:a4f1d76146fcd753a95592e908faa9ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">next read handler This handler is called when the current mqtt message has been processed.  <a href="classMQTT__NS_1_1endpoint.html#a4f1d76146fcd753a95592e908faa9ab7">More...</a><br /></td></tr>
<tr class="separator:a4f1d76146fcd753a95592e908faa9ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bc27d0819fe7ab29688270916e0d9a"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a54bc27d0819fe7ab29688270916e0d9a">socket_optional</a> ()</td></tr>
<tr class="memdesc:a54bc27d0819fe7ab29688270916e0d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> of socket.  <a href="classMQTT__NS_1_1endpoint.html#a54bc27d0819fe7ab29688270916e0d9a">More...</a><br /></td></tr>
<tr class="separator:a54bc27d0819fe7ab29688270916e0d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba0a39184031abbbff36356edc30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae7dba0a39184031abbbff36356edc30f">async_read_control_packet_type</a> (any session_life_keeper)</td></tr>
<tr class="separator:ae7dba0a39184031abbbff36356edc30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5361b6928bb27411cbf4ffcf70436930"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5361b6928bb27411cbf4ffcf70436930">handle_close_or_error</a> (<a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a> ec)</td></tr>
<tr class="separator:a5361b6928bb27411cbf4ffcf70436930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7651aee058c15cebc0b1c8b223e213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adf7651aee058c15cebc0b1c8b223e213">set_connect</a> ()</td></tr>
<tr class="separator:adf7651aee058c15cebc0b1c8b223e213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdd241d4efe946d6f53d97f4739551b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abcdd241d4efe946d6f53d97f4739551b">set_protocol_version</a> (<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> version)</td></tr>
<tr class="separator:abcdd241d4efe946d6f53d97f4739551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75ffdd8daefd8a60e39b66f589368a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa75ffdd8daefd8a60e39b66f589368a9">clear_session_data</a> ()</td></tr>
<tr class="separator:aa75ffdd8daefd8a60e39b66f589368a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b75689b52ab8e1c524d03f261e91e4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4b75689b52ab8e1c524d03f261e91e4a">~endpoint</a> ()=default</td></tr>
<tr class="separator:a4b75689b52ab8e1c524d03f261e91e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad750138f9326bd7e016581c0dd2d2fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad750138f9326bd7e016581c0dd2d2fa6">clean_start_</a> {false}</td></tr>
<tr class="separator:ad750138f9326bd7e016581c0dd2d2fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a480c9e07ff13bcbed796378425633074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480c9e07ff13bcbed796378425633074">&#9670;&nbsp;</a></span>async_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a> =  std::function&lt;void(<a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a> ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9525c3f23b3eb6818ad591f88eb8ecc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525c3f23b3eb6818ad591f88eb8ecc3">&#9670;&nbsp;</a></span>packet_id_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> =  typename <a class="el" href="structMQTT__NS_1_1packet__id__type.html">packet_id_type</a>&lt;PacketIdBytes&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a29470cf9cad5cb1756a24f582d5f8f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29470cf9cad5cb1756a24f582d5f8f58">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">as::io_context &amp;&#160;</td>
          <td class="paramname"><em>ioc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async_send_store</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for client. </p>

</div>
</div>
<a id="afe0414917b1c36359b10cde35938bb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0414917b1c36359b10cde35938bb5a">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Socket &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">as::io_context &amp;&#160;</td>
          <td class="paramname"><em>ioc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; Socket &gt;&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async_send_store</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for server. socket should have already been connected with another endpoint. </p>

</div>
</div>
<a id="a91cb31e631081e8aa9885498b00902e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb31e631081e8aa9885498b00902e8">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef4b283fc6b3a22f6302851c8ada488a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4b283fc6b3a22f6302851c8ada488a">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b75689b52ab8e1c524d03f261e91e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b75689b52ab8e1c524d03f261e91e4a">&#9670;&nbsp;</a></span>~endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::~<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3f4cdeb5c5ad02c0d7af643b5f47343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f4cdeb5c5ad02c0d7af643b5f47343">&#9670;&nbsp;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structMQTT__NS_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>packet id </dd></dl>

</div>
</div>
<a id="a894b2f21d533b51d1975ce7e9c5d5a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894b2f21d533b51d1975ce7e9c5d5a3f">&#9670;&nbsp;</a></span>acquire_unique_packet_id_no_except()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt;<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquire_unique_packet_id_no_except </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the new unique packet id. If all packet ids are already in use, then returns nullopt After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>packet id </dd></dl>

</div>
</div>
<a id="a2e539eda565875dc30417b615077f1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e539eda565875dc30417b615077f1ff">&#9670;&nbsp;</a></span>async_auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edefa260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br  />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br  />
 3.15.2.2 AUTH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58f66cc8f3ac1196a2b7f87d26ec8edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f66cc8f3ac1196a2b7f87d26ec8edb">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac453a08e11e70495e424b71d83101b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac453a08e11e70495e424b71d83101b27">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br  />
 3.2.2.3 CONNACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a1baca693ccbf7db65f7bbcfded853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1baca693ccbf7db65f7bbcfded853f">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cb11c2c933459f4c890b45ad8679891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb11c2c933459f4c890b45ad8679891">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4f14e205e649f130db4903e43b7e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4f14e205e649f130db4903e43b7e4b">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e3ace4ba483c42831c1977004604041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ace4ba483c42831c1977004604041">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>DISCONNECT Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br  />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br  />
 3.14.2.2 DISCONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acba980320a69c7855ec39c0d4c54be63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba980320a69c7855ec39c0d4c54be63">&#9670;&nbsp;</a></span>async_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pingreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe4faf45939505b6d22cac4d77e809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4faf45939505b6d22cac4d77e809d">&#9670;&nbsp;</a></span>async_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pingresp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f1a1dd8a4256cfd2e6e4dfcc1e9c73">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6673ec20b1891e470a713fd6800660da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6673ec20b1891e470a713fd6800660da">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br  />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br  />
 3.4.2.2 PUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a89add1bcd55da883a487c0b8fb06a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a89add1bcd55da883a487c0b8fb06a3">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae33d2b8ae33769fea3124cb6891fbaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33d2b8ae33769fea3124cb6891fbaa2">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br  />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br  />
 3.7.2.2 PUBCOMP Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac48b04a5dea51912ebbd56130ca29c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b04a5dea51912ebbd56130ca29c4c">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; as::is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86556113db679faa0d369ee79b08846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86556113db679faa0d369ee79b08846e">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; as::is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="ac8d4860fe4156611c9dad32bec9f5a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4860fe4156611c9dad32bec9f5a01">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt;BufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="af58a19525c5613bab04f867a8f03c392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58a19525c5613bab04f867a8f03c392">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt;BufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e5172d1d85911e893bb5c932dd8635e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5172d1d85911e893bb5c932dd8635e">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="a1f239b956aea0c6d2472898d9e48a95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f239b956aea0c6d2472898d9e48a95a">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6acc15cef8803299cacf874319818b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6acc15cef8803299cacf874319818b2">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="ad3f707530ee64a9cac7211fe64cce3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f707530ee64a9cac7211fe64cce3d3">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2df5ccbf0bffea0df3f2462cfb7acab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2df5ccbf0bffea0df3f2462cfb7acab">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br  />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br  />
 3.5.2.2 PUBREC Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2baa14e7b1373f3f918176c1d66f9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2baa14e7b1373f3f918176c1d66f9e6">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af613e6b9b53f025422aaac81529a1c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af613e6b9b53f025422aaac81529a1c30">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br  />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br  />
 3.6.2.2 PUBREL Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a></td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The library may store this message while it communicates with the server for several round trips. As such, the life_keeper paramter is important. </dd></dl>

</div>
</div>
<a id="ae7dba0a39184031abbbff36356edc30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dba0a39184031abbbff36356edc30f">&#9670;&nbsp;</a></span>async_read_control_packet_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_read_control_packet_type </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a873f5a741b43e9356a07f9d2251a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a873f5a741b43e9356a07f9d2251a3">&#9670;&nbsp;</a></span>async_read_next_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_read_next_message </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);. </p>

</div>
</div>
<a id="a062f40d9ba27c7e49036dfa898275908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062f40d9ba27c7e49036dfa898275908">&#9670;&nbsp;</a></span>async_send_store_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_send_store_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51cab1c916e9b1a451ded59e12f12e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cab1c916e9b1a451ded59e12f12e5c">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb007ffeabe2f2c69048485ce06931a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb007ffeabe2f2c69048485ce06931a7">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cc5e59f1c48ab211a60a9ace01e5658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc5e59f1c48ab211a60a9ace01e5658">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ada90956428632c33b6a9a5f81d874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada90956428632c33b6a9a5f81d874b">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedb9163e7bada6110d8ff0df2baae20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb9163e7bada6110d8ff0df2baae20b">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffers for topic_filter. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c16c80d9d84ddc70f4980f6afe8c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c16c80d9d84ddc70f4980f6afe8c46e">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffers for topic_filter, and properties. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a680b73d11c2c572229e4ea14290754ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680b73d11c2c572229e4ea14290754ff">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a087cd4e62c27a5237abda417e8e0e173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087cd4e62c27a5237abda417e8e0e173">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1333ea0e561e36c321be73a787fa2919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1333ea0e561e36c321be73a787fa2919">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fef18f9c0b493ea572d7f4b4d2b5df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fef18f9c0b493ea572d7f4b4d2b5df2">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e95060da3a5d7a13aa5d43092466c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e95060da3a5d7a13aa5d43092466c2">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffers for params. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67e4e8a6bdb4695b46fd1b5832ecb0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e4e8a6bdb4695b46fd1b5832ecb0ed">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffers for params. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a8a732620985bd2c8157d8f229340b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8a732620985bd2c8157d8f229340b4">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e71a3aefd8b250395525aef1b1d1b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e71a3aefd8b250395525aef1b1d1b9d">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a962fd8bbf17d0fd0a3b248d671773e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962fd8bbf17d0fd0a3b248d671773e72">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d10735355ed752fbbb16387c7ed9df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10735355ed752fbbb16387c7ed9df7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_filter and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4f03591552db167ed61e36844952515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f03591552db167ed61e36844952515">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03bce36b9aed6dcf1766f499e5810610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bce36b9aed6dcf1766f499e5810610">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send ununsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6df35344e3cba6367b410a4bb6832a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df35344e3cba6367b410a4bb6832a56">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4c6ef4a06f30e02a1d111808dd44bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c6ef4a06f30e02a1d111808dd44bc6">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af46adb55ce6aab5dc2b5be8cecd7af9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46adb55ce6aab5dc2b5be8cecd7af9e">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c9b2c41518efec0c532166ecd1dee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9b2c41518efec0c532166ecd1dee62">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a322f1c786c076732089751285538cb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322f1c786c076732089751285538cb9c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>topic_filter </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffer for topic_filter. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f9119d138c26741f081ad806562ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f9119d138c26741f081ad806562ac5">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>topic_filter </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1041054526b376ede83e0e4f278f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1041054526b376ede83e0e4f278f59">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99285a401ee98b3804ea885120ae9c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99285a401ee98b3804ea885120ae9c5c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>topic_filter </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44f22eafbd2caad2b8d56357d85f2ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f22eafbd2caad2b8d56357d85f2ac2">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object may hold the lifetime of the buffers for topic_filter and contents. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a35975e5f3bd9046f1d5689e2ddd951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a35975e5f3bd9046f1d5689e2ddd951">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. This object should hold the lifetime of the buffers for params. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ff54f16c07bb6e6774e646cbc27004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ff54f16c07bb6e6774e646cbc27004">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d9472baa8d936ae9733d78e82aae03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d9472baa8d936ae9733d78e82aae03">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc80eca694c8a00cdcd016690c7954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc80eca694c8a00cdcd016690c7954a">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3d5e6673351a33f52a9a2d217e53e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d5e6673351a33f52a9a2d217e53e6">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a480c9e07ff13bcbed796378425633074">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4df77c087e7798f781497460d3f54b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df77c087e7798f781497460d3f54b3b">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976536019598132e1eefc9bf74da3ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976536019598132e1eefc9bf74da3ddd">&#9670;&nbsp;</a></span>auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edefa260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br  />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br  />
 3.15.2.2 AUTH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b22497e0a2b8adfd9012f4fc3a25bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b22497e0a2b8adfd9012f4fc3a25bf">&#9670;&nbsp;</a></span>clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean session. </p>
<p>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231</a><br  />
 3.1.2.4 Clean Session<br  />
 After constructing a endpoint, the clean session is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean session </dd></dl>

</div>
</div>
<a id="aeced2510df92ce5eb5c0276a6445fb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeced2510df92ce5eb5c0276a6445fb49">&#9670;&nbsp;</a></span>clean_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean start. </p>
<p>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 After constructing a endpoint, the clean start is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean start </dd></dl>

</div>
</div>
<a id="aa75ffdd8daefd8a60e39b66f589368a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75ffdd8daefd8a60e39b66f589368a9">&#9670;&nbsp;</a></span>clear_session_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clear_session_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc5859b47639e05d71bc5727c90747a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5859b47639e05d71bc5727c90747a6">&#9670;&nbsp;</a></span>clear_stored_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clear_stored_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stored publish message that has packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to stored publish </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee5330b0b2c4a29a8c61663cd9a3e67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5330b0b2c4a29a8c61663cd9a3e67d">&#9670;&nbsp;</a></span>connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">reason_code</td><td>See <a class="el" href="reason__code_8hpp.html">reason_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br  />
 3.2.2.3 CONNACK Properties See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8262e0105321d1757e165f6468447f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8262e0105321d1757e165f6468447f6">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">clean_session</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238</a> See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2604ecbd5ea98e18e6ec41fd21911b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2604ecbd5ea98e18e6ec41fd21911b18">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">clean_session</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238</a> See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b0e603f71edda56ae521b30915fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b0e603f71edda56ae521b30915fd30">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>current connection status </dd></dl>

</div>
</div>
<a id="a5c3d3198305da5ba6b9d3c0f6e4a0168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3d3198305da5ba6b9d3c0f6e4a0168">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442a31fe45844c214ec5ad8d824be3709a8d">v5::disconnect_reason_code::normal_disconnection</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>DISCONNECT Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br  />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br  />
 3.14.2.2 DISCONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f5b67e45a7591a1ddb6f241999570d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f5b67e45a7591a1ddb6f241999570d">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(store_message_variant) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cad0b9951be47e922c919275e08dc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cad0b9951be47e922c919275e08dc1a">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *, std::size_t)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(char const*, std::size_t) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf3205579946e26234a9aa094d6f88a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3205579946e26234a9aa094d6f88a7">&#9670;&nbsp;</a></span>for_each_store_with_life_keeper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::for_each_store_with_life_keeper </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;, any)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(store_message_variant, any) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340f9768dfcb465f5a368244d27d8dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340f9768dfcb465f5a368244d27d8dac">&#9670;&nbsp;</a></span>force_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::force_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br  />
 </p>

</div>
</div>
<a id="a7a3b0cbbcf288e8c5ce7b05a22883a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3b0cbbcf288e8c5ce7b05a22883a5b">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0700fc3a40284d20867e0b19eb16165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0700fc3a40284d20867e0b19eb16165b">&#9670;&nbsp;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4449eb06a51355c995f0a1a5bbfe9c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4449eb06a51355c995f0a1a5bbfe9c1e">&#9670;&nbsp;</a></span>get_total_bytes_received()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::get_total_bytes_received </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_total_bytes_received </p>
<dl class="section return"><dt>Returns</dt><dd>The total bytes received on the socket. </dd></dl>

</div>
</div>
<a id="ae34fd1beb49cba6b069a544aadbf878c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34fd1beb49cba6b069a544aadbf878c">&#9670;&nbsp;</a></span>get_total_bytes_sent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::get_total_bytes_sent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get_total_bytes_sent </p>
<dl class="section return"><dt>Returns</dt><dd>The total bytes sent on the socket. </dd></dl>

</div>
</div>
<a id="a5361b6928bb27411cbf4ffcf70436930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5361b6928bb27411cbf4ffcf70436930">&#9670;&nbsp;</a></span>handle_close_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::handle_close_or_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a>&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e8f4c5b51c8c4397be8653f51ab21d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8f4c5b51c8c4397be8653f51ab21d5">&#9670;&nbsp;</a></span>on_close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close handler. </p>
<p>This handler is called if the client called <code><a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> and the server closed the socket cleanly. If the socket is closed by other reasons, error_handler is called. </p>

<p>Implemented in <a class="el" href="classMQTT__NS_1_1server__endpoint.html#a5decdeea31cc738b82d89746bbd2342f">MQTT_NS::server_endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;</a>, <a class="el" href="classMQTT__NS_1_1client.html#a6ff8c45dca1526513432f041528eb377">MQTT_NS::client&lt; Socket, PacketIdBytes &gt;</a>, and <a class="el" href="classMQTT__NS_1_1client.html#a6ff8c45dca1526513432f041528eb377">MQTT_NS::client&lt; Socket, 2 &gt;</a>.</p>

</div>
</div>
<a id="ab4959bf399d4547e51d46d695163b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4959bf399d4547e51d46d695163b3fa">&#9670;&nbsp;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a5a0205af6c142eef71e19d7066501d91">error_code</a>&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error handler. </p>
<p>This handler is called if the socket is closed without client's <code><a class="el" href="classMQTT__NS_1_1endpoint.html#a5c3d3198305da5ba6b9d3c0f6e4a0168" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>error code </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMQTT__NS_1_1server__endpoint.html#a6a93f23424affa8f9e44c1ed847c41c8">MQTT_NS::server_endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;</a>, <a class="el" href="classMQTT__NS_1_1client.html#a6033df4222f74683ef936d99d7ccca99">MQTT_NS::client&lt; Socket, PacketIdBytes &gt;</a>, and <a class="el" href="classMQTT__NS_1_1client.html#a6033df4222f74683ef936d99d7ccca99">MQTT_NS::client&lt; Socket, 2 &gt;</a>.</p>

</div>
</div>
<a id="a4f1d76146fcd753a95592e908faa9ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1d76146fcd753a95592e908faa9ab7">&#9670;&nbsp;</a></span>on_mqtt_message_processed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="attributes_8hpp.html#a27e44ba0a30f7987ed61228826f1a1e7">MQTT_ALWAYS_INLINE</a> void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_mqtt_message_processed </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next read handler This handler is called when the current mqtt message has been processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95a9292a0ab9a7ebf01125a06cef605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a9292a0ab9a7ebf01125a06cef605d">&#9670;&nbsp;</a></span>on_pre_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pre_send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-send handler This handler is called when any mqtt control packet is decided to send. </p>

<p>Implemented in <a class="el" href="classMQTT__NS_1_1server__endpoint.html#abceae31b072a0434f35c430c68665688">MQTT_NS::server_endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;</a>, <a class="el" href="classMQTT__NS_1_1client.html#a9b071015f08f48ac2db28912a0dd54b6">MQTT_NS::client&lt; Socket, PacketIdBytes &gt;</a>, and <a class="el" href="classMQTT__NS_1_1client.html#a9b071015f08f48ac2db28912a0dd54b6">MQTT_NS::client&lt; Socket, 2 &gt;</a>.</p>

</div>
</div>
<a id="a9f4a2506a09708a2de1e5d3aa8bbf275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4a2506a09708a2de1e5d3aa8bbf275">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16684404a6edf1f58d07938b60fbaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16684404a6edf1f58d07938b60fbaf0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6073e6c1a564756c1cb350f20650b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6073e6c1a564756c1cb350f20650b95">&#9670;&nbsp;</a></span>pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>. </p>

</div>
</div>
<a id="a9163ebce3564d4bbcdb45ca6ca3718f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9163ebce3564d4bbcdb45ca6ca3718f7">&#9670;&nbsp;</a></span>pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>. </p>

</div>
</div>
<a id="a7cd636fb096675d2d760b96f6bd0aa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd636fb096675d2d760b96f6bd0aa51">&#9670;&nbsp;</a></span>puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7da260ca9dd8a4577fc00b7bd5810298076">v5::puback_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br  />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br  />
 3.4.2.2 PUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af445953a02866e9eea2b4397c33162cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af445953a02866e9eea2b4397c33162cb">&#9670;&nbsp;</a></span>pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903a260ca9dd8a4577fc00b7bd5810298076">v5::pubcomp_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br  />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br  />
 3.7.2.2 PUBCOMP Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8003e60961de0b10342ec68b694b3108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8003e60961de0b10342ec68b694b3108">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; as::is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="a9841d7e52b11cbcfee2800edb253af81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9841d7e52b11cbcfee2800edb253af81">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; as::is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="adb3340717ebfd97f44b62d3adfc506d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3340717ebfd97f44b62d3adfc506d0">&#9670;&nbsp;</a></span>publish() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt;BufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="a9545e8a331cea70f0c24203fbe669ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9545e8a331cea70f0c24203fbe669ce6">&#9670;&nbsp;</a></span>publish() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structMQTT__NS_1_1is__buffer__sequence.html">is_buffer_sequence</a>&lt;BufferSequence&gt;::value &gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferSequence&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents or the range of the contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. If topic_name and contents don't manage their lifetimes, then life_keeper should be used to keep their lifetimes. </dd></dl>

</div>
</div>
<a id="ae0ac4e03f9b9971fd33264806b98b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ac4e03f9b9971fd33264806b98b512">&#9670;&nbsp;</a></span>publish() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1publish__options.html">publish_options</a>&#160;</td>
          <td class="paramname"><em>pubopts</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="a2122a797f9904c13a8fbde624dec9fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122a797f9904c13a8fbde624dec9fb9">&#9670;&nbsp;</a></span>publish() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">pubopts</td><td>qos, retain flag, and dup flag. </td></tr>
    <tr><td class="paramname">props</td><td>(optional) Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>(optional) An object that stays alive as long as the library holds a reference to any other parameters. If topic_name, contents, or props do not have built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If your QOS level is exactly_once or at_least_once, then the library will store this publish internally until the broker has confirmed delivery, which may involve resends, and as such the life_keeper parameter is important. </dd></dl>

</div>
</div>
<a id="ab88387690236c708daac8083a7f6be68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88387690236c708daac8083a7f6be68">&#9670;&nbsp;</a></span>pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4ca260ca9dd8a4577fc00b7bd5810298076">v5::pubrec_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br  />
 3.5.2.1 Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br  />
 3.5.2.2 Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13def035f0198369cf98e29460fee09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13def035f0198369cf98e29460fee09f">&#9670;&nbsp;</a></span>pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55cea260ca9dd8a4577fc00b7bd5810298076">v5::pubrel_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br  />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br  />
 3.6.2.2 PUBREL Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive as long as the library holds a reference to any other parameters. If your props are not using built-in lifetime management, (e.g. buffer) use this parameter to manage their lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The library may store this message while it communicates with the server for several round trips. As such, the life_keeper paramter is important. </dd></dl>

</div>
</div>
<a id="ad36d39d8679fe97e5a68c4163f483d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36d39d8679fe97e5a68c4163f483d27">&#9670;&nbsp;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully registerd then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a65d90ba2b897d685115ef4cc6bd58175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d90ba2b897d685115ef4cc6bd58175">&#9670;&nbsp;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id to release. only the packet_id gotten by acquire_unique_packet_id, or register_packet_id is permitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac884bd8af142285b71bc2897975a048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac884bd8af142285b71bc2897975a048a">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0689df35a3c8957419b12947cb63fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0689df35a3c8957419b12947cb63fcb">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30f7bd5e20ee86fd6cf074789cdcd5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f7bd5e20ee86fd6cf074789cdcd5a9">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2a5640a4575a7a3e0a603cfa88f2e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a5640a4575a7a3e0a603cfa88f2e43">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_convertible&lt;typename Iterator::value_type, char&gt;::value &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb659a33611b7f11ef1235bd89ef9b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb659a33611b7f11ef1235bd89ef9b32">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_convertible&lt;typename Iterator::value_type, char&gt;::value &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message Empty topic_name on MQTT <a class="el" href="namespaceMQTT__NS_1_1v5.html">v5</a> publish message is prohibited. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b2f6e697216d4990716362e2eeb67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2f6e697216d4990716362e2eeb67a">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. Empty topic_name is prohibited. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af96100c7687e83ebc8d20c9233df8f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96100c7687e83ebc8d20c9233df8f0d">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec75bdff202818927aae75bd6f78f3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec75bdff202818927aae75bd6f78f3cc">&#9670;&nbsp;</a></span>send_store_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::send_store_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a33167542fb2c57e9763f837f687a88b4">basic_store_message_variant</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acabfd0bd245770caa1ef8e03a76aa64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfd0bd245770caa1ef8e03a76aa64f">&#9670;&nbsp;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set auto publish response mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>set value </td></tr>
    <tr><td class="paramname">async</td><td>auto publish ressponse send asynchronous</td></tr>
  </table>
  </dd>
</dl>
<p>When set auto publish response mode to true, puback, pubrec, pubrel,and pub comp automatically send.<br  />
 </p>

</div>
</div>
<a id="abff4c5e845c5b4d5904bcf0a11eca37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff4c5e845c5b4d5904bcf0a11eca37c">&#9670;&nbsp;</a></span>set_auto_replace_topic_alias_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_auto_replace_topic_alias_send </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf7651aee058c15cebc0b1c8b223e213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7651aee058c15cebc0b1c8b223e213">&#9670;&nbsp;</a></span>set_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e234aade0059fc4fec26a2eeb50123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e234aade0059fc4fec26a2eeb50123b">&#9670;&nbsp;</a></span>set_max_queue_send_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_count </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>maximum number of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64befa073dd4949ec5554f25dafa52c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64befa073dd4949ec5554f25dafa52c2">&#9670;&nbsp;</a></span>set_max_queue_send_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>maximum size of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab936aa635400f77eeaff109656ffbf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab936aa635400f77eeaff109656ffbf0c">&#9670;&nbsp;</a></span>set_packet_bulk_read_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_packet_bulk_read_limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ede24be64bef669c080a153b9871dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ede24be64bef669c080a153b9871dd0">&#9670;&nbsp;</a></span>set_pingresp_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_pingresp_timeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::duration&#160;</td>
          <td class="paramname"><em>tim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingresp timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<p>If tim is not zero, when the client sends PINGREQ, set a timer. The timer cancels when PINGRESP is received. If the timer is fired, then force_disconnect from the client side.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </p>

</div>
</div>
<a id="a71b1d2e8898e9cda6f8f4441ce663408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b1d2e8898e9cda6f8f4441ce663408">&#9670;&nbsp;</a></span>set_props_bulk_read_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_props_bulk_read_limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcdd241d4efe946d6f53d97f4739551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdd241d4efe946d6f53d97f4739551b">&#9670;&nbsp;</a></span>set_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_protocol_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75e6012673eaa3dae1f6e69eaed4a3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6012673eaa3dae1f6e69eaed4a3bd">&#9670;&nbsp;</a></span>socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a873a631af560eac356e15cd9355aba75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873a631af560eac356e15cd9355aba75">&#9670;&nbsp;</a></span>socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a> const&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54bc27d0819fe7ab29688270916e0d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bc27d0819fe7ab29688270916e0d9a">&#9670;&nbsp;</a></span>socket_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt;<a class="el" href="namespaceMQTT__NS.html#ade0fb43788f914f6d676282b0b481359">MQTT_NS::socket</a>&gt;&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::socket_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> of socket. </p>
<dl class="section return"><dt>Returns</dt><dd>reference of <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> socket </dd></dl>

</div>
</div>
<a id="a4ce134b027d9313ef79bf622659ed45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce134b027d9313ef79bf622659ed45d">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::start_session </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em> = <code>any()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start session with a connected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>finish handler that is called when the session is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76ade37f6ff8e6d538f39f126869ec64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ade37f6ff8e6d538f39f126869ec64">&#9670;&nbsp;</a></span>suback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b833460c24968c8d8a898ad4862cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b833460c24968c8d8a898ad4862cf3">&#9670;&nbsp;</a></span>suback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3bd2e73406ab3cdff507839d70334b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd2e73406ab3cdff507839d70334b0">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad81ba461fc8ab3dbd506f1037b49ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad81ba461fc8ab3dbd506f1037b49ba8">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the <a class="el" href="structMQTT__NS_1_1subscribe__entry.html">subscribe_entry</a>. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5755ae7555bda911f5d0d4fe07b50941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5755ae7555bda911f5d0d4fe07b50941">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad928c00260f7a2cce1740ac0f5aaf70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad928c00260f7a2cce1740ac0f5aaf70e">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac638b33a024c3288baaf9a69928b147a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac638b33a024c3288baaf9a69928b147a">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a4f494250e701522b452b81f335cd0921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f494250e701522b452b81f335cd0921">&#9670;&nbsp;</a></span>underlying_connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::underlying_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check underlying layer connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>current connection status </dd></dl>

</div>
</div>
<a id="a1fad6ceb5599d28d1f97c0d2053d129a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fad6ceb5599d28d1f97c0d2053d129a">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5b2098ddcb6c4aeb2946fb8484e391b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b2098ddcb6c4aeb2946fb8484e391b">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a22ff11f06c2a3d1a4cf40963fdd606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a22ff11f06c2a3d1a4cf40963fdd606">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b9cdc305a9de72a91ea23ff500101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b9cdc305a9de72a91ea23ff500101a">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a6af2f4557e8cdd830c05810a9c1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a6af2f4557e8cdd830c05810a9c1b4">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2840b82d26af00c23dd41a492d47dd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2840b82d26af00c23dd41a492d47dd64">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0b9780e37643be9f3d0acc95b95c4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b9780e37643be9f3d0acc95b95c4c8">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa8ba5667cc5728610463506a98a23b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8ba5667cc5728610463506a98a23b3">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9ca117363777099691058c4855fa5b6a">v5::properties</a>&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_filter</td><td>A topic filter to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdfdc7647cee774547f857f0a65e9c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfdc7647cee774547f857f0a65e9c32">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... Params&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ! std::is_convertible&lt;std::decay_t&lt;T&gt;, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&gt;::value, <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad750138f9326bd7e016581c0dd2d2fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad750138f9326bd7e016581c0dd2d2fa6">&#9670;&nbsp;</a></span>clean_start_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex  = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_start_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/mqtt_cpp/include/mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
