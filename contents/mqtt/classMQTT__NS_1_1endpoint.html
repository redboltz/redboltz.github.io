<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mqtt_cpp: MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mqtt_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMQTT__NS.html">MQTT_NS</a></li><li class="navelem"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMQTT__NS_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classMQTT__NS_1_1endpoint__inherit__graph.png" border="0" usemap="#MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" id="MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map">
<area shape="rect" title=" " alt="" coords="11,124,217,180"/>
<area shape="rect" title=" " alt="" coords="5,5,223,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MQTT_NS::endpoint&lt; Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classMQTT__NS_1_1endpoint__coll__graph.png" border="0" usemap="#MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" id="MQTT__NS_1_1endpoint_3_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="11,124,217,180"/>
<area shape="rect" title=" " alt="" coords="5,5,223,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aec238d7bd6b44c945cf78431ca0fee35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:aec238d7bd6b44c945cf78431ca0fee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525c3f23b3eb6818ad591f88eb8ecc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> = typename <a class="el" href="structMQTT__NS_1_1packet__id__type.html">packet_id_type</a>&lt; PacketIdBytes &gt;::type</td></tr>
<tr class="separator:a9525c3f23b3eb6818ad591f88eb8ecc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a781fc9ff61a4cd609a24297096e9454e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a781fc9ff61a4cd609a24297096e9454e">endpoint</a> (<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> version=<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>, bool async_send_store=false)</td></tr>
<tr class="memdesc:a781fc9ff61a4cd609a24297096e9454e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for client.  <a href="classMQTT__NS_1_1endpoint.html#a781fc9ff61a4cd609a24297096e9454e">More...</a><br /></td></tr>
<tr class="separator:a781fc9ff61a4cd609a24297096e9454e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2fc00e63f634010b15a866c1c4b8b3"><td class="memTemplParams" colspan="2">template&lt;typename Socket &gt; </td></tr>
<tr class="memitem:aed2fc00e63f634010b15a866c1c4b8b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aed2fc00e63f634010b15a866c1c4b8b3">endpoint</a> (std::shared_ptr&lt; Socket &gt; <a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">socket</a>, <a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> version=<a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>, bool async_send_store=false)</td></tr>
<tr class="memdesc:aed2fc00e63f634010b15a866c1c4b8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for server. socket should have already been connected with another endpoint.  <a href="classMQTT__NS_1_1endpoint.html#aed2fc00e63f634010b15a866c1c4b8b3">More...</a><br /></td></tr>
<tr class="separator:aed2fc00e63f634010b15a866c1c4b8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326c1b11e759549b8b4f5fe328e3fe3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1326c1b11e759549b8b4f5fe328e3fe3">on_pingreq</a> ()=0</td></tr>
<tr class="memdesc:a1326c1b11e759549b8b4f5fe328e3fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br  />
 3.13 PINGREQ – PING request.  <a href="classMQTT__NS_1_1endpoint.html#a1326c1b11e759549b8b4f5fe328e3fe3">More...</a><br /></td></tr>
<tr class="separator:a1326c1b11e759549b8b4f5fe328e3fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8534b4853d1384b15fd192063a90c81f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8534b4853d1384b15fd192063a90c81f">on_pingresp</a> ()=0</td></tr>
<tr class="memdesc:a8534b4853d1384b15fd192063a90c81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pingresp handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a><br  />
 3.13 PINGRESP – PING response.  <a href="classMQTT__NS_1_1endpoint.html#a8534b4853d1384b15fd192063a90c81f">More...</a><br /></td></tr>
<tr class="separator:a8534b4853d1384b15fd192063a90c81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106bef609e666832b3696fe47dfce91"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa106bef609e666832b3696fe47dfce91">on_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> client_id, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; user_name, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; password, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; <a class="el" href="classMQTT__NS_1_1will.html">will</a>, bool <a class="el" href="classMQTT__NS_1_1endpoint.html#a83b22497e0a2b8adfd9012f4fc3a25bf">clean_session</a>, std::uint16_t keep_alive)=0</td></tr>
<tr class="memdesc:aa106bef609e666832b3696fe47dfce91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect handler.  <a href="classMQTT__NS_1_1endpoint.html#aa106bef609e666832b3696fe47dfce91">More...</a><br /></td></tr>
<tr class="separator:aa106bef609e666832b3696fe47dfce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba262462dcf91c1c5ca5a3f191d23a90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aba262462dcf91c1c5ca5a3f191d23a90">on_connack</a> (bool session_present, <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a> return_code)=0</td></tr>
<tr class="memdesc:aba262462dcf91c1c5ca5a3f191d23a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connack handler.  <a href="classMQTT__NS_1_1endpoint.html#aba262462dcf91c1c5ca5a3f191d23a90">More...</a><br /></td></tr>
<tr class="separator:aba262462dcf91c1c5ca5a3f191d23a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f661662b72957334e1f63ff1bd394ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4f661662b72957334e1f63ff1bd394ee">on_publish</a> (bool dup, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt; packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> contents)=0</td></tr>
<tr class="memdesc:a4f661662b72957334e1f63ff1bd394ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish handler.  <a href="classMQTT__NS_1_1endpoint.html#a4f661662b72957334e1f63ff1bd394ee">More...</a><br /></td></tr>
<tr class="separator:a4f661662b72957334e1f63ff1bd394ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf4459f5e75e5da65c705e66c80b470"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abdf4459f5e75e5da65c705e66c80b470">on_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:abdf4459f5e75e5da65c705e66c80b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puback handler.  <a href="classMQTT__NS_1_1endpoint.html#abdf4459f5e75e5da65c705e66c80b470">More...</a><br /></td></tr>
<tr class="separator:abdf4459f5e75e5da65c705e66c80b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c0e6e5c22291ee3edd8135246a1bd7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a30c0e6e5c22291ee3edd8135246a1bd7">on_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:a30c0e6e5c22291ee3edd8135246a1bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrec handler.  <a href="classMQTT__NS_1_1endpoint.html#a30c0e6e5c22291ee3edd8135246a1bd7">More...</a><br /></td></tr>
<tr class="separator:a30c0e6e5c22291ee3edd8135246a1bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19a608b0c537f3548ddb7eb20bbf38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aca19a608b0c537f3548ddb7eb20bbf38">on_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:aca19a608b0c537f3548ddb7eb20bbf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrel handler.  <a href="classMQTT__NS_1_1endpoint.html#aca19a608b0c537f3548ddb7eb20bbf38">More...</a><br /></td></tr>
<tr class="separator:aca19a608b0c537f3548ddb7eb20bbf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5821b61bc8b8a8278b9b62b91a289fd2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5821b61bc8b8a8278b9b62b91a289fd2">on_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:a5821b61bc8b8a8278b9b62b91a289fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubcomp handler.  <a href="classMQTT__NS_1_1endpoint.html#a5821b61bc8b8a8278b9b62b91a289fd2">More...</a><br /></td></tr>
<tr class="separator:a5821b61bc8b8a8278b9b62b91a289fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca69c094379b01b41b861183c0c7fc1a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aca69c094379b01b41b861183c0c7fc1a">on_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; entries)=0</td></tr>
<tr class="memdesc:aca69c094379b01b41b861183c0c7fc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe handler.  <a href="classMQTT__NS_1_1endpoint.html#aca69c094379b01b41b861183c0c7fc1a">More...</a><br /></td></tr>
<tr class="separator:aca69c094379b01b41b861183c0c7fc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee064563a7474e855933a6b6da31fc07"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aee064563a7474e855933a6b6da31fc07">on_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">MQTT_NS::suback_return_code</a> &gt; returns)=0</td></tr>
<tr class="memdesc:aee064563a7474e855933a6b6da31fc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suback handler.  <a href="classMQTT__NS_1_1endpoint.html#aee064563a7474e855933a6b6da31fc07">More...</a><br /></td></tr>
<tr class="separator:aee064563a7474e855933a6b6da31fc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c77a1bf913251bb5215be04fc5f0391"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8c77a1bf913251bb5215be04fc5f0391">on_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; topics)=0</td></tr>
<tr class="memdesc:a8c77a1bf913251bb5215be04fc5f0391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe handler.  <a href="classMQTT__NS_1_1endpoint.html#a8c77a1bf913251bb5215be04fc5f0391">More...</a><br /></td></tr>
<tr class="separator:a8c77a1bf913251bb5215be04fc5f0391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6499ebcd6d022d74c07fd0765adf77a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6499ebcd6d022d74c07fd0765adf77a8">on_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)=0</td></tr>
<tr class="memdesc:a6499ebcd6d022d74c07fd0765adf77a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsuback handler.  <a href="classMQTT__NS_1_1endpoint.html#a6499ebcd6d022d74c07fd0765adf77a8">More...</a><br /></td></tr>
<tr class="separator:a6499ebcd6d022d74c07fd0765adf77a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443660c7ad51013f2f220b54aff67c36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a443660c7ad51013f2f220b54aff67c36">on_disconnect</a> ()=0</td></tr>
<tr class="memdesc:a443660c7ad51013f2f220b54aff67c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463</a><br  />
 3.14 DISCONNECT – Disconnect notification.  <a href="classMQTT__NS_1_1endpoint.html#a443660c7ad51013f2f220b54aff67c36">More...</a><br /></td></tr>
<tr class="separator:a443660c7ad51013f2f220b54aff67c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b04b9be065dd40cc4f7138807826220"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1b04b9be065dd40cc4f7138807826220">on_v5_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> client_id, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; user_name, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; password, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; <a class="el" href="classMQTT__NS_1_1will.html">will</a>, bool <a class="el" href="classMQTT__NS_1_1endpoint.html#aeced2510df92ce5eb5c0276a6445fb49">clean_start</a>, std::uint16_t keep_alive, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a1b04b9be065dd40cc4f7138807826220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect handler.  <a href="classMQTT__NS_1_1endpoint.html#a1b04b9be065dd40cc4f7138807826220">More...</a><br /></td></tr>
<tr class="separator:a1b04b9be065dd40cc4f7138807826220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da29579cd34fd24903094997a7dfb9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a68da29579cd34fd24903094997a7dfb9">on_v5_connack</a> (bool session_present, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a68da29579cd34fd24903094997a7dfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connack handler.  <a href="classMQTT__NS_1_1endpoint.html#a68da29579cd34fd24903094997a7dfb9">More...</a><br /></td></tr>
<tr class="separator:a68da29579cd34fd24903094997a7dfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9cc6056e76fa1847055a2cf760f9bf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0b9cc6056e76fa1847055a2cf760f9bf">on_v5_publish</a> (bool dup, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt; packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> contents, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a0b9cc6056e76fa1847055a2cf760f9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish handler.  <a href="classMQTT__NS_1_1endpoint.html#a0b9cc6056e76fa1847055a2cf760f9bf">More...</a><br /></td></tr>
<tr class="separator:a0b9cc6056e76fa1847055a2cf760f9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907b31c845e780a4b197128d2d8f5bf8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a907b31c845e780a4b197128d2d8f5bf8">on_v5_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a907b31c845e780a4b197128d2d8f5bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puback handler.  <a href="classMQTT__NS_1_1endpoint.html#a907b31c845e780a4b197128d2d8f5bf8">More...</a><br /></td></tr>
<tr class="separator:a907b31c845e780a4b197128d2d8f5bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a029a37883f25705ec2a23aa9603e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac6a029a37883f25705ec2a23aa9603e6">on_v5_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:ac6a029a37883f25705ec2a23aa9603e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrec handler.  <a href="classMQTT__NS_1_1endpoint.html#ac6a029a37883f25705ec2a23aa9603e6">More...</a><br /></td></tr>
<tr class="separator:ac6a029a37883f25705ec2a23aa9603e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbcee1fc640bc361b15e98c8e2de0ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aadbcee1fc640bc361b15e98c8e2de0ec">on_v5_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:aadbcee1fc640bc361b15e98c8e2de0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrel handler.  <a href="classMQTT__NS_1_1endpoint.html#aadbcee1fc640bc361b15e98c8e2de0ec">More...</a><br /></td></tr>
<tr class="separator:aadbcee1fc640bc361b15e98c8e2de0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e0e209a2423937e59d066762bd5137"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a12e0e209a2423937e59d066762bd5137">on_v5_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a12e0e209a2423937e59d066762bd5137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubcomp handler.  <a href="classMQTT__NS_1_1endpoint.html#a12e0e209a2423937e59d066762bd5137">More...</a><br /></td></tr>
<tr class="separator:a12e0e209a2423937e59d066762bd5137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af015fea598ef29c17cc85a9d18eb6981"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af015fea598ef29c17cc85a9d18eb6981">on_v5_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; entries, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:af015fea598ef29c17cc85a9d18eb6981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe handler.  <a href="classMQTT__NS_1_1endpoint.html#af015fea598ef29c17cc85a9d18eb6981">More...</a><br /></td></tr>
<tr class="separator:af015fea598ef29c17cc85a9d18eb6981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b9c5e264aea23dc4487dc510e56349"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a75b9c5e264aea23dc4487dc510e56349">on_v5_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">MQTT_NS::v5::suback_reason_code</a> &gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a75b9c5e264aea23dc4487dc510e56349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suback handler.  <a href="classMQTT__NS_1_1endpoint.html#a75b9c5e264aea23dc4487dc510e56349">More...</a><br /></td></tr>
<tr class="separator:a75b9c5e264aea23dc4487dc510e56349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f98095341d0f177e640f86302cf5c5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a80f98095341d0f177e640f86302cf5c5">on_v5_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt; topics, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a80f98095341d0f177e640f86302cf5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe handler.  <a href="classMQTT__NS_1_1endpoint.html#a80f98095341d0f177e640f86302cf5c5">More...</a><br /></td></tr>
<tr class="separator:a80f98095341d0f177e640f86302cf5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442ed97d3653b2906bad0c55a152658b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a442ed97d3653b2906bad0c55a152658b">on_v5_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a442ed97d3653b2906bad0c55a152658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsuback handler.  <a href="classMQTT__NS_1_1endpoint.html#a442ed97d3653b2906bad0c55a152658b">More...</a><br /></td></tr>
<tr class="separator:a442ed97d3653b2906bad0c55a152658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d91d0afe1d3db047da39ece3a0f7f4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7d91d0afe1d3db047da39ece3a0f7f4b">on_v5_disconnect</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a7d91d0afe1d3db047da39ece3a0f7f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
 3.14 DISCONNECT – Disconnect notification.  <a href="classMQTT__NS_1_1endpoint.html#a7d91d0afe1d3db047da39ece3a0f7f4b">More...</a><br /></td></tr>
<tr class="separator:a7d91d0afe1d3db047da39ece3a0f7f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d743fb32c45fe91b9491d14f9f054"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a499d743fb32c45fe91b9491d14f9f054">on_v5_auth</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props)=0</td></tr>
<tr class="memdesc:a499d743fb32c45fe91b9491d14f9f054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auth handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217</a><br  />
 3.15 AUTH – Authentication exchange.  <a href="classMQTT__NS_1_1endpoint.html#a499d743fb32c45fe91b9491d14f9f054">More...</a><br /></td></tr>
<tr class="separator:a499d743fb32c45fe91b9491d14f9f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278772fe2cd0cd67975c77b187f8b987"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a278772fe2cd0cd67975c77b187f8b987">on_close</a> ()=0</td></tr>
<tr class="memdesc:a278772fe2cd0cd67975c77b187f8b987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="classMQTT__NS_1_1endpoint.html#a278772fe2cd0cd67975c77b187f8b987">More...</a><br /></td></tr>
<tr class="separator:a278772fe2cd0cd67975c77b187f8b987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af423f4675966c8c68e83b49a51cb88fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af423f4675966c8c68e83b49a51cb88fc">on_error</a> (boost::system::error_code const &amp;ec)=0</td></tr>
<tr class="memdesc:af423f4675966c8c68e83b49a51cb88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handler.  <a href="classMQTT__NS_1_1endpoint.html#af423f4675966c8c68e83b49a51cb88fc">More...</a><br /></td></tr>
<tr class="separator:af423f4675966c8c68e83b49a51cb88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4663ae9cb7200570556c70194cca7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1fc4663ae9cb7200570556c70194cca7">on_pub_res_sent</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:a1fc4663ae9cb7200570556c70194cca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2.  <a href="classMQTT__NS_1_1endpoint.html#a1fc4663ae9cb7200570556c70194cca7">More...</a><br /></td></tr>
<tr class="separator:a1fc4663ae9cb7200570556c70194cca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fffb7166f69a9ce3a0c8d854b29073a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2fffb7166f69a9ce3a0c8d854b29073a">on_serialize_publish_message</a> (<a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt; msg)=0</td></tr>
<tr class="memdesc:a2fffb7166f69a9ce3a0c8d854b29073a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="classMQTT__NS_1_1endpoint.html#a2fffb7166f69a9ce3a0c8d854b29073a">More...</a><br /></td></tr>
<tr class="separator:a2fffb7166f69a9ce3a0c8d854b29073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4db59d14d39a6fc20c34461eac118b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2e4db59d14d39a6fc20c34461eac118b">on_serialize_v5_publish_message</a> (<a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt; msg)=0</td></tr>
<tr class="memdesc:a2e4db59d14d39a6fc20c34461eac118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="classMQTT__NS_1_1endpoint.html#a2e4db59d14d39a6fc20c34461eac118b">More...</a><br /></td></tr>
<tr class="separator:a2e4db59d14d39a6fc20c34461eac118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0dab0d068f90543933335fa8fe127"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a83d0dab0d068f90543933335fa8fe127">on_serialize_pubrel_message</a> (<a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt; msg)=0</td></tr>
<tr class="memdesc:a83d0dab0d068f90543933335fa8fe127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="classMQTT__NS_1_1endpoint.html#a83d0dab0d068f90543933335fa8fe127">More...</a><br /></td></tr>
<tr class="separator:a83d0dab0d068f90543933335fa8fe127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac962a8e37ef6178c88fdeff03fab403f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac962a8e37ef6178c88fdeff03fab403f">on_serialize_v5_pubrel_message</a> (<a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt; msg)=0</td></tr>
<tr class="memdesc:ac962a8e37ef6178c88fdeff03fab403f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="classMQTT__NS_1_1endpoint.html#ac962a8e37ef6178c88fdeff03fab403f">More...</a><br /></td></tr>
<tr class="separator:ac962a8e37ef6178c88fdeff03fab403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ca03480deacecbad964e354b882760"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a31ca03480deacecbad964e354b882760">on_serialize_remove</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)=0</td></tr>
<tr class="memdesc:a31ca03480deacecbad964e354b882760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove serialized message.  <a href="classMQTT__NS_1_1endpoint.html#a31ca03480deacecbad964e354b882760">More...</a><br /></td></tr>
<tr class="separator:a31ca03480deacecbad964e354b882760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83147c685a0ae4f4f8f71cbde852f1b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a83147c685a0ae4f4f8f71cbde852f1b1">on_pre_send</a> ()=0</td></tr>
<tr class="memdesc:a83147c685a0ae4f4f8f71cbde852f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-send handler This handler is called when any mqtt control packet is decided to send.  <a href="classMQTT__NS_1_1endpoint.html#a83147c685a0ae4f4f8f71cbde852f1b1">More...</a><br /></td></tr>
<tr class="separator:a83147c685a0ae4f4f8f71cbde852f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd767b5cccac13a838637bfe8f254333"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abd767b5cccac13a838637bfe8f254333">check_is_valid_length</a> (<a class="el" href="namespaceMQTT__NS.html#a4ff14039c2291ee42436507a29776543">control_packet_type</a> packet_type, std::size_t <a class="el" href="namespaceMQTT__NS.html#a4ddf48c98316632ba885b6803fca1a92">remaining_length</a>)=0</td></tr>
<tr class="memdesc:abd767b5cccac13a838637bfe8f254333"><td class="mdescLeft">&#160;</td><td class="mdescRight">is valid length handler This handler is called when remaining length is received.  <a href="classMQTT__NS_1_1endpoint.html#abd767b5cccac13a838637bfe8f254333">More...</a><br /></td></tr>
<tr class="separator:abd767b5cccac13a838637bfe8f254333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7176d6ece0e157342e1f51594ca89681"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="attributes_8hpp.html#a27e44ba0a30f7987ed61228826f1a1e7">MQTT_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7176d6ece0e157342e1f51594ca89681">on_mqtt_message_processed</a> (MQTT_NS::any session_life_keeper)</td></tr>
<tr class="memdesc:a7176d6ece0e157342e1f51594ca89681"><td class="mdescLeft">&#160;</td><td class="mdescRight">next read handler This handler is called when the current mqtt message has been processed.  <a href="classMQTT__NS_1_1endpoint.html#a7176d6ece0e157342e1f51594ca89681">More...</a><br /></td></tr>
<tr class="separator:a7176d6ece0e157342e1f51594ca89681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb31e631081e8aa9885498b00902e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a91cb31e631081e8aa9885498b00902e8">endpoint</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:a91cb31e631081e8aa9885498b00902e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4b283fc6b3a22f6302851c8ada488a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aef4b283fc6b3a22f6302851c8ada488a">endpoint</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aef4b283fc6b3a22f6302851c8ada488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16684404a6edf1f58d07938b60fbaf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa16684404a6edf1f58d07938b60fbaf0">operator=</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:aa16684404a6edf1f58d07938b60fbaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a2506a09708a2de1e5d3aa8bbf275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9f4a2506a09708a2de1e5d3aa8bbf275">operator=</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9f4a2506a09708a2de1e5d3aa8bbf275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a83b22497e0a2b8adfd9012f4fc3a25bf">clean_session</a> () const</td></tr>
<tr class="memdesc:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean session.  <a href="classMQTT__NS_1_1endpoint.html#a83b22497e0a2b8adfd9012f4fc3a25bf">More...</a><br /></td></tr>
<tr class="separator:a83b22497e0a2b8adfd9012f4fc3a25bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced2510df92ce5eb5c0276a6445fb49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aeced2510df92ce5eb5c0276a6445fb49">clean_start</a> () const</td></tr>
<tr class="memdesc:aeced2510df92ce5eb5c0276a6445fb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean start.  <a href="classMQTT__NS_1_1endpoint.html#aeced2510df92ce5eb5c0276a6445fb49">More...</a><br /></td></tr>
<tr class="separator:aeced2510df92ce5eb5c0276a6445fb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfd0bd245770caa1ef8e03a76aa64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acabfd0bd245770caa1ef8e03a76aa64f">set_auto_pub_response</a> (bool b=true, bool async=true)</td></tr>
<tr class="memdesc:acabfd0bd245770caa1ef8e03a76aa64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set auto publish response mode.  <a href="classMQTT__NS_1_1endpoint.html#acabfd0bd245770caa1ef8e03a76aa64f">More...</a><br /></td></tr>
<tr class="separator:acabfd0bd245770caa1ef8e03a76aa64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab936aa635400f77eeaff109656ffbf0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab936aa635400f77eeaff109656ffbf0c">set_packet_bulk_read_limit</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="separator:ab936aa635400f77eeaff109656ffbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b1d2e8898e9cda6f8f4441ce663408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a71b1d2e8898e9cda6f8f4441ce663408">set_props_bulk_read_limit</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="separator:a71b1d2e8898e9cda6f8f4441ce663408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce134b027d9313ef79bf622659ed45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4ce134b027d9313ef79bf622659ed45d">start_session</a> (any session_life_keeper=any())</td></tr>
<tr class="memdesc:a4ce134b027d9313ef79bf622659ed45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">start session with a connected endpoint.  <a href="classMQTT__NS_1_1endpoint.html#a4ce134b027d9313ef79bf622659ed45d">More...</a><br /></td></tr>
<tr class="separator:a4ce134b027d9313ef79bf622659ed45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad1c1cf62c4e64808d7d492ef2a76b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7ad1c1cf62c4e64808d7d492ef2a76b9">publish</a> (std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a7ad1c1cf62c4e64808d7d492ef2a76b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#a7ad1c1cf62c4e64808d7d492ef2a76b9">More...</a><br /></td></tr>
<tr class="separator:a7ad1c1cf62c4e64808d7d492ef2a76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86f5d4cd8119f41e64f9216199119f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad86f5d4cd8119f41e64f9216199119f8">publish</a> (as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ad86f5d4cd8119f41e64f9216199119f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#ad86f5d4cd8119f41e64f9216199119f8">More...</a><br /></td></tr>
<tr class="separator:ad86f5d4cd8119f41e64f9216199119f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b12391d625e962bacccfb27a660109d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2b12391d625e962bacccfb27a660109d">publish</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a2b12391d625e962bacccfb27a660109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#a2b12391d625e962bacccfb27a660109d">More...</a><br /></td></tr>
<tr class="separator:a2b12391d625e962bacccfb27a660109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d2bd50132f2a9986ae766e3433dc07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad8d2bd50132f2a9986ae766e3433dc07">subscribe</a> (<a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ad8d2bd50132f2a9986ae766e3433dc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ad8d2bd50132f2a9986ae766e3433dc07">More...</a><br /></td></tr>
<tr class="separator:ad8d2bd50132f2a9986ae766e3433dc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77950e184f8c63c5bf71790ee1fb05cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a77950e184f8c63c5bf71790ee1fb05cc">subscribe</a> (as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a77950e184f8c63c5bf71790ee1fb05cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a77950e184f8c63c5bf71790ee1fb05cc">More...</a><br /></td></tr>
<tr class="separator:a77950e184f8c63c5bf71790ee1fb05cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511cab76d8e1c1fb666e38846bef4b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a511cab76d8e1c1fb666e38846bef4b9f">subscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a511cab76d8e1c1fb666e38846bef4b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a511cab76d8e1c1fb666e38846bef4b9f">More...</a><br /></td></tr>
<tr class="separator:a511cab76d8e1c1fb666e38846bef4b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2dc98ab912aa5286330eb84b93650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a44c2dc98ab912aa5286330eb84b93650">subscribe</a> (std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a44c2dc98ab912aa5286330eb84b93650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a44c2dc98ab912aa5286330eb84b93650">More...</a><br /></td></tr>
<tr class="separator:a44c2dc98ab912aa5286330eb84b93650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2506a3f48432467bcfb64715da0a9288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2506a3f48432467bcfb64715da0a9288">subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a2506a3f48432467bcfb64715da0a9288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a2506a3f48432467bcfb64715da0a9288">More...</a><br /></td></tr>
<tr class="separator:a2506a3f48432467bcfb64715da0a9288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dea01f04d2ba650332af41558e6633f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9dea01f04d2ba650332af41558e6633f">subscribe</a> (std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9dea01f04d2ba650332af41558e6633f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a9dea01f04d2ba650332af41558e6633f">More...</a><br /></td></tr>
<tr class="separator:a9dea01f04d2ba650332af41558e6633f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df9b9fdea79fdad5a55aaaae9b27d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6df9b9fdea79fdad5a55aaaae9b27d16">unsubscribe</a> (<a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a6df9b9fdea79fdad5a55aaaae9b27d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a6df9b9fdea79fdad5a55aaaae9b27d16">More...</a><br /></td></tr>
<tr class="separator:a6df9b9fdea79fdad5a55aaaae9b27d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b35b1e92cf3508031d8fa90ca55e7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5b35b1e92cf3508031d8fa90ca55e7ee">unsubscribe</a> (as::const_buffer topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a5b35b1e92cf3508031d8fa90ca55e7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a5b35b1e92cf3508031d8fa90ca55e7ee">More...</a><br /></td></tr>
<tr class="separator:a5b35b1e92cf3508031d8fa90ca55e7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4146e98caadae8b038fe178bda340517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4146e98caadae8b038fe178bda340517">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a4146e98caadae8b038fe178bda340517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4146e98caadae8b038fe178bda340517">More...</a><br /></td></tr>
<tr class="separator:a4146e98caadae8b038fe178bda340517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba6360ee921a1c3366aa26442cbd8c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0ba6360ee921a1c3366aa26442cbd8c0">unsubscribe</a> (std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0ba6360ee921a1c3366aa26442cbd8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a0ba6360ee921a1c3366aa26442cbd8c0">More...</a><br /></td></tr>
<tr class="separator:a0ba6360ee921a1c3366aa26442cbd8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79e71dbb6849334bfffd73848e40bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab79e71dbb6849334bfffd73848e40bff">unsubscribe</a> (std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ab79e71dbb6849334bfffd73848e40bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ab79e71dbb6849334bfffd73848e40bff">More...</a><br /></td></tr>
<tr class="separator:ab79e71dbb6849334bfffd73848e40bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254b37103d31eab6fbddb91d9a3c6cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0254b37103d31eab6fbddb91d9a3c6cf">unsubscribe</a> (std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0254b37103d31eab6fbddb91d9a3c6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a0254b37103d31eab6fbddb91d9a3c6cf">More...</a><br /></td></tr>
<tr class="separator:a0254b37103d31eab6fbddb91d9a3c6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4693c2e48ae0283e29db15294f2cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee">disconnect</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a> reason=<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442a31fe45844c214ec5ad8d824be3709a8d">v5::disconnect_reason_code::normal_disconnection</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a8d4693c2e48ae0283e29db15294f2cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
  <a href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee">More...</a><br /></td></tr>
<tr class="separator:a8d4693c2e48ae0283e29db15294f2cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340f9768dfcb465f5a368244d27d8dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac">force_disconnect</a> ()</td></tr>
<tr class="memdesc:a340f9768dfcb465f5a368244d27d8dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br  />
  <a href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac">More...</a><br /></td></tr>
<tr class="separator:a340f9768dfcb465f5a368244d27d8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e0d9835e95a4e237d55e1e1f0fcfeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a65e0d9835e95a4e237d55e1e1f0fcfeb">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a65e0d9835e95a4e237d55e1e1f0fcfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a65e0d9835e95a4e237d55e1e1f0fcfeb">More...</a><br /></td></tr>
<tr class="separator:a65e0d9835e95a4e237d55e1e1f0fcfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fcd28ad35574b126573b2c6d7db604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a65fcd28ad35574b126573b2c6d7db604">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a65fcd28ad35574b126573b2c6d7db604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a65fcd28ad35574b126573b2c6d7db604">More...</a><br /></td></tr>
<tr class="separator:a65fcd28ad35574b126573b2c6d7db604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dddf70619bb2ecaee32f97464b8802a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3dddf70619bb2ecaee32f97464b8802a">publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a3dddf70619bb2ecaee32f97464b8802a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a3dddf70619bb2ecaee32f97464b8802a">More...</a><br /></td></tr>
<tr class="separator:a3dddf70619bb2ecaee32f97464b8802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f7c5006ec9dd6021b06a954d9077f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae44f7c5006ec9dd6021b06a954d9077f">publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ae44f7c5006ec9dd6021b06a954d9077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ae44f7c5006ec9dd6021b06a954d9077f">More...</a><br /></td></tr>
<tr class="separator:ae44f7c5006ec9dd6021b06a954d9077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a7c19a5b3ffa7ebdd95277221233d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aeb9a7c19a5b3ffa7ebdd95277221233d">publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aeb9a7c19a5b3ffa7ebdd95277221233d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#aeb9a7c19a5b3ffa7ebdd95277221233d">More...</a><br /></td></tr>
<tr class="separator:aeb9a7c19a5b3ffa7ebdd95277221233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73b1bc3490a00acbf02e7bb14b13b75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae73b1bc3490a00acbf02e7bb14b13b75">publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ae73b1bc3490a00acbf02e7bb14b13b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ae73b1bc3490a00acbf02e7bb14b13b75">More...</a><br /></td></tr>
<tr class="separator:ae73b1bc3490a00acbf02e7bb14b13b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022ca4babbb40ca60cd9c03281584811"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a022ca4babbb40ca60cd9c03281584811">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a022ca4babbb40ca60cd9c03281584811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a022ca4babbb40ca60cd9c03281584811">More...</a><br /></td></tr>
<tr class="separator:a022ca4babbb40ca60cd9c03281584811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2f34abac43fd046082175d50d772d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afa2f34abac43fd046082175d50d772d7">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:afa2f34abac43fd046082175d50d772d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#afa2f34abac43fd046082175d50d772d7">More...</a><br /></td></tr>
<tr class="separator:afa2f34abac43fd046082175d50d772d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50b8a30e3e72925ab8dff7518da28f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afe50b8a30e3e72925ab8dff7518da28f">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:afe50b8a30e3e72925ab8dff7518da28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#afe50b8a30e3e72925ab8dff7518da28f">More...</a><br /></td></tr>
<tr class="separator:afe50b8a30e3e72925ab8dff7518da28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b251cac75ff14e264c1bc40b45c2eb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9b251cac75ff14e264c1bc40b45c2eb4">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9b251cac75ff14e264c1bc40b45c2eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a9b251cac75ff14e264c1bc40b45c2eb4">More...</a><br /></td></tr>
<tr class="separator:a9b251cac75ff14e264c1bc40b45c2eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64812942bf42b83801ea48e4352a37a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a64812942bf42b83801ea48e4352a37a9">subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a64812942bf42b83801ea48e4352a37a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a64812942bf42b83801ea48e4352a37a9">More...</a><br /></td></tr>
<tr class="separator:a64812942bf42b83801ea48e4352a37a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab196de6014d8fbd0838adc3e0c2b4fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab196de6014d8fbd0838adc3e0c2b4fb7">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ab196de6014d8fbd0838adc3e0c2b4fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ab196de6014d8fbd0838adc3e0c2b4fb7">More...</a><br /></td></tr>
<tr class="separator:ab196de6014d8fbd0838adc3e0c2b4fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30537313b7312d4901bab82a3e7f3e34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a30537313b7312d4901bab82a3e7f3e34">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a30537313b7312d4901bab82a3e7f3e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a30537313b7312d4901bab82a3e7f3e34">More...</a><br /></td></tr>
<tr class="separator:a30537313b7312d4901bab82a3e7f3e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24597afd8a95f0d353e367eb0f681033"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a24597afd8a95f0d353e367eb0f681033">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a24597afd8a95f0d353e367eb0f681033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a24597afd8a95f0d353e367eb0f681033">More...</a><br /></td></tr>
<tr class="separator:a24597afd8a95f0d353e367eb0f681033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88e75b50e1a4a72e634bf4d6ec6f05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3c88e75b50e1a4a72e634bf4d6ec6f05">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a3c88e75b50e1a4a72e634bf4d6ec6f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a3c88e75b50e1a4a72e634bf4d6ec6f05">More...</a><br /></td></tr>
<tr class="separator:a3c88e75b50e1a4a72e634bf4d6ec6f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e66b73d93958f4e88cee209dfd49437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6e66b73d93958f4e88cee209dfd49437">unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a6e66b73d93958f4e88cee209dfd49437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a6e66b73d93958f4e88cee209dfd49437">More...</a><br /></td></tr>
<tr class="separator:a6e66b73d93958f4e88cee209dfd49437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cfd0ce2fa333134b3182be622af6df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a31cfd0ce2fa333134b3182be622af6df">acquired_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a31cfd0ce2fa333134b3182be622af6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a31cfd0ce2fa333134b3182be622af6df">More...</a><br /></td></tr>
<tr class="separator:a31cfd0ce2fa333134b3182be622af6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df7e2e1db7aecbebf3f54991a57969f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7df7e2e1db7aecbebf3f54991a57969f">acquired_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a7df7e2e1db7aecbebf3f54991a57969f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a7df7e2e1db7aecbebf3f54991a57969f">More...</a><br /></td></tr>
<tr class="separator:a7df7e2e1db7aecbebf3f54991a57969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad289bdf9805ba05637b138b5e91f24fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad289bdf9805ba05637b138b5e91f24fa">acquired_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ad289bdf9805ba05637b138b5e91f24fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ad289bdf9805ba05637b138b5e91f24fa">More...</a><br /></td></tr>
<tr class="separator:ad289bdf9805ba05637b138b5e91f24fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847ee6638de13b8794d6e596808086ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a847ee6638de13b8794d6e596808086ed">acquired_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a847ee6638de13b8794d6e596808086ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a847ee6638de13b8794d6e596808086ed">More...</a><br /></td></tr>
<tr class="separator:a847ee6638de13b8794d6e596808086ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade0676120bbea2100e69b6d3327523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1ade0676120bbea2100e69b6d3327523">acquired_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a1ade0676120bbea2100e69b6d3327523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a1ade0676120bbea2100e69b6d3327523">More...</a><br /></td></tr>
<tr class="separator:a1ade0676120bbea2100e69b6d3327523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e0ed59c3c4f7b7b0f74097eedcb31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa66e0ed59c3c4f7b7b0f74097eedcb31">acquired_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aa66e0ed59c3c4f7b7b0f74097eedcb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#aa66e0ed59c3c4f7b7b0f74097eedcb31">More...</a><br /></td></tr>
<tr class="separator:aa66e0ed59c3c4f7b7b0f74097eedcb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63960f9587f77b83aa8efa39abe1666b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a63960f9587f77b83aa8efa39abe1666b">acquired_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a63960f9587f77b83aa8efa39abe1666b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a63960f9587f77b83aa8efa39abe1666b">More...</a><br /></td></tr>
<tr class="separator:a63960f9587f77b83aa8efa39abe1666b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0995ecad9929c4b0388346c6bf3542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1d0995ecad9929c4b0388346c6bf3542">acquired_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a1d0995ecad9929c4b0388346c6bf3542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a1d0995ecad9929c4b0388346c6bf3542">More...</a><br /></td></tr>
<tr class="separator:a1d0995ecad9929c4b0388346c6bf3542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8b110d1f29af716b23f563d00891c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2d8b110d1f29af716b23f563d00891c0">acquired_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a2d8b110d1f29af716b23f563d00891c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a2d8b110d1f29af716b23f563d00891c0">More...</a><br /></td></tr>
<tr class="separator:a2d8b110d1f29af716b23f563d00891c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0f04803a7cf068a9d1261ab857cf8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aaf0f04803a7cf068a9d1261ab857cf8a">acquired_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aaf0f04803a7cf068a9d1261ab857cf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#aaf0f04803a7cf068a9d1261ab857cf8a">More...</a><br /></td></tr>
<tr class="separator:aaf0f04803a7cf068a9d1261ab857cf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313bdeceba8412452293ffd0414ceddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a313bdeceba8412452293ffd0414ceddb">acquired_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a313bdeceba8412452293ffd0414ceddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a313bdeceba8412452293ffd0414ceddb">More...</a><br /></td></tr>
<tr class="separator:a313bdeceba8412452293ffd0414ceddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3a9faeabd90dfaf966be2522e8e5e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aaf3a9faeabd90dfaf966be2522e8e5e7">acquired_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aaf3a9faeabd90dfaf966be2522e8e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#aaf3a9faeabd90dfaf966be2522e8e5e7">More...</a><br /></td></tr>
<tr class="separator:aaf3a9faeabd90dfaf966be2522e8e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6563414ff3aa2192e9a76e65bf392cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6563414ff3aa2192e9a76e65bf392cc0">acquired_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a6563414ff3aa2192e9a76e65bf392cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a6563414ff3aa2192e9a76e65bf392cc0">More...</a><br /></td></tr>
<tr class="separator:a6563414ff3aa2192e9a76e65bf392cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18944108881f9226283b1185869dea8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a18944108881f9226283b1185869dea8d">acquired_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a18944108881f9226283b1185869dea8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a18944108881f9226283b1185869dea8d">More...</a><br /></td></tr>
<tr class="separator:a18944108881f9226283b1185869dea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91898d5cc7835cb8ba82ffd5b6234835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a91898d5cc7835cb8ba82ffd5b6234835">acquired_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a91898d5cc7835cb8ba82ffd5b6234835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a91898d5cc7835cb8ba82ffd5b6234835">More...</a><br /></td></tr>
<tr class="separator:a91898d5cc7835cb8ba82ffd5b6234835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6073e6c1a564756c1cb350f20650b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af6073e6c1a564756c1cb350f20650b95">pingreq</a> ()</td></tr>
<tr class="memdesc:af6073e6c1a564756c1cb350f20650b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>.  <a href="classMQTT__NS_1_1endpoint.html#af6073e6c1a564756c1cb350f20650b95">More...</a><br /></td></tr>
<tr class="separator:af6073e6c1a564756c1cb350f20650b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9163ebce3564d4bbcdb45ca6ca3718f7">pingresp</a> ()</td></tr>
<tr class="memdesc:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>.  <a href="classMQTT__NS_1_1endpoint.html#a9163ebce3564d4bbcdb45ca6ca3718f7">More...</a><br /></td></tr>
<tr class="separator:a9163ebce3564d4bbcdb45ca6ca3718f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266ca1e346ed7e2a72d84357328bda6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa266ca1e346ed7e2a72d84357328bda6">auth</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aa266ca1e346ed7e2a72d84357328bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>.  <a href="classMQTT__NS_1_1endpoint.html#aa266ca1e346ed7e2a72d84357328bda6">More...</a><br /></td></tr>
<tr class="separator:aa266ca1e346ed7e2a72d84357328bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0142b488912ddb5bb889d01b5c3e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9b0142b488912ddb5bb889d01b5c3e6e">connect</a> (std::string const &amp;client_id, optional&lt; std::string &gt; const &amp;user_name, optional&lt; std::string &gt; const &amp;password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9b0142b488912ddb5bb889d01b5c3e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a9b0142b488912ddb5bb889d01b5c3e6e">More...</a><br /></td></tr>
<tr class="separator:a9b0142b488912ddb5bb889d01b5c3e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19587e80ca96360bc7e43345c1c04fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a19587e80ca96360bc7e43345c1c04fde">connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a19587e80ca96360bc7e43345c1c04fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a19587e80ca96360bc7e43345c1c04fde">More...</a><br /></td></tr>
<tr class="separator:a19587e80ca96360bc7e43345c1c04fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a2e7b925b20d9b6a5bf6123974edec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac9a2e7b925b20d9b6a5bf6123974edec">connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ac9a2e7b925b20d9b6a5bf6123974edec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ac9a2e7b925b20d9b6a5bf6123974edec">More...</a><br /></td></tr>
<tr class="separator:ac9a2e7b925b20d9b6a5bf6123974edec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b9daeff3d9e36c2ce0a43bee5ef83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afe6b9daeff3d9e36c2ce0a43bee5ef83">puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::puback_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:afe6b9daeff3d9e36c2ce0a43bee5ef83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#afe6b9daeff3d9e36c2ce0a43bee5ef83">More...</a><br /></td></tr>
<tr class="separator:afe6b9daeff3d9e36c2ce0a43bee5ef83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961240f654b640c7b8dd7a7cd7d6d29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a961240f654b640c7b8dd7a7cd7d6d29d">pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubrec_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a961240f654b640c7b8dd7a7cd7d6d29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send packet.  <a href="classMQTT__NS_1_1endpoint.html#a961240f654b640c7b8dd7a7cd7d6d29d">More...</a><br /></td></tr>
<tr class="separator:a961240f654b640c7b8dd7a7cd7d6d29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f78448c72ccc7f8888ebf3e3b539e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af2f78448c72ccc7f8888ebf3e3b539e9">pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubrel_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={}, any life_keeper=any())</td></tr>
<tr class="memdesc:af2f78448c72ccc7f8888ebf3e3b539e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#af2f78448c72ccc7f8888ebf3e3b539e9">More...</a><br /></td></tr>
<tr class="separator:af2f78448c72ccc7f8888ebf3e3b539e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7bf271b4ebdcf08aa0a7dea3072939"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0a7bf271b4ebdcf08aa0a7dea3072939">pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubcomp_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0a7bf271b4ebdcf08aa0a7dea3072939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#a0a7bf271b4ebdcf08aa0a7dea3072939">More...</a><br /></td></tr>
<tr class="separator:a0a7bf271b4ebdcf08aa0a7dea3072939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c3a7634b034525ad19062ced8103ff"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa4c3a7634b034525ad19062ced8103ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa4c3a7634b034525ad19062ced8103ff">suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa4c3a7634b034525ad19062ced8103ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#aa4c3a7634b034525ad19062ced8103ff">More...</a><br /></td></tr>
<tr class="separator:aa4c3a7634b034525ad19062ced8103ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6f546a26eae937c53fb4610c224ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7d6f546a26eae937c53fb4610c224ec3">suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a7d6f546a26eae937c53fb4610c224ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a7d6f546a26eae937c53fb4610c224ec3">More...</a><br /></td></tr>
<tr class="separator:a7d6f546a26eae937c53fb4610c224ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9343443234b29e9eb93f5b4ecf05867e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9343443234b29e9eb93f5b4ecf05867e">suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9343443234b29e9eb93f5b4ecf05867e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a9343443234b29e9eb93f5b4ecf05867e">More...</a><br /></td></tr>
<tr class="separator:a9343443234b29e9eb93f5b4ecf05867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1fad6ceb5599d28d1f97c0d2053d129a">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a1fad6ceb5599d28d1f97c0d2053d129a">More...</a><br /></td></tr>
<tr class="separator:a1fad6ceb5599d28d1f97c0d2053d129a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4e8c0871a66e6563b42426e8565160"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9d4e8c0871a66e6563b42426e8565160"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9d4e8c0871a66e6563b42426e8565160">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9d4e8c0871a66e6563b42426e8565160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a9d4e8c0871a66e6563b42426e8565160">More...</a><br /></td></tr>
<tr class="separator:a9d4e8c0871a66e6563b42426e8565160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487276490217b3e7164a6099a229ed6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a487276490217b3e7164a6099a229ed6f">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a487276490217b3e7164a6099a229ed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a487276490217b3e7164a6099a229ed6f">More...</a><br /></td></tr>
<tr class="separator:a487276490217b3e7164a6099a229ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f999764a19542abc320081daacd94c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a53f999764a19542abc320081daacd94c">unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a53f999764a19542abc320081daacd94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a53f999764a19542abc320081daacd94c">More...</a><br /></td></tr>
<tr class="separator:a53f999764a19542abc320081daacd94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b0a463ff07ce6a4caf924be5abdb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac1b0a463ff07ce6a4caf924be5abdb1b">async_publish</a> (std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac1b0a463ff07ce6a4caf924be5abdb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#ac1b0a463ff07ce6a4caf924be5abdb1b">More...</a><br /></td></tr>
<tr class="separator:ac1b0a463ff07ce6a4caf924be5abdb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f36d1b28ce5cf65036d38d5f901e006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9f36d1b28ce5cf65036d38d5f901e006">async_publish</a> (std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9f36d1b28ce5cf65036d38d5f901e006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#a9f36d1b28ce5cf65036d38d5f901e006">More...</a><br /></td></tr>
<tr class="separator:a9f36d1b28ce5cf65036d38d5f901e006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e58c4735a178c8ffcd9ada6728d769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa5e58c4735a178c8ffcd9ada6728d769">async_publish</a> (as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa5e58c4735a178c8ffcd9ada6728d769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#aa5e58c4735a178c8ffcd9ada6728d769">More...</a><br /></td></tr>
<tr class="separator:aa5e58c4735a178c8ffcd9ada6728d769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61da081ba24c06e7d87f7d4223fd551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab61da081ba24c06e7d87f7d4223fd551">async_publish</a> (as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab61da081ba24c06e7d87f7d4223fd551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#ab61da081ba24c06e7d87f7d4223fd551">More...</a><br /></td></tr>
<tr class="separator:ab61da081ba24c06e7d87f7d4223fd551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a1073a6dcde58dce4cdc417b0e24a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a28a1073a6dcde58dce4cdc417b0e24a3">async_publish</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a28a1073a6dcde58dce4cdc417b0e24a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#a28a1073a6dcde58dce4cdc417b0e24a3">More...</a><br /></td></tr>
<tr class="separator:a28a1073a6dcde58dce4cdc417b0e24a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb820cbc29d0ff95d829211168a0daeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aeb820cbc29d0ff95d829211168a0daeb">async_publish</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aeb820cbc29d0ff95d829211168a0daeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="classMQTT__NS_1_1endpoint.html#aeb820cbc29d0ff95d829211168a0daeb">More...</a><br /></td></tr>
<tr class="separator:aeb820cbc29d0ff95d829211168a0daeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f98cefc5ed8175f7ea7b646f7383864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4f98cefc5ed8175f7ea7b646f7383864">async_subscribe</a> (std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4f98cefc5ed8175f7ea7b646f7383864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4f98cefc5ed8175f7ea7b646f7383864">More...</a><br /></td></tr>
<tr class="separator:a4f98cefc5ed8175f7ea7b646f7383864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fbb2f15448986e9620d2414479256f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a84fbb2f15448986e9620d2414479256f">async_subscribe</a> (std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a84fbb2f15448986e9620d2414479256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a84fbb2f15448986e9620d2414479256f">More...</a><br /></td></tr>
<tr class="separator:a84fbb2f15448986e9620d2414479256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63915d83ccc78bc4a76760c8b4d6dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4b63915d83ccc78bc4a76760c8b4d6dd">async_subscribe</a> (as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4b63915d83ccc78bc4a76760c8b4d6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4b63915d83ccc78bc4a76760c8b4d6dd">More...</a><br /></td></tr>
<tr class="separator:a4b63915d83ccc78bc4a76760c8b4d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c0bf81baf46c6428c7d548baacbb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7b7c0bf81baf46c6428c7d548baacbb7">async_subscribe</a> (as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7b7c0bf81baf46c6428c7d548baacbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a7b7c0bf81baf46c6428c7d548baacbb7">More...</a><br /></td></tr>
<tr class="separator:a7b7c0bf81baf46c6428c7d548baacbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd70462588939a7bde40465ce60340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7cfd70462588939a7bde40465ce60340">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7cfd70462588939a7bde40465ce60340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a7cfd70462588939a7bde40465ce60340">More...</a><br /></td></tr>
<tr class="separator:a7cfd70462588939a7bde40465ce60340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2436dfd11052741134a96967f584c0ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2436dfd11052741134a96967f584c0ed">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2436dfd11052741134a96967f584c0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a2436dfd11052741134a96967f584c0ed">More...</a><br /></td></tr>
<tr class="separator:a2436dfd11052741134a96967f584c0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f0d5e6333f0a4ed2b236d447dba7ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a15f0d5e6333f0a4ed2b236d447dba7ad">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a15f0d5e6333f0a4ed2b236d447dba7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a15f0d5e6333f0a4ed2b236d447dba7ad">More...</a><br /></td></tr>
<tr class="separator:a15f0d5e6333f0a4ed2b236d447dba7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3dd152b7a4a53919bcf5a6bf1ccea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5f3dd152b7a4a53919bcf5a6bf1ccea8">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a5f3dd152b7a4a53919bcf5a6bf1ccea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a5f3dd152b7a4a53919bcf5a6bf1ccea8">More...</a><br /></td></tr>
<tr class="separator:a5f3dd152b7a4a53919bcf5a6bf1ccea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe84c3665de1331e951633d2e050a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6fe84c3665de1331e951633d2e050a1d">async_subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6fe84c3665de1331e951633d2e050a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a6fe84c3665de1331e951633d2e050a1d">More...</a><br /></td></tr>
<tr class="separator:a6fe84c3665de1331e951633d2e050a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf63685e811cb152888d38456b1092f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acf63685e811cb152888d38456b1092f2">async_subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:acf63685e811cb152888d38456b1092f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#acf63685e811cb152888d38456b1092f2">More...</a><br /></td></tr>
<tr class="separator:acf63685e811cb152888d38456b1092f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4391186a1b5d1a62482f61b79286a2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4391186a1b5d1a62482f61b79286a2f7">async_subscribe</a> (std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4391186a1b5d1a62482f61b79286a2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4391186a1b5d1a62482f61b79286a2f7">More...</a><br /></td></tr>
<tr class="separator:a4391186a1b5d1a62482f61b79286a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64357ed1f9b839233e391155879c6e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a64357ed1f9b839233e391155879c6e37">async_subscribe</a> (std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a64357ed1f9b839233e391155879c6e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a64357ed1f9b839233e391155879c6e37">More...</a><br /></td></tr>
<tr class="separator:a64357ed1f9b839233e391155879c6e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876353d33c80f75ec9847c3fb23748ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a876353d33c80f75ec9847c3fb23748ca">async_unsubscribe</a> (std::string topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a876353d33c80f75ec9847c3fb23748ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a876353d33c80f75ec9847c3fb23748ca">More...</a><br /></td></tr>
<tr class="separator:a876353d33c80f75ec9847c3fb23748ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5abac88b6abb79a880449bfe552a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1b5abac88b6abb79a880449bfe552a17">async_unsubscribe</a> (std::string topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1b5abac88b6abb79a880449bfe552a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a1b5abac88b6abb79a880449bfe552a17">More...</a><br /></td></tr>
<tr class="separator:a1b5abac88b6abb79a880449bfe552a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a54839fd71bcc487a122c036b874ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a02a54839fd71bcc487a122c036b874ee">async_unsubscribe</a> (as::const_buffer topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a02a54839fd71bcc487a122c036b874ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a02a54839fd71bcc487a122c036b874ee">More...</a><br /></td></tr>
<tr class="separator:a02a54839fd71bcc487a122c036b874ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ef23df3587b52745fd4a6081e36c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac9ef23df3587b52745fd4a6081e36c9b">async_unsubscribe</a> (as::const_buffer topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac9ef23df3587b52745fd4a6081e36c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ac9ef23df3587b52745fd4a6081e36c9b">More...</a><br /></td></tr>
<tr class="separator:ac9ef23df3587b52745fd4a6081e36c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d689cc3b1502dd55c8273580e6a2cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8d689cc3b1502dd55c8273580e6a2cb8">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8d689cc3b1502dd55c8273580e6a2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a8d689cc3b1502dd55c8273580e6a2cb8">More...</a><br /></td></tr>
<tr class="separator:a8d689cc3b1502dd55c8273580e6a2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e54190b724a9b99e8e7b46325a369c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a88e54190b724a9b99e8e7b46325a369c">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a88e54190b724a9b99e8e7b46325a369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a88e54190b724a9b99e8e7b46325a369c">More...</a><br /></td></tr>
<tr class="separator:a88e54190b724a9b99e8e7b46325a369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7d190868f60cbd19bfdcf8f086209a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9e7d190868f60cbd19bfdcf8f086209a">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9e7d190868f60cbd19bfdcf8f086209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a9e7d190868f60cbd19bfdcf8f086209a">More...</a><br /></td></tr>
<tr class="separator:a9e7d190868f60cbd19bfdcf8f086209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe89a4f70da29fd01bc92b28b102d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aebe89a4f70da29fd01bc92b28b102d62">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aebe89a4f70da29fd01bc92b28b102d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aebe89a4f70da29fd01bc92b28b102d62">More...</a><br /></td></tr>
<tr class="separator:aebe89a4f70da29fd01bc92b28b102d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0dce5f45082e7d61caa5dc48e0ca81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4f0dce5f45082e7d61caa5dc48e0ca81">async_unsubscribe</a> (std::vector&lt; as::const_buffer &gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4f0dce5f45082e7d61caa5dc48e0ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4f0dce5f45082e7d61caa5dc48e0ca81">More...</a><br /></td></tr>
<tr class="separator:a4f0dce5f45082e7d61caa5dc48e0ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa288246823d76a7dd5cba01e81951e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa288246823d76a7dd5cba01e81951e0c">async_unsubscribe</a> (std::vector&lt; as::const_buffer &gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa288246823d76a7dd5cba01e81951e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aa288246823d76a7dd5cba01e81951e0c">More...</a><br /></td></tr>
<tr class="separator:aa288246823d76a7dd5cba01e81951e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b5b9c7457995b7465e9d7a5d5bbc5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a29b5b9c7457995b7465e9d7a5d5bbc5a">async_unsubscribe</a> (std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a29b5b9c7457995b7465e9d7a5d5bbc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a29b5b9c7457995b7465e9d7a5d5bbc5a">More...</a><br /></td></tr>
<tr class="separator:a29b5b9c7457995b7465e9d7a5d5bbc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde0eda9224c321bced015f99da002e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3bde0eda9224c321bced015f99da002e">async_unsubscribe</a> (std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3bde0eda9224c321bced015f99da002e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a3bde0eda9224c321bced015f99da002e">More...</a><br /></td></tr>
<tr class="separator:a3bde0eda9224c321bced015f99da002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cdf8e4232b18f8cfecfd000b10a65f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a57cdf8e4232b18f8cfecfd000b10a65f">async_disconnect</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a57cdf8e4232b18f8cfecfd000b10a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="classMQTT__NS_1_1endpoint.html#a57cdf8e4232b18f8cfecfd000b10a65f">More...</a><br /></td></tr>
<tr class="separator:a57cdf8e4232b18f8cfecfd000b10a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dfa3d9410b87644779e04d2d174cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a20dfa3d9410b87644779e04d2d174cc7">async_disconnect</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a> reason, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a20dfa3d9410b87644779e04d2d174cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="classMQTT__NS_1_1endpoint.html#a20dfa3d9410b87644779e04d2d174cc7">More...</a><br /></td></tr>
<tr class="separator:a20dfa3d9410b87644779e04d2d174cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189203d0cc2004af3617d188ff6c65b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a189203d0cc2004af3617d188ff6c65b2">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a189203d0cc2004af3617d188ff6c65b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a189203d0cc2004af3617d188ff6c65b2">More...</a><br /></td></tr>
<tr class="separator:a189203d0cc2004af3617d188ff6c65b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ae086e842e858783b628f2a36d80e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a712ae086e842e858783b628f2a36d80e">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a712ae086e842e858783b628f2a36d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a712ae086e842e858783b628f2a36d80e">More...</a><br /></td></tr>
<tr class="separator:a712ae086e842e858783b628f2a36d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ee5540fa49bf593d2fd39da7b07e58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a94ee5540fa49bf593d2fd39da7b07e58">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a94ee5540fa49bf593d2fd39da7b07e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a94ee5540fa49bf593d2fd39da7b07e58">More...</a><br /></td></tr>
<tr class="separator:a94ee5540fa49bf593d2fd39da7b07e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6e920fa6264dee8ad0b4e726f05b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adf6e920fa6264dee8ad0b4e726f05b59">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:adf6e920fa6264dee8ad0b4e726f05b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#adf6e920fa6264dee8ad0b4e726f05b59">More...</a><br /></td></tr>
<tr class="separator:adf6e920fa6264dee8ad0b4e726f05b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d3424110fbf9ded73ffd12c760aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8b1d3424110fbf9ded73ffd12c760aec">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8b1d3424110fbf9ded73ffd12c760aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a8b1d3424110fbf9ded73ffd12c760aec">More...</a><br /></td></tr>
<tr class="separator:a8b1d3424110fbf9ded73ffd12c760aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7e7448d43c5dcbc66821f71a80755c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9e7e7448d43c5dcbc66821f71a80755c">async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9e7e7448d43c5dcbc66821f71a80755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a9e7e7448d43c5dcbc66821f71a80755c">More...</a><br /></td></tr>
<tr class="separator:a9e7e7448d43c5dcbc66821f71a80755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f04d24345d7f352d0611a1633b2c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a389f04d24345d7f352d0611a1633b2c8">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a389f04d24345d7f352d0611a1633b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a389f04d24345d7f352d0611a1633b2c8">More...</a><br /></td></tr>
<tr class="separator:a389f04d24345d7f352d0611a1633b2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac353626f8ba94c0475d414a35f04bdcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac353626f8ba94c0475d414a35f04bdcc">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac353626f8ba94c0475d414a35f04bdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ac353626f8ba94c0475d414a35f04bdcc">More...</a><br /></td></tr>
<tr class="separator:ac353626f8ba94c0475d414a35f04bdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3a90b45da1e49bc33b0b5b4ebe49de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abb3a90b45da1e49bc33b0b5b4ebe49de">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abb3a90b45da1e49bc33b0b5b4ebe49de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#abb3a90b45da1e49bc33b0b5b4ebe49de">More...</a><br /></td></tr>
<tr class="separator:abb3a90b45da1e49bc33b0b5b4ebe49de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bf6e807c226213865c64483ce4b204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a62bf6e807c226213865c64483ce4b204">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a62bf6e807c226213865c64483ce4b204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a62bf6e807c226213865c64483ce4b204">More...</a><br /></td></tr>
<tr class="separator:a62bf6e807c226213865c64483ce4b204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5329435a0ced477f6a7a8cdf26bbbae8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5329435a0ced477f6a7a8cdf26bbbae8">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a5329435a0ced477f6a7a8cdf26bbbae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a5329435a0ced477f6a7a8cdf26bbbae8">More...</a><br /></td></tr>
<tr class="separator:a5329435a0ced477f6a7a8cdf26bbbae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd93af51944c7e187211bdfb86f4d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a13fd93af51944c7e187211bdfb86f4d7">async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a13fd93af51944c7e187211bdfb86f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a13fd93af51944c7e187211bdfb86f4d7">More...</a><br /></td></tr>
<tr class="separator:a13fd93af51944c7e187211bdfb86f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eb5f791cccc6318e1613e6f7a11694"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a20eb5f791cccc6318e1613e6f7a11694">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a20eb5f791cccc6318e1613e6f7a11694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a20eb5f791cccc6318e1613e6f7a11694">More...</a><br /></td></tr>
<tr class="separator:a20eb5f791cccc6318e1613e6f7a11694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6a38b8613f865d3fa4b18305f4c2b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4a6a38b8613f865d3fa4b18305f4c2b5">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4a6a38b8613f865d3fa4b18305f4c2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4a6a38b8613f865d3fa4b18305f4c2b5">More...</a><br /></td></tr>
<tr class="separator:a4a6a38b8613f865d3fa4b18305f4c2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a3be599a8bfc5fd8a5ba3c54e5c1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afa0a3be599a8bfc5fd8a5ba3c54e5c1e">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:afa0a3be599a8bfc5fd8a5ba3c54e5c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#afa0a3be599a8bfc5fd8a5ba3c54e5c1e">More...</a><br /></td></tr>
<tr class="separator:afa0a3be599a8bfc5fd8a5ba3c54e5c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac491d642720bb87b9bf53140db5024db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac491d642720bb87b9bf53140db5024db">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac491d642720bb87b9bf53140db5024db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ac491d642720bb87b9bf53140db5024db">More...</a><br /></td></tr>
<tr class="separator:ac491d642720bb87b9bf53140db5024db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb79dd4b4d3b29759b3ee99d98d849b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#addb79dd4b4d3b29759b3ee99d98d849b">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:addb79dd4b4d3b29759b3ee99d98d849b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#addb79dd4b4d3b29759b3ee99d98d849b">More...</a><br /></td></tr>
<tr class="separator:addb79dd4b4d3b29759b3ee99d98d849b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed0485ed8f9e68d8760145d4ad78a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af1ed0485ed8f9e68d8760145d4ad78a8">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:af1ed0485ed8f9e68d8760145d4ad78a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#af1ed0485ed8f9e68d8760145d4ad78a8">More...</a><br /></td></tr>
<tr class="separator:af1ed0485ed8f9e68d8760145d4ad78a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3625a930e75c8d9ec9f15d18bf9746b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3625a930e75c8d9ec9f15d18bf9746b7">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3625a930e75c8d9ec9f15d18bf9746b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a3625a930e75c8d9ec9f15d18bf9746b7">More...</a><br /></td></tr>
<tr class="separator:a3625a930e75c8d9ec9f15d18bf9746b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7bc59adb4d4b03211363a9b69ecf6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abc7bc59adb4d4b03211363a9b69ecf6c">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abc7bc59adb4d4b03211363a9b69ecf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#abc7bc59adb4d4b03211363a9b69ecf6c">More...</a><br /></td></tr>
<tr class="separator:abc7bc59adb4d4b03211363a9b69ecf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6493fa980bbba11e02d8dc3be3a5223"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae6493fa980bbba11e02d8dc3be3a5223">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae6493fa980bbba11e02d8dc3be3a5223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ae6493fa980bbba11e02d8dc3be3a5223">More...</a><br /></td></tr>
<tr class="separator:ae6493fa980bbba11e02d8dc3be3a5223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ee91fe4aff95c26c7a26bd8af99bd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a84ee91fe4aff95c26c7a26bd8af99bd4">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a84ee91fe4aff95c26c7a26bd8af99bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a84ee91fe4aff95c26c7a26bd8af99bd4">More...</a><br /></td></tr>
<tr class="separator:a84ee91fe4aff95c26c7a26bd8af99bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bec7baf1b82ecb16ed7a40a79d3a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa0bec7baf1b82ecb16ed7a40a79d3a63">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa0bec7baf1b82ecb16ed7a40a79d3a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#aa0bec7baf1b82ecb16ed7a40a79d3a63">More...</a><br /></td></tr>
<tr class="separator:aa0bec7baf1b82ecb16ed7a40a79d3a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab089e713cfd4f41276fd0ab4406fd6a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab089e713cfd4f41276fd0ab4406fd6a8">async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab089e713cfd4f41276fd0ab4406fd6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ab089e713cfd4f41276fd0ab4406fd6a8">More...</a><br /></td></tr>
<tr class="separator:ab089e713cfd4f41276fd0ab4406fd6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c36b12ec0784f686beafda8d55876"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac99c36b12ec0784f686beafda8d55876">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac99c36b12ec0784f686beafda8d55876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ac99c36b12ec0784f686beafda8d55876">More...</a><br /></td></tr>
<tr class="separator:ac99c36b12ec0784f686beafda8d55876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace82fa1f346a54cc4caca780e0a52d1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ace82fa1f346a54cc4caca780e0a52d1f">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ace82fa1f346a54cc4caca780e0a52d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#ace82fa1f346a54cc4caca780e0a52d1f">More...</a><br /></td></tr>
<tr class="separator:ace82fa1f346a54cc4caca780e0a52d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f17c0be7f863494611aaaa4039a1de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a86f17c0be7f863494611aaaa4039a1de">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a86f17c0be7f863494611aaaa4039a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a86f17c0be7f863494611aaaa4039a1de">More...</a><br /></td></tr>
<tr class="separator:a86f17c0be7f863494611aaaa4039a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645cad51dd6f6919aa3b86086b1abdb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a645cad51dd6f6919aa3b86086b1abdb0">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a645cad51dd6f6919aa3b86086b1abdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a645cad51dd6f6919aa3b86086b1abdb0">More...</a><br /></td></tr>
<tr class="separator:a645cad51dd6f6919aa3b86086b1abdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f4bcd2b5ef915f6fcb974024a34696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae0f4bcd2b5ef915f6fcb974024a34696">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; const &amp;params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae0f4bcd2b5ef915f6fcb974024a34696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ae0f4bcd2b5ef915f6fcb974024a34696">More...</a><br /></td></tr>
<tr class="separator:ae0f4bcd2b5ef915f6fcb974024a34696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc0248ba5c3d3781fa36d8e7e91463a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afbc0248ba5c3d3781fa36d8e7e91463a">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; const &amp;params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:afbc0248ba5c3d3781fa36d8e7e91463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#afbc0248ba5c3d3781fa36d8e7e91463a">More...</a><br /></td></tr>
<tr class="separator:afbc0248ba5c3d3781fa36d8e7e91463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d7a16a11bab22f44f5b718c84a165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa49d7a16a11bab22f44f5b718c84a165">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa49d7a16a11bab22f44f5b718c84a165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aa49d7a16a11bab22f44f5b718c84a165">More...</a><br /></td></tr>
<tr class="separator:aa49d7a16a11bab22f44f5b718c84a165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84566141b51eea853b92bb1bd8458c66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a84566141b51eea853b92bb1bd8458c66">async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a84566141b51eea853b92bb1bd8458c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a84566141b51eea853b92bb1bd8458c66">More...</a><br /></td></tr>
<tr class="separator:a84566141b51eea853b92bb1bd8458c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eb2583bb040f099cf4d14ea249609c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a56eb2583bb040f099cf4d14ea249609c">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a56eb2583bb040f099cf4d14ea249609c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a56eb2583bb040f099cf4d14ea249609c">More...</a><br /></td></tr>
<tr class="separator:a56eb2583bb040f099cf4d14ea249609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7cbb430d750096605dc04707980a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9a7cbb430d750096605dc04707980a70">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9a7cbb430d750096605dc04707980a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a9a7cbb430d750096605dc04707980a70">More...</a><br /></td></tr>
<tr class="separator:a9a7cbb430d750096605dc04707980a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ed43d4ad6ada34a118d28e8931a1a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a57ed43d4ad6ada34a118d28e8931a1a5">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a57ed43d4ad6ada34a118d28e8931a1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a57ed43d4ad6ada34a118d28e8931a1a5">More...</a><br /></td></tr>
<tr class="separator:a57ed43d4ad6ada34a118d28e8931a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ef23ac11df694b34d9b04a8524dc53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a73ef23ac11df694b34d9b04a8524dc53">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a73ef23ac11df694b34d9b04a8524dc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a73ef23ac11df694b34d9b04a8524dc53">More...</a><br /></td></tr>
<tr class="separator:a73ef23ac11df694b34d9b04a8524dc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b1823978f45630e5aa486dc3b8d260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a88b1823978f45630e5aa486dc3b8d260">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a88b1823978f45630e5aa486dc3b8d260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a88b1823978f45630e5aa486dc3b8d260">More...</a><br /></td></tr>
<tr class="separator:a88b1823978f45630e5aa486dc3b8d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357464f4863ddd0e745e0bfbda9a6f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3357464f4863ddd0e745e0bfbda9a6f1">acquired_async_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3357464f4863ddd0e745e0bfbda9a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a3357464f4863ddd0e745e0bfbda9a6f1">More...</a><br /></td></tr>
<tr class="separator:a3357464f4863ddd0e745e0bfbda9a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0e947db191ff3d6874173ed2c89e57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abe0e947db191ff3d6874173ed2c89e57">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abe0e947db191ff3d6874173ed2c89e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#abe0e947db191ff3d6874173ed2c89e57">More...</a><br /></td></tr>
<tr class="separator:abe0e947db191ff3d6874173ed2c89e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf258cc62729fe6d47dfa9654419fbd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acf258cc62729fe6d47dfa9654419fbd0">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, std::string contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:acf258cc62729fe6d47dfa9654419fbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#acf258cc62729fe6d47dfa9654419fbd0">More...</a><br /></td></tr>
<tr class="separator:acf258cc62729fe6d47dfa9654419fbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7548a09706be1ad7240ab2d90d07a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abf7548a09706be1ad7240ab2d90d07a0">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abf7548a09706be1ad7240ab2d90d07a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#abf7548a09706be1ad7240ab2d90d07a0">More...</a><br /></td></tr>
<tr class="separator:abf7548a09706be1ad7240ab2d90d07a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fc0c818fcec7ee41bf915d194658c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a359fc0c818fcec7ee41bf915d194658c">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, any life_keeper, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a359fc0c818fcec7ee41bf915d194658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a359fc0c818fcec7ee41bf915d194658c">More...</a><br /></td></tr>
<tr class="separator:a359fc0c818fcec7ee41bf915d194658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1c35f60b2a338d6b9cae75b014acc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abb1c35f60b2a338d6b9cae75b014acc8">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value=<a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>=false, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abb1c35f60b2a338d6b9cae75b014acc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#abb1c35f60b2a338d6b9cae75b014acc8">More...</a><br /></td></tr>
<tr class="separator:abb1c35f60b2a338d6b9cae75b014acc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f879fc9e1cd122e9fa531acace9ef14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7f879fc9e1cd122e9fa531acace9ef14">acquired_async_publish_dup</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> contents, <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a> qos_value, bool <a class="el" href="namespaceMQTT__NS.html#ae9ca6e99fc28d9b59325754e8b8ce788a16d79ff80feadcf2f52096f073f2b94a">retain</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7f879fc9e1cd122e9fa531acace9ef14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="classMQTT__NS_1_1endpoint.html#a7f879fc9e1cd122e9fa531acace9ef14">More...</a><br /></td></tr>
<tr class="separator:a7f879fc9e1cd122e9fa531acace9ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba253ed5db5179a59933384db666cf4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aba253ed5db5179a59933384db666cf4c">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aba253ed5db5179a59933384db666cf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#aba253ed5db5179a59933384db666cf4c">More...</a><br /></td></tr>
<tr class="separator:aba253ed5db5179a59933384db666cf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4f03cc36f06c884713eec5036a63b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abd4f03cc36f06c884713eec5036a63b0">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abd4f03cc36f06c884713eec5036a63b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#abd4f03cc36f06c884713eec5036a63b0">More...</a><br /></td></tr>
<tr class="separator:abd4f03cc36f06c884713eec5036a63b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddddee04d4cc6ed05ea842655c656f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6ddddee04d4cc6ed05ea842655c656f3">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6ddddee04d4cc6ed05ea842655c656f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a6ddddee04d4cc6ed05ea842655c656f3">More...</a><br /></td></tr>
<tr class="separator:a6ddddee04d4cc6ed05ea842655c656f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21028b1ce65f6fb13e5150e3325a44d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a21028b1ce65f6fb13e5150e3325a44d4">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a21028b1ce65f6fb13e5150e3325a44d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a21028b1ce65f6fb13e5150e3325a44d4">More...</a><br /></td></tr>
<tr class="separator:a21028b1ce65f6fb13e5150e3325a44d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da3ca961c3af241cb9573b123a8277a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a7da3ca961c3af241cb9573b123a8277a">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7da3ca961c3af241cb9573b123a8277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a7da3ca961c3af241cb9573b123a8277a">More...</a><br /></td></tr>
<tr class="separator:a7da3ca961c3af241cb9573b123a8277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ebe10a9f4bf03e7ec076960274fc70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a62ebe10a9f4bf03e7ec076960274fc70">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> option, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a62ebe10a9f4bf03e7ec076960274fc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a62ebe10a9f4bf03e7ec076960274fc70">More...</a><br /></td></tr>
<tr class="separator:a62ebe10a9f4bf03e7ec076960274fc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b5ffd1694ee404281b008ff587a946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af0b5ffd1694ee404281b008ff587a946">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:af0b5ffd1694ee404281b008ff587a946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#af0b5ffd1694ee404281b008ff587a946">More...</a><br /></td></tr>
<tr class="separator:af0b5ffd1694ee404281b008ff587a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d64408fec544e992df6e79e9cd862b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a68d64408fec544e992df6e79e9cd862b">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a68d64408fec544e992df6e79e9cd862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a68d64408fec544e992df6e79e9cd862b">More...</a><br /></td></tr>
<tr class="separator:a68d64408fec544e992df6e79e9cd862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad839a27fbbb20f45d614ccffe8311806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad839a27fbbb20f45d614ccffe8311806">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad839a27fbbb20f45d614ccffe8311806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#ad839a27fbbb20f45d614ccffe8311806">More...</a><br /></td></tr>
<tr class="separator:ad839a27fbbb20f45d614ccffe8311806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a06056687f3af18d027ca9c6f4a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4d4a06056687f3af18d027ca9c6f4a36">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4d4a06056687f3af18d027ca9c6f4a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a4d4a06056687f3af18d027ca9c6f4a36">More...</a><br /></td></tr>
<tr class="separator:a4d4a06056687f3af18d027ca9c6f4a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2ee2b95dbdbebb05f325ba3f970e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#abae2ee2b95dbdbebb05f325ba3f970e2">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:abae2ee2b95dbdbebb05f325ba3f970e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#abae2ee2b95dbdbebb05f325ba3f970e2">More...</a><br /></td></tr>
<tr class="separator:abae2ee2b95dbdbebb05f325ba3f970e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3061ede81b46726eb8eb2a702a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a97e3061ede81b46726eb8eb2a702a08e">acquired_async_subscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a97e3061ede81b46726eb8eb2a702a08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="classMQTT__NS_1_1endpoint.html#a97e3061ede81b46726eb8eb2a702a08e">More...</a><br /></td></tr>
<tr class="separator:a97e3061ede81b46726eb8eb2a702a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a48bece400dead5646db0b3b6c820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a473a48bece400dead5646db0b3b6c820">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::string topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a473a48bece400dead5646db0b3b6c820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a473a48bece400dead5646db0b3b6c820">More...</a><br /></td></tr>
<tr class="separator:a473a48bece400dead5646db0b3b6c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c5ea4e72db8a58e7eef58bf21053c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa88c5ea4e72db8a58e7eef58bf21053c">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, as::const_buffer topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa88c5ea4e72db8a58e7eef58bf21053c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aa88c5ea4e72db8a58e7eef58bf21053c">More...</a><br /></td></tr>
<tr class="separator:aa88c5ea4e72db8a58e7eef58bf21053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a82ac34326f3c6c962274ae6a30b191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9a82ac34326f3c6c962274ae6a30b191">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9a82ac34326f3c6c962274ae6a30b191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a9a82ac34326f3c6c962274ae6a30b191">More...</a><br /></td></tr>
<tr class="separator:a9a82ac34326f3c6c962274ae6a30b191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8305d69c57f24cad925989fa6f361da7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8305d69c57f24cad925989fa6f361da7">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> topic_name, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8305d69c57f24cad925989fa6f361da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a8305d69c57f24cad925989fa6f361da7">More...</a><br /></td></tr>
<tr class="separator:a8305d69c57f24cad925989fa6f361da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f4f15311dd4394051eeed07a2b2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a178f4f15311dd4394051eeed07a2b2a4">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a178f4f15311dd4394051eeed07a2b2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a178f4f15311dd4394051eeed07a2b2a4">More...</a><br /></td></tr>
<tr class="separator:a178f4f15311dd4394051eeed07a2b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aed79ebad9c4cdd94e9710bc5a8d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa5aed79ebad9c4cdd94e9710bc5a8d25">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa5aed79ebad9c4cdd94e9710bc5a8d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#aa5aed79ebad9c4cdd94e9710bc5a8d25">More...</a><br /></td></tr>
<tr class="separator:aa5aed79ebad9c4cdd94e9710bc5a8d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953eacbfd1c2f9c665a177ffe8f7f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab953eacbfd1c2f9c665a177ffe8f7f61">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab953eacbfd1c2f9c665a177ffe8f7f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ab953eacbfd1c2f9c665a177ffe8f7f61">More...</a><br /></td></tr>
<tr class="separator:ab953eacbfd1c2f9c665a177ffe8f7f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a844dfd6e0277b314ed482832ea854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab5a844dfd6e0277b314ed482832ea854">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab5a844dfd6e0277b314ed482832ea854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#ab5a844dfd6e0277b314ed482832ea854">More...</a><br /></td></tr>
<tr class="separator:ab5a844dfd6e0277b314ed482832ea854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596171fe276f12b47c6b7497db75665b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a596171fe276f12b47c6b7497db75665b">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a596171fe276f12b47c6b7497db75665b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a596171fe276f12b47c6b7497db75665b">More...</a><br /></td></tr>
<tr class="separator:a596171fe276f12b47c6b7497db75665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd7d3135e6cf1583bb5c37064bdab3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0dd7d3135e6cf1583bb5c37064bdab3d">acquired_async_unsubscribe</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; params, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0dd7d3135e6cf1583bb5c37064bdab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="classMQTT__NS_1_1endpoint.html#a0dd7d3135e6cf1583bb5c37064bdab3d">More...</a><br /></td></tr>
<tr class="separator:a0dd7d3135e6cf1583bb5c37064bdab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c3eef41e425e4037644aacaf746feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab5c3eef41e425e4037644aacaf746feb">async_pingreq</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab5c3eef41e425e4037644aacaf746feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet.  <a href="classMQTT__NS_1_1endpoint.html#ab5c3eef41e425e4037644aacaf746feb">More...</a><br /></td></tr>
<tr class="separator:ab5c3eef41e425e4037644aacaf746feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fbd466b45a2b9e6b21ede007578cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa3fbd466b45a2b9e6b21ede007578cb6">async_pingresp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa3fbd466b45a2b9e6b21ede007578cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#aa3fbd466b45a2b9e6b21ede007578cb6">More...</a><br /></td></tr>
<tr class="separator:aa3fbd466b45a2b9e6b21ede007578cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1016657bfc6a1c865b2d6763da0be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3e1016657bfc6a1c865b2d6763da0be0">async_auth</a> (<a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a> reason_code=<a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a>, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props={}, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3e1016657bfc6a1c865b2d6763da0be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet.  <a href="classMQTT__NS_1_1endpoint.html#a3e1016657bfc6a1c865b2d6763da0be0">More...</a><br /></td></tr>
<tr class="separator:a3e1016657bfc6a1c865b2d6763da0be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6534dcc5312f30e3eead2a43ff6d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1d6534dcc5312f30e3eead2a43ff6d57">async_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1d6534dcc5312f30e3eead2a43ff6d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#a1d6534dcc5312f30e3eead2a43ff6d57">More...</a><br /></td></tr>
<tr class="separator:a1d6534dcc5312f30e3eead2a43ff6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88fa1e8b093c2f762247b02cca0e1cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad88fa1e8b093c2f762247b02cca0e1cd">async_connect</a> (<a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> client_id, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; user_name, optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt; password, optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt; w, std::uint16_t keep_alive_sec, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad88fa1e8b093c2f762247b02cca0e1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="classMQTT__NS_1_1endpoint.html#ad88fa1e8b093c2f762247b02cca0e1cd">More...</a><br /></td></tr>
<tr class="separator:ad88fa1e8b093c2f762247b02cca0e1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98965931dec1a70439ce28ce7d5e663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa98965931dec1a70439ce28ce7d5e663">async_connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa98965931dec1a70439ce28ce7d5e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#aa98965931dec1a70439ce28ce7d5e663">More...</a><br /></td></tr>
<tr class="separator:aa98965931dec1a70439ce28ce7d5e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f249cf6feb9edf3bfc091660c8cfba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a1f249cf6feb9edf3bfc091660c8cfba6">async_connack</a> (bool session_present, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt; reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1f249cf6feb9edf3bfc091660c8cfba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a1f249cf6feb9edf3bfc091660c8cfba6">More...</a><br /></td></tr>
<tr class="separator:a1f249cf6feb9edf3bfc091660c8cfba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e99d2211df33c12c769f050f6013938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9e99d2211df33c12c769f050f6013938">async_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9e99d2211df33c12c769f050f6013938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#a9e99d2211df33c12c769f050f6013938">More...</a><br /></td></tr>
<tr class="separator:a9e99d2211df33c12c769f050f6013938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bf27d98bad7de18a6954b7263fbca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af3bf27d98bad7de18a6954b7263fbca1">async_puback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:af3bf27d98bad7de18a6954b7263fbca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="classMQTT__NS_1_1endpoint.html#af3bf27d98bad7de18a6954b7263fbca1">More...</a><br /></td></tr>
<tr class="separator:af3bf27d98bad7de18a6954b7263fbca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad2ca1b11081d1304b06a18f32a70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a13ad2ca1b11081d1304b06a18f32a70d">async_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a13ad2ca1b11081d1304b06a18f32a70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="classMQTT__NS_1_1endpoint.html#a13ad2ca1b11081d1304b06a18f32a70d">More...</a><br /></td></tr>
<tr class="separator:a13ad2ca1b11081d1304b06a18f32a70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b9f54bc30f2eb0d612c2e8b48f8a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a88b9f54bc30f2eb0d612c2e8b48f8a64">async_pubrec</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a88b9f54bc30f2eb0d612c2e8b48f8a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="classMQTT__NS_1_1endpoint.html#a88b9f54bc30f2eb0d612c2e8b48f8a64">More...</a><br /></td></tr>
<tr class="separator:a88b9f54bc30f2eb0d612c2e8b48f8a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7bf27ddc348695abd318af7dee7e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a5c7bf27ddc348695abd318af7dee7e90">async_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a5c7bf27ddc348695abd318af7dee7e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#a5c7bf27ddc348695abd318af7dee7e90">More...</a><br /></td></tr>
<tr class="separator:a5c7bf27ddc348695abd318af7dee7e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8060887a13996e577911b4903625998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af8060887a13996e577911b4903625998">async_pubrel</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>(), any life_keeper=any())</td></tr>
<tr class="memdesc:af8060887a13996e577911b4903625998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="classMQTT__NS_1_1endpoint.html#af8060887a13996e577911b4903625998">More...</a><br /></td></tr>
<tr class="separator:af8060887a13996e577911b4903625998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bd78e74d65fa1d8845d2c5679b4c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac0bd78e74d65fa1d8845d2c5679b4c0a">async_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac0bd78e74d65fa1d8845d2c5679b4c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#ac0bd78e74d65fa1d8845d2c5679b4c0a">More...</a><br /></td></tr>
<tr class="separator:ac0bd78e74d65fa1d8845d2c5679b4c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b2f1a5ec413438d8300a7be903a3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a29b2f1a5ec413438d8300a7be903a3f9">async_pubcomp</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a> reason_code, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a29b2f1a5ec413438d8300a7be903a3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="classMQTT__NS_1_1endpoint.html#a29b2f1a5ec413438d8300a7be903a3f9">More...</a><br /></td></tr>
<tr class="separator:a29b2f1a5ec413438d8300a7be903a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45c4fbcac4e778891b8f37c43e4a83a"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ad45c4fbcac4e778891b8f37c43e4a83a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad45c4fbcac4e778891b8f37c43e4a83a">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::uint8_t reason, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad45c4fbcac4e778891b8f37c43e4a83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ad45c4fbcac4e778891b8f37c43e4a83a">More...</a><br /></td></tr>
<tr class="separator:ad45c4fbcac4e778891b8f37c43e4a83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af258ed238979e581ed0c19bc5a29634c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af258ed238979e581ed0c19bc5a29634c">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:af258ed238979e581ed0c19bc5a29634c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#af258ed238979e581ed0c19bc5a29634c">More...</a><br /></td></tr>
<tr class="separator:af258ed238979e581ed0c19bc5a29634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc952a170fb55a8f9779249e76d359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a47fc952a170fb55a8f9779249e76d359">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt; reason, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a47fc952a170fb55a8f9779249e76d359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a47fc952a170fb55a8f9779249e76d359">More...</a><br /></td></tr>
<tr class="separator:a47fc952a170fb55a8f9779249e76d359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c209df9b4c9dc768ffd0de55404fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a03c209df9b4c9dc768ffd0de55404fdd">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a03c209df9b4c9dc768ffd0de55404fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a03c209df9b4c9dc768ffd0de55404fdd">More...</a><br /></td></tr>
<tr class="separator:a03c209df9b4c9dc768ffd0de55404fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c959d8dc991e06a34de5322683dd29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac1c959d8dc991e06a34de5322683dd29">async_suback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac1c959d8dc991e06a34de5322683dd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ac1c959d8dc991e06a34de5322683dd29">More...</a><br /></td></tr>
<tr class="separator:ac1c959d8dc991e06a34de5322683dd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac816e82bd47d5ab7f91cf527632aaaa0"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ac816e82bd47d5ab7f91cf527632aaaa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ac816e82bd47d5ab7f91cf527632aaaa0">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac816e82bd47d5ab7f91cf527632aaaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ac816e82bd47d5ab7f91cf527632aaaa0">More...</a><br /></td></tr>
<tr class="separator:ac816e82bd47d5ab7f91cf527632aaaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4cdff525b15c7c4dd91569612f5721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afd4cdff525b15c7c4dd91569612f5721">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:afd4cdff525b15c7c4dd91569612f5721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#afd4cdff525b15c7c4dd91569612f5721">More...</a><br /></td></tr>
<tr class="separator:afd4cdff525b15c7c4dd91569612f5721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6593d6b03e91d1e166931657d7dd5bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6593d6b03e91d1e166931657d7dd5bed">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> reason, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6593d6b03e91d1e166931657d7dd5bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a6593d6b03e91d1e166931657d7dd5bed">More...</a><br /></td></tr>
<tr class="separator:a6593d6b03e91d1e166931657d7dd5bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d2f5a7c77ab6dac1ef8b1aa48b136e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#af7d2f5a7c77ab6dac1ef8b1aa48b136e">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:af7d2f5a7c77ab6dac1ef8b1aa48b136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#af7d2f5a7c77ab6dac1ef8b1aa48b136e">More...</a><br /></td></tr>
<tr class="separator:af7d2f5a7c77ab6dac1ef8b1aa48b136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c80e8174aed6daf2faec7190fe42ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab7c80e8174aed6daf2faec7190fe42ab">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt; reasons, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt; props, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab7c80e8174aed6daf2faec7190fe42ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#ab7c80e8174aed6daf2faec7190fe42ab">More...</a><br /></td></tr>
<tr class="separator:ab7c80e8174aed6daf2faec7190fe42ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713d5ece6d7047865a3dcfa64c1c33ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a713d5ece6d7047865a3dcfa64c1c33ab">async_unsuback</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id, <a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> func=<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>())</td></tr>
<tr class="memdesc:a713d5ece6d7047865a3dcfa64c1c33ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send ununsuback packet. This function is for broker.  <a href="classMQTT__NS_1_1endpoint.html#a713d5ece6d7047865a3dcfa64c1c33ab">More...</a><br /></td></tr>
<tr class="separator:a713d5ece6d7047865a3dcfa64c1c33ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5859b47639e05d71bc5727c90747a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#acc5859b47639e05d71bc5727c90747a6">clear_stored_publish</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:acc5859b47639e05d71bc5727c90747a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stored publish message that has packet_id.  <a href="classMQTT__NS_1_1endpoint.html#acc5859b47639e05d71bc5727c90747a6">More...</a><br /></td></tr>
<tr class="separator:acc5859b47639e05d71bc5727c90747a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad0b9951be47e922c919275e08dc1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3cad0b9951be47e922c919275e08dc1a">for_each_store</a> (std::function&lt; void(char const *, std::size_t)&gt; const &amp;f)</td></tr>
<tr class="memdesc:a3cad0b9951be47e922c919275e08dc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="classMQTT__NS_1_1endpoint.html#a3cad0b9951be47e922c919275e08dc1a">More...</a><br /></td></tr>
<tr class="separator:a3cad0b9951be47e922c919275e08dc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9fd234cad358e130b5b11ae5d1d9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a2e9fd234cad358e130b5b11ae5d1d9af">for_each_store</a> (std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#aee95f40e601e192225456ccf0e325714">message_variant</a> const &amp;)&gt; const &amp;f)</td></tr>
<tr class="memdesc:a2e9fd234cad358e130b5b11ae5d1d9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="classMQTT__NS_1_1endpoint.html#a2e9fd234cad358e130b5b11ae5d1d9af">More...</a><br /></td></tr>
<tr class="separator:a2e9fd234cad358e130b5b11ae5d1d9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa3f4cdeb5c5ad02c0d7af643b5f47343">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structMQTT__NS_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="classMQTT__NS_1_1endpoint.html#aa3f4cdeb5c5ad02c0d7af643b5f47343">More...</a><br /></td></tr>
<tr class="separator:aa3f4cdeb5c5ad02c0d7af643b5f47343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36d39d8679fe97e5a68c4163f483d27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ad36d39d8679fe97e5a68c4163f483d27">register_packet_id</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:ad36d39d8679fe97e5a68c4163f483d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="classMQTT__NS_1_1endpoint.html#ad36d39d8679fe97e5a68c4163f483d27">More...</a><br /></td></tr>
<tr class="separator:ad36d39d8679fe97e5a68c4163f483d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e96478a968d9fa3880f67324b97e4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aa9e96478a968d9fa3880f67324b97e4f">release_packet_id</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:aa9e96478a968d9fa3880f67324b97e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packet_id.  <a href="classMQTT__NS_1_1endpoint.html#aa9e96478a968d9fa3880f67324b97e4f">More...</a><br /></td></tr>
<tr class="separator:aa9e96478a968d9fa3880f67324b97e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae13e48d68ebfd2376e3dd55e5296958"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aae13e48d68ebfd2376e3dd55e5296958"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958">restore_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>, Iterator b, Iterator e)</td></tr>
<tr class="memdesc:aae13e48d68ebfd2376e3dd55e5296958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958">More...</a><br /></td></tr>
<tr class="separator:aae13e48d68ebfd2376e3dd55e5296958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fea72e63e79eda1775b8ea2344128c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a8fea72e63e79eda1775b8ea2344128c1">restore_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper)</td></tr>
<tr class="memdesc:a8fea72e63e79eda1775b8ea2344128c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#a8fea72e63e79eda1775b8ea2344128c1">More...</a><br /></td></tr>
<tr class="separator:a8fea72e63e79eda1775b8ea2344128c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad7ad5bce13798f90e60282126f83a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a6ad7ad5bce13798f90e60282126f83a1">restore_serialized_message</a> (<a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg)</td></tr>
<tr class="memdesc:a6ad7ad5bce13798f90e60282126f83a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function should be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#a6ad7ad5bce13798f90e60282126f83a1">More...</a><br /></td></tr>
<tr class="separator:a6ad7ad5bce13798f90e60282126f83a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300f8b2656bfda0c4d96a706614820f0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a300f8b2656bfda0c4d96a706614820f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a300f8b2656bfda0c4d96a706614820f0">restore_v5_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>, Iterator b, Iterator e)</td></tr>
<tr class="memdesc:a300f8b2656bfda0c4d96a706614820f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#a300f8b2656bfda0c4d96a706614820f0">More...</a><br /></td></tr>
<tr class="separator:a300f8b2656bfda0c4d96a706614820f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf225237f7026f58cca3bb1abccce72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3bf225237f7026f58cca3bb1abccce72">restore_v5_serialized_message</a> (<a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper)</td></tr>
<tr class="memdesc:a3bf225237f7026f58cca3bb1abccce72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#a3bf225237f7026f58cca3bb1abccce72">More...</a><br /></td></tr>
<tr class="separator:a3bf225237f7026f58cca3bb1abccce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f3798fc0aa5eff3126ce884f29b575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a99f3798fc0aa5eff3126ce884f29b575">restore_v5_serialized_message</a> (<a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg, any life_keeper)</td></tr>
<tr class="memdesc:a99f3798fc0aa5eff3126ce884f29b575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function shouold be called before connect.  <a href="classMQTT__NS_1_1endpoint.html#a99f3798fc0aa5eff3126ce884f29b575">More...</a><br /></td></tr>
<tr class="separator:a99f3798fc0aa5eff3126ce884f29b575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0e603f71edda56ae521b30915fd30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a34b0e603f71edda56ae521b30915fd30">connected</a> () const</td></tr>
<tr class="memdesc:a34b0e603f71edda56ae521b30915fd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check connection status.  <a href="classMQTT__NS_1_1endpoint.html#a34b0e603f71edda56ae521b30915fd30">More...</a><br /></td></tr>
<tr class="separator:a34b0e603f71edda56ae521b30915fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a873f5a741b43e9356a07f9d2251a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ab4a873f5a741b43e9356a07f9d2251a3">async_read_next_message</a> (any session_life_keeper)</td></tr>
<tr class="memdesc:ab4a873f5a741b43e9356a07f9d2251a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);.  <a href="classMQTT__NS_1_1endpoint.html#ab4a873f5a741b43e9356a07f9d2251a3">More...</a><br /></td></tr>
<tr class="separator:ab4a873f5a741b43e9356a07f9d2251a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e234aade0059fc4fec26a2eeb50123b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a3e234aade0059fc4fec26a2eeb50123b">set_max_queue_send_count</a> (std::size_t count)</td></tr>
<tr class="memdesc:a3e234aade0059fc4fec26a2eeb50123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1.  <a href="classMQTT__NS_1_1endpoint.html#a3e234aade0059fc4fec26a2eeb50123b">More...</a><br /></td></tr>
<tr class="separator:a3e234aade0059fc4fec26a2eeb50123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64befa073dd4949ec5554f25dafa52c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a64befa073dd4949ec5554f25dafa52c2">set_max_queue_send_size</a> (std::size_t <a class="el" href="namespaceMQTT__NS.html#aa277277e254987fcfa134e38ec17aca4">size</a>)</td></tr>
<tr class="memdesc:a64befa073dd4949ec5554f25dafa52c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0.  <a href="classMQTT__NS_1_1endpoint.html#a64befa073dd4949ec5554f25dafa52c2">More...</a><br /></td></tr>
<tr class="separator:a64befa073dd4949ec5554f25dafa52c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0700fc3a40284d20867e0b19eb16165b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a0700fc3a40284d20867e0b19eb16165b">get_protocol_version</a> () const</td></tr>
<tr class="separator:a0700fc3a40284d20867e0b19eb16165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873a631af560eac356e15cd9355aba75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a873a631af560eac356e15cd9355aba75">socket</a> () const</td></tr>
<tr class="separator:a873a631af560eac356e15cd9355aba75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6012673eaa3dae1f6e69eaed4a3bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a75e6012673eaa3dae1f6e69eaed4a3bd">socket</a> ()</td></tr>
<tr class="separator:a75e6012673eaa3dae1f6e69eaed4a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a54bc27d0819fe7ab29688270916e0d9a"><td class="memItemLeft" align="right" valign="top">optional&lt; <a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a54bc27d0819fe7ab29688270916e0d9a">socket_optional</a> ()</td></tr>
<tr class="memdesc:a54bc27d0819fe7ab29688270916e0d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> of socket.  <a href="classMQTT__NS_1_1endpoint.html#a54bc27d0819fe7ab29688270916e0d9a">More...</a><br /></td></tr>
<tr class="separator:a54bc27d0819fe7ab29688270916e0d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba0a39184031abbbff36356edc30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#ae7dba0a39184031abbbff36356edc30f">async_read_control_packet_type</a> (any session_life_keeper)</td></tr>
<tr class="separator:ae7dba0a39184031abbbff36356edc30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7362548bb8b50db36976565e66c403"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9e7362548bb8b50db36976565e66c403">handle_close_or_error</a> (boost::system::error_code const &amp;ec)</td></tr>
<tr class="separator:a9e7362548bb8b50db36976565e66c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7651aee058c15cebc0b1c8b223e213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#adf7651aee058c15cebc0b1c8b223e213">set_connect</a> ()</td></tr>
<tr class="separator:adf7651aee058c15cebc0b1c8b223e213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa09a5e39fb49c656de0f9cb5fe3221e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#afa09a5e39fb49c656de0f9cb5fe3221e">set_protocol_version</a> (std::size_t version)</td></tr>
<tr class="separator:afa09a5e39fb49c656de0f9cb5fe3221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b75689b52ab8e1c524d03f261e91e4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a4b75689b52ab8e1c524d03f261e91e4a">~endpoint</a> ()=default</td></tr>
<tr class="separator:a4b75689b52ab8e1c524d03f261e91e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a13d162f21986858ca4175b47682fdd02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMQTT__NS_1_1endpoint.html#a13d162f21986858ca4175b47682fdd02">clean_session_</a> {false}</td></tr>
<tr class="separator:a13d162f21986858ca4175b47682fdd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aec238d7bd6b44c945cf78431ca0fee35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec238d7bd6b44c945cf78431ca0fee35">&#9670;&nbsp;</a></span>async_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9525c3f23b3eb6818ad591f88eb8ecc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525c3f23b3eb6818ad591f88eb8ecc3">&#9670;&nbsp;</a></span>packet_id_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> =  typename <a class="el" href="structMQTT__NS_1_1packet__id__type.html">packet_id_type</a>&lt;PacketIdBytes&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a781fc9ff61a4cd609a24297096e9454e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781fc9ff61a4cd609a24297096e9454e">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async_send_store</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for client. </p>

</div>
</div>
<a id="aed2fc00e63f634010b15a866c1c4b8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2fc00e63f634010b15a866c1c4b8b3">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Socket &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Socket &gt;&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async_send_store</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for server. socket should have already been connected with another endpoint. </p>

</div>
</div>
<a id="a91cb31e631081e8aa9885498b00902e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb31e631081e8aa9885498b00902e8">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef4b283fc6b3a22f6302851c8ada488a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4b283fc6b3a22f6302851c8ada488a">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b75689b52ab8e1c524d03f261e91e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b75689b52ab8e1c524d03f261e91e4a">&#9670;&nbsp;</a></span>~endpoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::~<a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3f4cdeb5c5ad02c0d7af643b5f47343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f4cdeb5c5ad02c0d7af643b5f47343">&#9670;&nbsp;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structMQTT__NS_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>packet id </dd></dl>

</div>
</div>
<a id="a73ef23ac11df694b34d9b04a8524dc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ef23ac11df694b34d9b04a8524dc53">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ed43d4ad6ada34a118d28e8931a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ed43d4ad6ada34a118d28e8931a1a5">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3357464f4863ddd0e745e0bfbda9a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3357464f4863ddd0e745e0bfbda9a6f1">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b1823978f45630e5aa486dc3b8d260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b1823978f45630e5aa486dc3b8d260">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a7cbb430d750096605dc04707980a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7cbb430d750096605dc04707980a70">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56eb2583bb040f099cf4d14ea249609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eb2583bb040f099cf4d14ea249609c">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359fc0c818fcec7ee41bf915d194658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fc0c818fcec7ee41bf915d194658c">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf7548a09706be1ad7240ab2d90d07a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7548a09706be1ad7240ab2d90d07a0">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f879fc9e1cd122e9fa531acace9ef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f879fc9e1cd122e9fa531acace9ef14">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb1c35f60b2a338d6b9cae75b014acc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1c35f60b2a338d6b9cae75b014acc8">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf258cc62729fe6d47dfa9654419fbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf258cc62729fe6d47dfa9654419fbd0">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe0e947db191ff3d6874173ed2c89e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0e947db191ff3d6874173ed2c89e57">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ddddee04d4cc6ed05ea842655c656f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddddee04d4cc6ed05ea842655c656f3">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21028b1ce65f6fb13e5150e3325a44d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21028b1ce65f6fb13e5150e3325a44d4">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7da3ca961c3af241cb9573b123a8277a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da3ca961c3af241cb9573b123a8277a">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62ebe10a9f4bf03e7ec076960274fc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ebe10a9f4bf03e7ec076960274fc70">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba253ed5db5179a59933384db666cf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba253ed5db5179a59933384db666cf4c">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br  />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4f03cc36f06c884713eec5036a63b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4f03cc36f06c884713eec5036a63b0">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad839a27fbbb20f45d614ccffe8311806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad839a27fbbb20f45d614ccffe8311806">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d4a06056687f3af18d027ca9c6f4a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4a06056687f3af18d027ca9c6f4a36">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abae2ee2b95dbdbebb05f325ba3f970e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae2ee2b95dbdbebb05f325ba3f970e2">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e3061ede81b46726eb8eb2a702a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3061ede81b46726eb8eb2a702a08e">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0b5ffd1694ee404281b008ff587a946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b5ffd1694ee404281b008ff587a946">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d64408fec544e992df6e79e9cd862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d64408fec544e992df6e79e9cd862b">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa88c5ea4e72db8a58e7eef58bf21053c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88c5ea4e72db8a58e7eef58bf21053c">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a82ac34326f3c6c962274ae6a30b191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a82ac34326f3c6c962274ae6a30b191">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8305d69c57f24cad925989fa6f361da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8305d69c57f24cad925989fa6f361da7">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473a48bece400dead5646db0b3b6c820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473a48bece400dead5646db0b3b6c820">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab953eacbfd1c2f9c665a177ffe8f7f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab953eacbfd1c2f9c665a177ffe8f7f61">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a844dfd6e0277b314ed482832ea854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a844dfd6e0277b314ed482832ea854">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596171fe276f12b47c6b7497db75665b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596171fe276f12b47c6b7497db75665b">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dd7d3135e6cf1583bb5c37064bdab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd7d3135e6cf1583bb5c37064bdab3d">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a178f4f15311dd4394051eeed07a2b2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178f4f15311dd4394051eeed07a2b2a4">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5aed79ebad9c4cdd94e9710bc5a8d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aed79ebad9c4cdd94e9710bc5a8d25">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7df7e2e1db7aecbebf3f54991a57969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df7e2e1db7aecbebf3f54991a57969f">&#9670;&nbsp;</a></span>acquired_publish() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad289bdf9805ba05637b138b5e91f24fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad289bdf9805ba05637b138b5e91f24fa">&#9670;&nbsp;</a></span>acquired_publish() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31cfd0ce2fa333134b3182be622af6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cfd0ce2fa333134b3182be622af6df">&#9670;&nbsp;</a></span>acquired_publish() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ade0676120bbea2100e69b6d3327523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade0676120bbea2100e69b6d3327523">&#9670;&nbsp;</a></span>acquired_publish_dup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66e0ed59c3c4f7b7b0f74097eedcb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66e0ed59c3c4f7b7b0f74097eedcb31">&#9670;&nbsp;</a></span>acquired_publish_dup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a847ee6638de13b8794d6e596808086ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847ee6638de13b8794d6e596808086ed">&#9670;&nbsp;</a></span>acquired_publish_dup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0995ecad9929c4b0388346c6bf3542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0995ecad9929c4b0388346c6bf3542">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf0f04803a7cf068a9d1261ab857cf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0f04803a7cf068a9d1261ab857cf8a">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d8b110d1f29af716b23f563d00891c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8b110d1f29af716b23f563d00891c0">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63960f9587f77b83aa8efa39abe1666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63960f9587f77b83aa8efa39abe1666b">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf3a9faeabd90dfaf966be2522e8e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3a9faeabd90dfaf966be2522e8e5e7">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18944108881f9226283b1185869dea8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18944108881f9226283b1185869dea8d">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91898d5cc7835cb8ba82ffd5b6234835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91898d5cc7835cb8ba82ffd5b6234835">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6563414ff3aa2192e9a76e65bf392cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6563414ff3aa2192e9a76e65bf392cc0">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a313bdeceba8412452293ffd0414ceddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313bdeceba8412452293ffd0414ceddb">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1016657bfc6a1c865b2d6763da0be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1016657bfc6a1c865b2d6763da0be0">&#9670;&nbsp;</a></span>async_auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br  />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br  />
 3.15.2.2 AUTH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa98965931dec1a70439ce28ce7d5e663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98965931dec1a70439ce28ce7d5e663">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f249cf6feb9edf3bfc091660c8cfba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f249cf6feb9edf3bfc091660c8cfba6">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br  />
 3.2.2.3 CONNACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6534dcc5312f30e3eead2a43ff6d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6534dcc5312f30e3eead2a43ff6d57">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad88fa1e8b093c2f762247b02cca0e1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88fa1e8b093c2f762247b02cca0e1cd">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57cdf8e4232b18f8cfecfd000b10a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cdf8e4232b18f8cfecfd000b10a65f">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20dfa3d9410b87644779e04d2d174cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dfa3d9410b87644779e04d2d174cc7">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>DISCONNECT Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br  />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br  />
 3.14.2.2 DISCONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5c3eef41e425e4037644aacaf746feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c3eef41e425e4037644aacaf746feb">&#9670;&nbsp;</a></span>async_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pingreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fbd466b45a2b9e6b21ede007578cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fbd466b45a2b9e6b21ede007578cb6">&#9670;&nbsp;</a></span>async_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pingresp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e99d2211df33c12c769f050f6013938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e99d2211df33c12c769f050f6013938">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3bf27d98bad7de18a6954b7263fbca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bf27d98bad7de18a6954b7263fbca1">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br  />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br  />
 3.4.2.2 PUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0bd78e74d65fa1d8845d2c5679b4c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bd78e74d65fa1d8845d2c5679b4c0a">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b2f1a5ec413438d8300a7be903a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b2f1a5ec413438d8300a7be903a3f9">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br  />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br  />
 3.7.2.2 PUBCOMP Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab61da081ba24c06e7d87f7d4223fd551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61da081ba24c06e7d87f7d4223fd551">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aa5e58c4735a178c8ffcd9ada6728d769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e58c4735a178c8ffcd9ada6728d769">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aeb820cbc29d0ff95d829211168a0daeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb820cbc29d0ff95d829211168a0daeb">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a28a1073a6dcde58dce4cdc417b0e24a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a1073a6dcde58dce4cdc417b0e24a3">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="adf6e920fa6264dee8ad0b4e726f05b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6e920fa6264dee8ad0b4e726f05b59">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a94ee5540fa49bf593d2fd39da7b07e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ee5540fa49bf593d2fd39da7b07e58">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a9e7e7448d43c5dcbc66821f71a80755c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7e7448d43c5dcbc66821f71a80755c">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a8b1d3424110fbf9ded73ffd12c760aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1d3424110fbf9ded73ffd12c760aec">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a712ae086e842e858783b628f2a36d80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ae086e842e858783b628f2a36d80e">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a189203d0cc2004af3617d188ff6c65b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189203d0cc2004af3617d188ff6c65b2">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a9f36d1b28ce5cf65036d38d5f901e006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f36d1b28ce5cf65036d38d5f901e006">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="ac1b0a463ff07ce6a4caf924be5abdb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b0a463ff07ce6a4caf924be5abdb1b">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a62bf6e807c226213865c64483ce4b204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bf6e807c226213865c64483ce4b204">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="abb3a90b45da1e49bc33b0b5b4ebe49de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3a90b45da1e49bc33b0b5b4ebe49de">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a13fd93af51944c7e187211bdfb86f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fd93af51944c7e187211bdfb86f4d7">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a5329435a0ced477f6a7a8cdf26bbbae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5329435a0ced477f6a7a8cdf26bbbae8">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ac353626f8ba94c0475d414a35f04bdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac353626f8ba94c0475d414a35f04bdcc">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a389f04d24345d7f352d0611a1633b2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389f04d24345d7f352d0611a1633b2c8">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a13ad2ca1b11081d1304b06a18f32a70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad2ca1b11081d1304b06a18f32a70d">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b9f54bc30f2eb0d612c2e8b48f8a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b9f54bc30f2eb0d612c2e8b48f8a64">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br  />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br  />
 3.5.2.2 PUBREC Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c7bf27ddc348695abd318af7dee7e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7bf27ddc348695abd318af7dee7e90">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8060887a13996e577911b4903625998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8060887a13996e577911b4903625998">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>any()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br  />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br  />
 3.6.2.2 PUBREL Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7dba0a39184031abbbff36356edc30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dba0a39184031abbbff36356edc30f">&#9670;&nbsp;</a></span>async_read_control_packet_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_read_control_packet_type </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a873f5a741b43e9356a07f9d2251a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a873f5a741b43e9356a07f9d2251a3">&#9670;&nbsp;</a></span>async_read_next_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_read_next_message </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);. </p>

</div>
</div>
<a id="ad45c4fbcac4e778891b8f37c43e4a83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45c4fbcac4e778891b8f37c43e4a83a">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code The format of args is <code>[option, option, ...,][props,][func]</code><br  />
 You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties You can set a callback function that is called when async operation will finish. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03c209df9b4c9dc768ffd0de55404fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c209df9b4c9dc768ffd0de55404fdd">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c959d8dc991e06a34de5322683dd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c959d8dc991e06a34de5322683dd29">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af258ed238979e581ed0c19bc5a29634c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af258ed238979e581ed0c19bc5a29634c">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47fc952a170fb55a8f9779249e76d359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fc952a170fb55a8f9779249e76d359">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b63915d83ccc78bc4a76760c8b4d6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63915d83ccc78bc4a76760c8b4d6dd">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a7b7c0bf81baf46c6428c7d548baacbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7c0bf81baf46c6428c7d548baacbb7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a7cfd70462588939a7bde40465ce60340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfd70462588939a7bde40465ce60340">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a2436dfd11052741134a96967f584c0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2436dfd11052741134a96967f584c0ed">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="afa0a3be599a8bfc5fd8a5ba3c54e5c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a3be599a8bfc5fd8a5ba3c54e5c1e">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ac491d642720bb87b9bf53140db5024db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac491d642720bb87b9bf53140db5024db">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="addb79dd4b4d3b29759b3ee99d98d849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb79dd4b4d3b29759b3ee99d98d849b">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="af1ed0485ed8f9e68d8760145d4ad78a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ed0485ed8f9e68d8760145d4ad78a8">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a20eb5f791cccc6318e1613e6f7a11694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eb5f791cccc6318e1613e6f7a11694">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a4a6a38b8613f865d3fa4b18305f4c2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6a38b8613f865d3fa4b18305f4c2b5">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ae6493fa980bbba11e02d8dc3be3a5223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6493fa980bbba11e02d8dc3be3a5223">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a84ee91fe4aff95c26c7a26bd8af99bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ee91fe4aff95c26c7a26bd8af99bd4">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="aa0bec7baf1b82ecb16ed7a40a79d3a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bec7baf1b82ecb16ed7a40a79d3a63">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ab089e713cfd4f41276fd0ab4406fd6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab089e713cfd4f41276fd0ab4406fd6a8">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a3625a930e75c8d9ec9f15d18bf9746b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3625a930e75c8d9ec9f15d18bf9746b7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="abc7bc59adb4d4b03211363a9b69ecf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7bc59adb4d4b03211363a9b69ecf6c">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a4f98cefc5ed8175f7ea7b646f7383864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f98cefc5ed8175f7ea7b646f7383864">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a84fbb2f15448986e9620d2414479256f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fbb2f15448986e9620d2414479256f">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a6fe84c3665de1331e951633d2e050a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe84c3665de1331e951633d2e050a1d">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="acf63685e811cb152888d38456b1092f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf63685e811cb152888d38456b1092f2">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a4391186a1b5d1a62482f61b79286a2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4391186a1b5d1a62482f61b79286a2f7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a64357ed1f9b839233e391155879c6e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64357ed1f9b839233e391155879c6e37">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a15f0d5e6333f0a4ed2b236d447dba7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f0d5e6333f0a4ed2b236d447dba7ad">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a5f3dd152b7a4a53919bcf5a6bf1ccea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3dd152b7a4a53919bcf5a6bf1ccea8">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a713d5ece6d7047865a3dcfa64c1c33ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713d5ece6d7047865a3dcfa64c1c33ab">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send ununsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d2f5a7c77ab6dac1ef8b1aa48b136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d2f5a7c77ab6dac1ef8b1aa48b136e">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c80e8174aed6daf2faec7190fe42ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c80e8174aed6daf2faec7190fe42ab">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac816e82bd47d5ab7f91cf527632aaaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac816e82bd47d5ab7f91cf527632aaaa0">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[option, option, ...,][props,][func]</code><br  />
 You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties You can set a callback function that is called when async operation will finish. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd4cdff525b15c7c4dd91569612f5721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4cdff525b15c7c4dd91569612f5721">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6593d6b03e91d1e166931657d7dd5bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6593d6b03e91d1e166931657d7dd5bed">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a54839fd71bcc487a122c036b874ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a54839fd71bcc487a122c036b874ee">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ac9ef23df3587b52745fd4a6081e36c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ef23df3587b52745fd4a6081e36c9b">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a8d689cc3b1502dd55c8273580e6a2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d689cc3b1502dd55c8273580e6a2cb8">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a88e54190b724a9b99e8e7b46325a369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e54190b724a9b99e8e7b46325a369c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ac99c36b12ec0784f686beafda8d55876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99c36b12ec0784f686beafda8d55876">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ace82fa1f346a54cc4caca780e0a52d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace82fa1f346a54cc4caca780e0a52d1f">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ae0f4bcd2b5ef915f6fcb974024a34696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f4bcd2b5ef915f6fcb974024a34696">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic names to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="afbc0248ba5c3d3781fa36d8e7e91463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc0248ba5c3d3781fa36d8e7e91463a">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aa49d7a16a11bab22f44f5b718c84a165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49d7a16a11bab22f44f5b718c84a165">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic names to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a84566141b51eea853b92bb1bd8458c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84566141b51eea853b92bb1bd8458c66">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a86f17c0be7f863494611aaaa4039a1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f17c0be7f863494611aaaa4039a1de">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a645cad51dd6f6919aa3b86086b1abdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645cad51dd6f6919aa3b86086b1abdb0">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic names to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a876353d33c80f75ec9847c3fb23748ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876353d33c80f75ec9847c3fb23748ca">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a1b5abac88b6abb79a880449bfe552a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5abac88b6abb79a880449bfe552a17">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a4f0dce5f45082e7d61caa5dc48e0ca81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0dce5f45082e7d61caa5dc48e0ca81">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aa288246823d76a7dd5cba01e81951e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa288246823d76a7dd5cba01e81951e0c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a29b5b9c7457995b7465e9d7a5d5bbc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b5b9c7457995b7465e9d7a5d5bbc5a">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a3bde0eda9224c321bced015f99da002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde0eda9224c321bced015f99da002e">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a9e7d190868f60cbd19bfdcf8f086209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7d190868f60cbd19bfdcf8f086209a">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aebe89a4f70da29fd01bc92b28b102d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe89a4f70da29fd01bc92b28b102d62">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classMQTT__NS_1_1endpoint.html#aec238d7bd6b44c945cf78431ca0fee35">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aa266ca1e346ed7e2a72d84357328bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa266ca1e346ed7e2a72d84357328bda6">&#9670;&nbsp;</a></span>auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::auth_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br  />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br  />
 3.15.2.2 AUTH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd767b5cccac13a838637bfe8f254333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd767b5cccac13a838637bfe8f254333">&#9670;&nbsp;</a></span>check_is_valid_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::check_is_valid_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a4ff14039c2291ee42436507a29776543">control_packet_type</a>&#160;</td>
          <td class="paramname"><em>packet_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>remaining_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is valid length handler This handler is called when remaining length is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control_packet_type</td><td>control_packet_type that has variable length </td></tr>
    <tr><td class="paramname">remaining</td><td>length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if check is success, otherwise false </dd></dl>

</div>
</div>
<a id="a83b22497e0a2b8adfd9012f4fc3a25bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b22497e0a2b8adfd9012f4fc3a25bf">&#9670;&nbsp;</a></span>clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean session. </p>
<p>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231</a><br  />
 3.1.2.4 Clean Session<br  />
 After constructing a endpoint, the clean session is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean session </dd></dl>

</div>
</div>
<a id="aeced2510df92ce5eb5c0276a6445fb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeced2510df92ce5eb5c0276a6445fb49">&#9670;&nbsp;</a></span>clean_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean start. </p>
<p>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 After constructing a endpoint, the clean start is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean start </dd></dl>

</div>
</div>
<a id="acc5859b47639e05d71bc5727c90747a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5859b47639e05d71bc5727c90747a6">&#9670;&nbsp;</a></span>clear_stored_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clear_stored_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stored publish message that has packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to stored publish </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9a2e7b925b20d9b6a5bf6123974edec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a2e7b925b20d9b6a5bf6123974edec">&#9670;&nbsp;</a></span>connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">reason_code</td><td>See <a class="el" href="reason__code_8hpp.html">reason_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br  />
 3.2.2.3 CONNACK Properties See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19587e80ca96360bc7e43345c1c04fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19587e80ca96360bc7e43345c1c04fde">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">clean_session</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238</a> See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b0142b488912ddb5bb889d01b5c3e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0142b488912ddb5bb889d01b5c3e6e">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br  />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">clean_session</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Start<br  />
 </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238</a> See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b0e603f71edda56ae521b30915fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b0e603f71edda56ae521b30915fd30">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>current connection status </dd></dl>

</div>
</div>
<a id="a8d4693c2e48ae0283e29db15294f2cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4693c2e48ae0283e29db15294f2cee">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442a31fe45844c214ec5ad8d824be3709a8d">v5::disconnect_reason_code::normal_disconnection</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>DISCONNECT Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br  />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br  />
 3.14.2.2 DISCONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cad0b9951be47e922c919275e08dc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cad0b9951be47e922c919275e08dc1a">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *, std::size_t)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(char const*, std::size_t) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e9fd234cad358e130b5b11ae5d1d9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9fd234cad358e130b5b11ae5d1d9af">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespaceMQTT__NS.html#aee95f40e601e192225456ccf0e325714">message_variant</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(message_variant const&amp;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340f9768dfcb465f5a368244d27d8dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340f9768dfcb465f5a368244d27d8dac">&#9670;&nbsp;</a></span>force_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::force_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br  />
 When the endpoint disconnects using <a class="el" href="classMQTT__NS_1_1endpoint.html#a340f9768dfcb465f5a368244d27d8dac" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br  />
 </p>

</div>
</div>
<a id="a0700fc3a40284d20867e0b19eb16165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0700fc3a40284d20867e0b19eb16165b">&#9670;&nbsp;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#abe4c9bdc61287be90f38e66c65bf7685">protocol_version</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e7362548bb8b50db36976565e66c403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7362548bb8b50db36976565e66c403">&#9670;&nbsp;</a></span>handle_close_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::handle_close_or_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a278772fe2cd0cd67975c77b187f8b987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278772fe2cd0cd67975c77b187f8b987">&#9670;&nbsp;</a></span>on_close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close handler. </p>
<p>This handler is called if the client called <code><a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> and the server closed the socket cleanly. If the socket is closed by other reasons, error_handler is called. </p>

</div>
</div>
<a id="aba262462dcf91c1c5ca5a3f191d23a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba262462dcf91c1c5ca5a3f191d23a90">&#9670;&nbsp;</a></span>on_connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a85cb6d4fd28210ba8b3b83b677660a5e">connect_return_code</a>&#160;</td>
          <td class="paramname"><em>return_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br  />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718036">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718036</a><br  />
 3.2.2.2 Session Present </td></tr>
    <tr><td class="paramname">return_code</td><td>connect_return_code<br  />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718036">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718036</a><br  />
 3.2.2.3 Connect Return code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="aa106bef609e666832b3696fe47dfce91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa106bef609e666832b3696fe47dfce91">&#9670;&nbsp;</a></span>on_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>will</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clean_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client Identifier.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245</a><br  />
 3.1.3.1 Client Identifier </td></tr>
    <tr><td class="paramname">user_name</td><td>User Name.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245</a><br  />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349246">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349246</a><br  />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, topic, and message.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349232">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349232</a><br  />
 3.1.2.5 Will Flag<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349233">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349233</a><br  />
 3.1.2.6 Will QoS<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349234">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349234</a><br  />
 3.1.2.7 Will Retain<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349243">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349243</a><br  />
 3.1.3.2 Will Topic<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349244">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349244</a><br  />
 3.1.3.3 Will Message<br  />
 </td></tr>
    <tr><td class="paramname">clean_session</td><td>Clean Session<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349231">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349231</a><br  />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349237">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349237</a><br  />
 3.1.2.10 Keep Alive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a443660c7ad51013f2f220b54aff67c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443660c7ad51013f2f220b54aff67c36">&#9670;&nbsp;</a></span>on_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463</a><br  />
 3.14 DISCONNECT – Disconnect notification. </p>

</div>
</div>
<a id="af423f4675966c8c68e83b49a51cb88fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af423f4675966c8c68e83b49a51cb88fc">&#9670;&nbsp;</a></span>on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error handler. </p>
<p>This handler is called if the socket is closed without client's <code><a class="el" href="classMQTT__NS_1_1endpoint.html#a8d4693c2e48ae0283e29db15294f2cee" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7176d6ece0e157342e1f51594ca89681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7176d6ece0e157342e1f51594ca89681">&#9670;&nbsp;</a></span>on_mqtt_message_processed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="attributes_8hpp.html#a27e44ba0a30f7987ed61228826f1a1e7">MQTT_ALWAYS_INLINE</a> void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_mqtt_message_processed </td>
          <td>(</td>
          <td class="paramtype">MQTT_NS::any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>next read handler This handler is called when the current mqtt message has been processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1326c1b11e759549b8b4f5fe328e3fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1326c1b11e759549b8b4f5fe328e3fe3">&#9670;&nbsp;</a></span>on_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br  />
 3.13 PINGREQ – PING request. </p>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a8534b4853d1384b15fd192063a90c81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8534b4853d1384b15fd192063a90c81f">&#9670;&nbsp;</a></span>on_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pingresp handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a><br  />
 3.13 PINGRESP – PING response. </p>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a83147c685a0ae4f4f8f71cbde852f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83147c685a0ae4f4f8f71cbde852f1b1">&#9670;&nbsp;</a></span>on_pre_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pre_send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-send handler This handler is called when any mqtt control packet is decided to send. </p>

</div>
</div>
<a id="a1fc4663ae9cb7200570556c70194cca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4663ae9cb7200570556c70194cca7">&#9670;&nbsp;</a></span>on_pub_res_sent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pub_res_sent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901026">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901026</a><br  />
 2.2.1 Packet Identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdf4459f5e75e5da65c705e66c80b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf4459f5e75e5da65c705e66c80b470">&#9670;&nbsp;</a></span>on_puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045</a><br  />
 3.4.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a5821b61bc8b8a8278b9b62b91a289fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5821b61bc8b8a8278b9b62b91a289fd2">&#9670;&nbsp;</a></span>on_pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718060">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718060</a><br  />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a4f661662b72957334e1f63ff1bd394ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f661662b72957334e1f63ff1bd394ee">&#9670;&nbsp;</a></span>on_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_publish </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718038">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718038</a><br  />
 3.3.1 Fixed header<br  />
 You can check the fixed header using <a class="el" href="namespaceMQTT__NS_1_1publish.html">MQTT_NS::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 If received publish's QoS is 0, packet_id is MQTT_NS::nullopt.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718039</a><br  />
 3.3.2 Variable header </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">contents</td><td>Published contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a30c0e6e5c22291ee3edd8135246a1bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c0e6e5c22291ee3edd8135246a1bd7">&#9670;&nbsp;</a></span>on_pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718050">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718050</a><br  />
 3.5.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="aca19a608b0c537f3548ddb7eb20bbf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19a608b0c537f3548ddb7eb20bbf38">&#9670;&nbsp;</a></span>on_pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349791">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349791</a><br  />
 3.6.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a2fffb7166f69a9ce3a0c8d854b29073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fffb7166f69a9ce3a0c8d854b29073a">&#9670;&nbsp;</a></span>on_serialize_publish_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_serialize_publish_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d0dab0d068f90543933335fa8fe127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d0dab0d068f90543933335fa8fe127">&#9670;&nbsp;</a></span>on_serialize_pubrel_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_serialize_pubrel_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ca03480deacecbad964e354b882760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ca03480deacecbad964e354b882760">&#9670;&nbsp;</a></span>on_serialize_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_serialize_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove serialized message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the removing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4db59d14d39a6fc20c34461eac118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4db59d14d39a6fc20c34461eac118b">&#9670;&nbsp;</a></span>on_serialize_v5_publish_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_serialize_v5_publish_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>v5::publish message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac962a8e37ef6178c88fdeff03fab403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac962a8e37ef6178c88fdeff03fab403f">&#9670;&nbsp;</a></span>on_serialize_v5_pubrel_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_serialize_v5_pubrel_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; sizeof(<a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classMQTT__NS_1_1endpoint.html#aae13e48d68ebfd2376e3dd55e5296958" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee064563a7474e855933a6b6da31fc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee064563a7474e855933a6b6da31fc07">&#9670;&nbsp;</a></span>on_suback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">MQTT_NS::suback_return_code</a> &gt;&#160;</td>
          <td class="paramname"><em>returns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718070">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718070</a><br  />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">qoss</td><td>Collection of QoS that is corresponding to subscribed topic order.<br  />
 If subscription is failure, the value is MQTT_NS::nullopt.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718071</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="aca69c094379b01b41b861183c0c7fc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca69c094379b01b41b861183c0c7fc1a">&#9670;&nbsp;</a></span>on_subscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349801">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349801</a><br  />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349802">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349802</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a6499ebcd6d022d74c07fd0765adf77a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6499ebcd6d022d74c07fd0765adf77a8">&#9670;&nbsp;</a></span>on_unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045</a><br  />
 3.11.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a8c77a1bf913251bb5215be04fc5f0391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c77a1bf913251bb5215be04fc5f0391">&#9670;&nbsp;</a></span>on_unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>topics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349810">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349810</a><br  />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800448">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800448</a><br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a499d743fb32c45fe91b9491d14f9f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499d743fb32c45fe91b9491d14f9f054">&#9670;&nbsp;</a></span>on_v5_auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a1fefc84fd3f3e72d668b40382526edef">v5::auth_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auth handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217</a><br  />
 3.15 AUTH – Authentication exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br  />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br  />
 3.15.2.2 AUTH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a68da29579cd34fd24903094997a7dfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da29579cd34fd24903094997a7dfb9">&#9670;&nbsp;</a></span>on_v5_connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eb">v5::connect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901078">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901078</a><br  />
 3.2.2.1.1 Session Present </td></tr>
    <tr><td class="paramname">reason_code</td><td>Connect Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079</a><br  />
 3.2.2.2 Connect Reason code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br  />
 3.2.2.3 CONNACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a1b04b9be065dd40cc4f7138807826220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b04b9be065dd40cc4f7138807826220">&#9670;&nbsp;</a></span>on_v5_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1will.html">will</a> &gt;&#160;</td>
          <td class="paramname"><em>will</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clean_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client Identifier.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br  />
 3.1.3.1 Client Identifier </td></tr>
    <tr><td class="paramname">user_name</td><td>User Name.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br  />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br  />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, propertied, topic, and message.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901040">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901040</a><br  />
 3.1.2.5 Will Flag<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901041">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901041</a><br  />
 3.1.2.6 Will QoS<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901042">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901042</a><br  />
 3.1.2.7 Will Retain<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901060">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901060</a><br  />
 3.1.3.2 Will Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901069">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901069</a><br  />
 3.1.3.3 Will Topic<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901070">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901070</a><br  />
 3.1.3.3 Will Payload<br  />
 </td></tr>
    <tr><td class="paramname">clean_start</td><td>Clean Start<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br  />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br  />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br  />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a7d91d0afe1d3db047da39ece3a0f7f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d91d0afe1d3db047da39ece3a0f7f4b">&#9670;&nbsp;</a></span>on_v5_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#ab584e17eca6e580b7a2e556dac731442">v5::disconnect_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br  />
 3.14 DISCONNECT – Disconnect notification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>DISCONNECT Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br  />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br  />
 3.14.2.2 DISCONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a907b31c845e780a4b197128d2d8f5bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907b31c845e780a4b197128d2d8f5bf8">&#9670;&nbsp;</a></span>on_v5_puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901123">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901123</a><br  />
 3.4.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br  />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br  />
 3.4.2.2 PUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a12e0e209a2423937e59d066762bd5137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e0e209a2423937e59d066762bd5137">&#9670;&nbsp;</a></span>on_v5_pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901153">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901153</a><br  />
 3.7.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br  />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br  />
 3.7.2.2 PUBCOMP Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a0b9cc6056e76fa1847055a2cf760f9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9cc6056e76fa1847055a2cf760f9bf">&#9670;&nbsp;</a></span>on_v5_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_publish </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MQTT_NS::optional&lt; <a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> &gt;&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901101">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901101</a><br  />
 3.3.1 Fixed header<br  />
 You can check the fixed header using <a class="el" href="namespaceMQTT__NS_1_1publish.html">MQTT_NS::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 If received publish's QoS is 0, packet_id is MQTT_NS::nullopt.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901108">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901108</a><br  />
 3.3.2.2 Packet Identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901107">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901107</a><br  />
 3.3.2.1 Topic Name<br  />
 </td></tr>
    <tr><td class="paramname">contents</td><td>Publish Payload<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901119">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901119</a><br  />
 3.3.3 PUBLISH Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ac6a029a37883f25705ec2a23aa9603e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a029a37883f25705ec2a23aa9603e6">&#9670;&nbsp;</a></span>on_v5_pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901133">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901133</a><br  />
 3.5.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br  />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br  />
 3.5.2.2 PUBREC Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="aadbcee1fc640bc361b15e98c8e2de0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbcee1fc640bc361b15e98c8e2de0ec">&#9670;&nbsp;</a></span>on_v5_pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901143">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901143</a><br  />
 3.6.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br  />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br  />
 3.6.2.2 PUBREL Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a75b9c5e264aea23dc4487dc510e56349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b9c5e264aea23dc4487dc510e56349">&#9670;&nbsp;</a></span>on_v5_suback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">MQTT_NS::v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901173">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901173</a><br  />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">reasons</td><td>Collection of reason_code.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="af015fea598ef29c17cc85a9d18eb6981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af015fea598ef29c17cc85a9d18eb6981">&#9670;&nbsp;</a></span>on_v5_subscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901163">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901163</a><br  />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901168">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901168</a><br  />
 </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a442ed97d3653b2906bad0c55a152658b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442ed97d3653b2906bad0c55a152658b">&#9670;&nbsp;</a></span>on_v5_unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901189">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901189</a><br  />
 3.11.2 Variable header </td></tr>
    <tr><td class="paramname">reasons</td><td>Collection of reason_code.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a80f98095341d0f177e640f86302cf5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f98095341d0f177e640f86302cf5c5">&#9670;&nbsp;</a></span>on_v5_unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::on_v5_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">MQTT_NS::buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901181">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901181</a><br  />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901185">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901185</a><br  />
 3.10.3 UNSUBSCRIBE Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a9f4a2506a09708a2de1e5d3aa8bbf275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4a2506a09708a2de1e5d3aa8bbf275">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16684404a6edf1f58d07938b60fbaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16684404a6edf1f58d07938b60fbaf0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6073e6c1a564756c1cb350f20650b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6073e6c1a564756c1cb350f20650b95">&#9670;&nbsp;</a></span>pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>. </p>

</div>
</div>
<a id="a9163ebce3564d4bbcdb45ca6ca3718f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9163ebce3564d4bbcdb45ca6ca3718f7">&#9670;&nbsp;</a></span>pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>. </p>

</div>
</div>
<a id="afe6b9daeff3d9e36c2ce0a43bee5ef83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6b9daeff3d9e36c2ce0a43bee5ef83">&#9670;&nbsp;</a></span>puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a730587fc15912a27b530e9473c7f1d7d">v5::puback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::puback_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br  />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br  />
 3.4.2.2 PUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a7bf271b4ebdcf08aa0a7dea3072939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7bf271b4ebdcf08aa0a7dea3072939">&#9670;&nbsp;</a></span>pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9650ab67a9f6a86853ac522a2b141903">v5::pubcomp_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubcomp_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br  />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br  />
 3.7.2.2 PUBCOMP Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad86f5d4cd8119f41e64f9216199119f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86f5d4cd8119f41e64f9216199119f8">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. If qos is <a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a>, then no life_keeper required. You can pass <code>any()</code> as the life_keeper. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a2b12391d625e962bacccfb27a660109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b12391d625e962bacccfb27a660109d">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a65fcd28ad35574b126573b2c6d7db604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fcd28ad35574b126573b2c6d7db604">&#9670;&nbsp;</a></span>publish() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a3dddf70619bb2ecaee32f97464b8802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dddf70619bb2ecaee32f97464b8802a">&#9670;&nbsp;</a></span>publish() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a65e0d9835e95a4e237d55e1e1f0fcfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e0d9835e95a4e237d55e1e1f0fcfeb">&#9670;&nbsp;</a></span>publish() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a7ad1c1cf62c4e64808d7d492ef2a76b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad1c1cf62c4e64808d7d492ef2a76b9">&#9670;&nbsp;</a></span>publish() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you know ahead of time that qos will be at_most_once, then prefer publish_at_most_once() over <a class="el" href="classMQTT__NS_1_1endpoint.html#a7ad1c1cf62c4e64808d7d492ef2a76b9" title="Publish.">publish()</a> as it is slightly more efficent. </dd></dl>

</div>
</div>
<a id="aeb9a7c19a5b3ffa7ebdd95277221233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a7c19a5b3ffa7ebdd95277221233d">&#9670;&nbsp;</a></span>publish_dup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ae73b1bc3490a00acbf02e7bb14b13b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73b1bc3490a00acbf02e7bb14b13b75">&#9670;&nbsp;</a></span>publish_dup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ae44f7c5006ec9dd6021b06a954d9077f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44f7c5006ec9dd6021b06a954d9077f">&#9670;&nbsp;</a></span>publish_dup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4d">qos</a>&#160;</td>
          <td class="paramname"><em>qos_value</em> = <code><a class="el" href="namespaceMQTT__NS.html#ac1235436f66e342fcbb253a2a9297c4da9cb5367ca459f35c28917fa49ed97135">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td>qos </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br  />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br  />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br  />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a961240f654b640c7b8dd7a7cd7d6d29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961240f654b640c7b8dd7a7cd7d6d29d">&#9670;&nbsp;</a></span>pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a9373a2a0e595ab9c09ecef4399c3dc4c">v5::pubrec_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubrec_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br  />
 3.5.2.1 Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br  />
 3.5.2.2 Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f78448c72ccc7f8888ebf3e3b539e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f78448c72ccc7f8888ebf3e3b539e9">&#9670;&nbsp;</a></span>pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a68fe018a036c70e76fe9cc35e77d55ce">v5::pubrel_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code><a class="el" href="namespaceMQTT__NS_1_1v5.html#a066fed6acd7efdb61dd0196e431324eba260ca9dd8a4577fc00b7bd5810298076">v5::pubrel_reason_code::success</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em> = <code>any()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br  />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br  />
 3.6.2.2 PUBREL Properties </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the async operation is finished. </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad36d39d8679fe97e5a68c4163f483d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36d39d8679fe97e5a68c4163f483d27">&#9670;&nbsp;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully registerd then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="aa9e96478a968d9fa3880f67324b97e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e96478a968d9fa3880f67324b97e4f">&#9670;&nbsp;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id to release. only the packet_id gotten by acquire_unique_packet_id, or register_packet_id is permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully released then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a8fea72e63e79eda1775b8ea2344128c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fea72e63e79eda1775b8ea2344128c1">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v3__1__1_1_1basic__publish__message.html">basic_publish_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ad7ad5bce13798f90e60282126f83a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad7ad5bce13798f90e60282126f83a1">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v3__1__1_1_1basic__pubrel__message.html">basic_pubrel_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae13e48d68ebfd2376e3dd55e5296958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae13e48d68ebfd2376e3dd55e5296958">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;typename Iterator::value_type, char&gt;::value&gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id of the message </td></tr>
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a300f8b2656bfda0c4d96a706614820f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300f8b2656bfda0c4d96a706614820f0">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;typename Iterator::value_type, char&gt;::value&gt;::type <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id of the message </td></tr>
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bf225237f7026f58cca3bb1abccce72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf225237f7026f58cca3bb1abccce72">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99f3798fc0aa5eff3126ce884f29b575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f3798fc0aa5eff3126ce884f29b575">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with <a class="el" href="namespaceMQTT__NS.html#a668d2397a4d95f82b905b43680ceaebf">force_move()</a>) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabfd0bd245770caa1ef8e03a76aa64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfd0bd245770caa1ef8e03a76aa64f">&#9670;&nbsp;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set auto publish response mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>set value </td></tr>
    <tr><td class="paramname">async</td><td>auto publish ressponse send asynchronous</td></tr>
  </table>
  </dd>
</dl>
<p>When set auto publish response mode to true, puback, pubrec, pubrel,and pub comp automatically send.<br  />
 </p>

</div>
</div>
<a id="adf7651aee058c15cebc0b1c8b223e213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7651aee058c15cebc0b1c8b223e213">&#9670;&nbsp;</a></span>set_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e234aade0059fc4fec26a2eeb50123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e234aade0059fc4fec26a2eeb50123b">&#9670;&nbsp;</a></span>set_max_queue_send_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_count </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>maximum number of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64befa073dd4949ec5554f25dafa52c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64befa073dd4949ec5554f25dafa52c2">&#9670;&nbsp;</a></span>set_max_queue_send_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>maximum size of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab936aa635400f77eeaff109656ffbf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab936aa635400f77eeaff109656ffbf0c">&#9670;&nbsp;</a></span>set_packet_bulk_read_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_packet_bulk_read_limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71b1d2e8898e9cda6f8f4441ce663408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b1d2e8898e9cda6f8f4441ce663408">&#9670;&nbsp;</a></span>set_props_bulk_read_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_props_bulk_read_limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa09a5e39fb49c656de0f9cb5fe3221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa09a5e39fb49c656de0f9cb5fe3221e">&#9670;&nbsp;</a></span>set_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::set_protocol_version </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75e6012673eaa3dae1f6e69eaed4a3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6012673eaa3dae1f6e69eaed4a3bd">&#9670;&nbsp;</a></span>socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a>&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a873a631af560eac356e15cd9355aba75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873a631af560eac356e15cd9355aba75">&#9670;&nbsp;</a></span>socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a> const&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54bc27d0819fe7ab29688270916e0d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bc27d0819fe7ab29688270916e0d9a">&#9670;&nbsp;</a></span>socket_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt;<a class="el" href="namespaceMQTT__NS.html#adb219df86218e8f3200cc18903bf628b">MQTT_NS::socket</a>&gt;&amp; <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::socket_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> of socket. </p>
<dl class="section return"><dt>Returns</dt><dd>reference of <a class="el" href="classMQTT__NS_1_1shared__any.html" title="boost::type_erasure wrapper that supports shared_ptr">shared_any</a> socket </dd></dl>

</div>
</div>
<a id="a4ce134b027d9313ef79bf622659ed45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce134b027d9313ef79bf622659ed45d">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::start_session </td>
          <td>(</td>
          <td class="paramtype">any&#160;</td>
          <td class="paramname"><em>session_life_keeper</em> = <code>any()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start session with a connected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>finish handler that is called when the session is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9343443234b29e9eb93f5b4ecf05867e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9343443234b29e9eb93f5b4ecf05867e">&#9670;&nbsp;</a></span>suback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a> &gt;, std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c3a7634b034525ad19062ced8103ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c3a7634b034525ad19062ced8103ff">&#9670;&nbsp;</a></span>suback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d6f546a26eae937c53fb4610c224ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6f546a26eae937c53fb4610c224ec3">&#9670;&nbsp;</a></span>suback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">variant&lt; <a class="el" href="namespaceMQTT__NS.html#a3d04a60b2151fdd94dd33cd9ef349c23">suback_return_code</a>, <a class="el" href="namespaceMQTT__NS_1_1v5.html#a5e6fab68041ffec5669a68bd19a1a406">v5::suback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br  />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br  />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77950e184f8c63c5bf71790ee1fb05cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77950e184f8c63c5bf71790ee1fb05cc">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a511cab76d8e1c1fb666e38846bef4b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511cab76d8e1c1fb666e38846bef4b9f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="afa2f34abac43fd046082175d50d772d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2f34abac43fd046082175d50d772d7">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </dd></dl>

</div>
</div>
<a id="a9b251cac75ff14e264c1bc40b45c2eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b251cac75ff14e264c1bc40b45c2eb4">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </dd></dl>

</div>
</div>
<a id="a64812942bf42b83801ea48e4352a37a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64812942bf42b83801ea48e4352a37a9">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </dd></dl>

</div>
</div>
<a id="afe50b8a30e3e72925ab8dff7518da28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe50b8a30e3e72925ab8dff7518da28f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </dd></dl>

</div>
</div>
<a id="a022ca4babbb40ca60cd9c03281584811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022ca4babbb40ca60cd9c03281584811">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br  />
 </dd></dl>

</div>
</div>
<a id="a2506a3f48432467bcfb64715da0a9288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2506a3f48432467bcfb64715da0a9288">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and option pair. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a9dea01f04d2ba650332af41558e6633f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dea01f04d2ba650332af41558e6633f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and option pair. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a44c2dc98ab912aa5286330eb84b93650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c2dc98ab912aa5286330eb84b93650">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>, <a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and option pair. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ad8d2bd50132f2a9986ae766e3433dc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d2bd50132f2a9986ae766e3433dc07">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMQTT__NS_1_1subscribe__options.html">subscribe_options</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br  />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br  />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a1fad6ceb5599d28d1f97c0d2053d129a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fad6ceb5599d28d1f97c0d2053d129a">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53f999764a19542abc320081daacd94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f999764a19542abc320081daacd94c">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a> &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d4e8c0871a66e6563b42426e8565160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4e8c0871a66e6563b42426e8565160">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a487276490217b3e7164a6099a229ed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487276490217b3e7164a6099a229ed6f">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS_1_1v5.html#a09cbb971c4c596c8c3bb9723c2e91885">v5::unsuback_reason_code</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br  />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br  />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b35b1e92cf3508031d8fa90ca55e7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b35b1e92cf3508031d8fa90ca55e7ee">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a4146e98caadae8b038fe178bda340517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4146e98caadae8b038fe178bda340517">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a30537313b7312d4901bab82a3e7f3e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30537313b7312d4901bab82a3e7f3e34">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a3c88e75b50e1a4a72e634bf4d6ec6f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c88e75b50e1a4a72e634bf4d6ec6f05">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a6e66b73d93958f4e88cee209dfd49437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e66b73d93958f4e88cee209dfd49437">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a24597afd8a95f0d353e367eb0f681033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24597afd8a95f0d353e367eb0f681033">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ab196de6014d8fbd0838adc3e0c2b4fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab196de6014d8fbd0838adc3e0c2b4fb7">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ab79e71dbb6849334bfffd73848e40bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79e71dbb6849334bfffd73848e40bff">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a0254b37103d31eab6fbddb91d9a3c6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0254b37103d31eab6fbddb91d9a3c6cf">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMQTT__NS_1_1buffer.html">buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a0ba6360ee921a1c3366aa26442cbd8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba6360ee921a1c3366aa26442cbd8c0">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a6df9b9fdea79fdad5a55aaaae9b27d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df9b9fdea79fdad5a55aaaae9b27d16">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMQTT__NS_1_1endpoint.html#a9525c3f23b3eb6818ad591f88eb8ecc3">packet_id_t</a> <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMQTT__NS.html#a21d771b44b8849e58d538da7d6c59894">string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceMQTT__NS_1_1v5.html#ae3ca3933dcdd3bc58de88dedaf51b2ad">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br  />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br  />
 You can subscribe multiple topics all at once.<br  />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a13d162f21986858ca4175b47682fdd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d162f21986858ca4175b47682fdd02">&#9670;&nbsp;</a></span>clean_session_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMQTT__NS_1_1endpoint.html">MQTT_NS::endpoint</a>&lt; Mutex, LockGuard, PacketIdBytes &gt;::clean_session_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/mqtt_cpp/include/mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
