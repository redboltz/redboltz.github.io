<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mqtt_client_cpp: mqtt::endpoint&lt; Socket, Strand, Mutex, LockGuard &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mqtt_client_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemqtt.html">mqtt</a></li><li class="navelem"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmqtt_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::endpoint&lt; Socket, Strand, Mutex, LockGuard &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mqtt::endpoint&lt; Socket, Strand, Mutex, LockGuard &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmqtt_1_1endpoint.png" usemap="#mqtt::endpoint_3C_20Socket_2C_20Strand_2C_20Mutex_2C_20LockGuard_20_3E_map" alt=""/>
  <map id="mqtt::endpoint_3C_20Socket_2C_20Strand_2C_20Mutex_2C_20LockGuard_20_3E_map" name="mqtt::endpoint_3C_20Socket_2C_20Strand_2C_20Mutex_2C_20LockGuard_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63b9e9bbefcc4b42a15938ff068e43d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:a63b9e9bbefcc4b42a15938ff068e43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364af867678842e91c1b32dec2a41367"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:a364af867678842e91c1b32dec2a41367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3fdaee0e81d37bebb9a151e039ccf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:aecb3fdaee0e81d37bebb9a151e039ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09735fb1fb557054eb5e64c4fcdb51e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a> = std::function&lt; bool(std::string const  &amp;client_id, boost::optional&lt; std::string &gt; const  &amp;username, boost::optional&lt; std::string &gt; const  &amp;password, boost::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool clean_session, std::uint16_t keep_alive)&gt;</td></tr>
<tr class="separator:a09735fb1fb557054eb5e64c4fcdb51e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2db4cf296282078f39ea56402b0ef5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a> = std::function&lt; bool(bool session_present, std::uint8_t return_code)&gt;</td></tr>
<tr class="separator:a6e2db4cf296282078f39ea56402b0ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af733e4f7cf8c99f81f9df87e3136f4fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a> = std::function&lt; bool(std::uint8_t fixed_header, boost::optional&lt; std::uint16_t &gt; packet_id, std::string topic_name, std::string contents)&gt;</td></tr>
<tr class="separator:af733e4f7cf8c99f81f9df87e3136f4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda47243d8f43b27b4ec3e5d1361ba9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:aebda47243d8f43b27b4ec3e5d1361ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b758532793dd312300f2865bc33d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:a2c7b758532793dd312300f2865bc33d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fa6923cbee75e2ae2e15e240eee4e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:ac8fa6923cbee75e2ae2e15e240eee4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18af7ad4e07dbe398a0d75eb4c4ccfcd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:a18af7ad4e07dbe398a0d75eb4c4ccfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19bd5db5bf78fc249c4846716fb1b11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a> = std::function&lt; void(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:ad19bd5db5bf78fc249c4846716fb1b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2c91b53ab913165efe9e2d87b7607a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt; &gt; entries)&gt;</td></tr>
<tr class="separator:a2f2c91b53ab913165efe9e2d87b7607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523cd39c11406669dd46bde2ba5b3f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; boost::optional&lt; std::uint8_t &gt; &gt; qoss)&gt;</td></tr>
<tr class="separator:a8523cd39c11406669dd46bde2ba5b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63219b61745484e9bb0fe07a764a9a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; std::string &gt; topics)&gt;</td></tr>
<tr class="separator:af63219b61745484e9bb0fe07a764a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5df280004bb38ce2aff3b0dd415f807"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a> = std::function&lt; bool(std::uint16_t)&gt;</td></tr>
<tr class="separator:ab5df280004bb38ce2aff3b0dd415f807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c370dcf0b186feb08dce27aeffdaf92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="separator:a6c370dcf0b186feb08dce27aeffdaf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3ac60054f4c091c07ddc54b565fbac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="separator:a0c3ac60054f4c091c07ddc54b565fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7c3f10ad78e6c698d6bbfef6711c3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:abd7c3f10ad78e6c698d6bbfef6711c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbe67ee0ca6a224565117954514faba7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adbe67ee0ca6a224565117954514faba7">endpoint</a> (as::io_service &amp;ios)</td></tr>
<tr class="memdesc:adbe67ee0ca6a224565117954514faba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for client.  <a href="#adbe67ee0ca6a224565117954514faba7">More...</a><br /></td></tr>
<tr class="separator:adbe67ee0ca6a224565117954514faba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2c15b9d4eb3536f235e2954164fa10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5b2c15b9d4eb3536f235e2954164fa10">endpoint</a> (std::unique_ptr&lt; Socket &gt; &amp;&amp;<a class="el" href="classmqtt_1_1endpoint.html#a739ee2cca2ee28fccf8e8d4e5c5c390a">socket</a>)</td></tr>
<tr class="memdesc:a5b2c15b9d4eb3536f235e2954164fa10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for server. socket should have already been connected with another endpoint.  <a href="#a5b2c15b9d4eb3536f235e2954164fa10">More...</a><br /></td></tr>
<tr class="separator:a5b2c15b9d4eb3536f235e2954164fa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5d899567068fab9e09b92b57a16fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3ae5d899567068fab9e09b92b57a16fb">endpoint</a> (<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3ae5d899567068fab9e09b92b57a16fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c3ffaa30c1102b5d293c97533324f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a717c3ffaa30c1102b5d293c97533324f">operator=</a> (<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a717c3ffaa30c1102b5d293c97533324f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5291b48d933fa8f48db17903de48f7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5291b48d933fa8f48db17903de48f7cb">set_client_id</a> (std::string id)</td></tr>
<tr class="separator:a5291b48d933fa8f48db17903de48f7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bceb4fd28a4842b56a09cb5e5fecbe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3bceb4fd28a4842b56a09cb5e5fecbe7">set_clean_session</a> (bool cs)</td></tr>
<tr class="separator:a3bceb4fd28a4842b56a09cb5e5fecbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4334acb6ead803c6248f6f3d7795a4dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4334acb6ead803c6248f6f3d7795a4dc">set_user_name</a> (std::string name)</td></tr>
<tr class="separator:a4334acb6ead803c6248f6f3d7795a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c44bf215bc14d93a5ef1802130f9602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6c44bf215bc14d93a5ef1802130f9602">set_password</a> (std::string password)</td></tr>
<tr class="separator:a6c44bf215bc14d93a5ef1802130f9602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d430aa25b01e26cb33cefea88d7dc35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5d430aa25b01e26cb33cefea88d7dc35">set_will</a> (<a class="el" href="classmqtt_1_1will.html">will</a> w)</td></tr>
<tr class="separator:a5d430aa25b01e26cb33cefea88d7dc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff3b8838f85a217a690e5adcd0d1c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7ff3b8838f85a217a690e5adcd0d1c7a">set_auto_pub_response</a> (bool b=true, bool async=true)</td></tr>
<tr class="separator:a7ff3b8838f85a217a690e5adcd0d1c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2324d7ba670c34bd0ea9c59139d38fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae2324d7ba670c34bd0ea9c59139d38fb">set_close_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a>())</td></tr>
<tr class="memdesc:ae2324d7ba670c34bd0ea9c59139d38fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set close handler.  <a href="#ae2324d7ba670c34bd0ea9c59139d38fb">More...</a><br /></td></tr>
<tr class="separator:ae2324d7ba670c34bd0ea9c59139d38fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be7c8d8c65f6e101088dc9f0db6261d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5be7c8d8c65f6e101088dc9f0db6261d">set_error_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a>())</td></tr>
<tr class="memdesc:a5be7c8d8c65f6e101088dc9f0db6261d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error handler.  <a href="#a5be7c8d8c65f6e101088dc9f0db6261d">More...</a><br /></td></tr>
<tr class="separator:a5be7c8d8c65f6e101088dc9f0db6261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b7b3797009df1b4c58bef6f1c4e4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af5b7b3797009df1b4c58bef6f1c4e4b9">set_connect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a>())</td></tr>
<tr class="memdesc:af5b7b3797009df1b4c58bef6f1c4e4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connect handler.  <a href="#af5b7b3797009df1b4c58bef6f1c4e4b9">More...</a><br /></td></tr>
<tr class="separator:af5b7b3797009df1b4c58bef6f1c4e4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a75def55f0ef79ec36401a1c401695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a21a75def55f0ef79ec36401a1c401695">set_connack_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a>())</td></tr>
<tr class="memdesc:a21a75def55f0ef79ec36401a1c401695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connack handler.  <a href="#a21a75def55f0ef79ec36401a1c401695">More...</a><br /></td></tr>
<tr class="separator:a21a75def55f0ef79ec36401a1c401695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a85da3750bf33f92ebf754128d25a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac0a85da3750bf33f92ebf754128d25a0">set_publish_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a>())</td></tr>
<tr class="memdesc:ac0a85da3750bf33f92ebf754128d25a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#ac0a85da3750bf33f92ebf754128d25a0">More...</a><br /></td></tr>
<tr class="separator:ac0a85da3750bf33f92ebf754128d25a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff41688bb7c646e49b9b453082a0b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a57ff41688bb7c646e49b9b453082a0b3">set_puback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a>())</td></tr>
<tr class="memdesc:a57ff41688bb7c646e49b9b453082a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#a57ff41688bb7c646e49b9b453082a0b3">More...</a><br /></td></tr>
<tr class="separator:a57ff41688bb7c646e49b9b453082a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb309bc9a2b42206b3a4b77f31a7d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8bb309bc9a2b42206b3a4b77f31a7d64">set_pubrec_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a>())</td></tr>
<tr class="memdesc:a8bb309bc9a2b42206b3a4b77f31a7d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrec handler.  <a href="#a8bb309bc9a2b42206b3a4b77f31a7d64">More...</a><br /></td></tr>
<tr class="separator:a8bb309bc9a2b42206b3a4b77f31a7d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c65a8e44cb53fc11fd87a37b3e6f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a96c65a8e44cb53fc11fd87a37b3e6f14">set_pubrel_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a>())</td></tr>
<tr class="memdesc:a96c65a8e44cb53fc11fd87a37b3e6f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrel handler.  <a href="#a96c65a8e44cb53fc11fd87a37b3e6f14">More...</a><br /></td></tr>
<tr class="separator:a96c65a8e44cb53fc11fd87a37b3e6f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85b61e3a087e6668797ad269b52467e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae85b61e3a087e6668797ad269b52467e">set_pubcomp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a>())</td></tr>
<tr class="memdesc:ae85b61e3a087e6668797ad269b52467e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#ae85b61e3a087e6668797ad269b52467e">More...</a><br /></td></tr>
<tr class="separator:ae85b61e3a087e6668797ad269b52467e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aeb6d564015de6a35c9fec7180910d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a29aeb6d564015de6a35c9fec7180910d">set_pub_res_sent_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a>())</td></tr>
<tr class="memdesc:a29aeb6d564015de6a35c9fec7180910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#a29aeb6d564015de6a35c9fec7180910d">More...</a><br /></td></tr>
<tr class="separator:a29aeb6d564015de6a35c9fec7180910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336a1b0be761cea662fa58e68889e71a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a336a1b0be761cea662fa58e68889e71a">set_subscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a>())</td></tr>
<tr class="memdesc:a336a1b0be761cea662fa58e68889e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subscribe handler.  <a href="#a336a1b0be761cea662fa58e68889e71a">More...</a><br /></td></tr>
<tr class="separator:a336a1b0be761cea662fa58e68889e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f0eb0d98dcc1dc7feda6b8ba8dbca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad7f0eb0d98dcc1dc7feda6b8ba8dbca6">set_suback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a>())</td></tr>
<tr class="memdesc:ad7f0eb0d98dcc1dc7feda6b8ba8dbca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set suback handler.  <a href="#ad7f0eb0d98dcc1dc7feda6b8ba8dbca6">More...</a><br /></td></tr>
<tr class="separator:ad7f0eb0d98dcc1dc7feda6b8ba8dbca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b56791dd5a42146af701bac9a89498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae8b56791dd5a42146af701bac9a89498">set_unsubscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a>())</td></tr>
<tr class="memdesc:ae8b56791dd5a42146af701bac9a89498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsubscribe handler.  <a href="#ae8b56791dd5a42146af701bac9a89498">More...</a><br /></td></tr>
<tr class="separator:ae8b56791dd5a42146af701bac9a89498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e543946cd51cdcd7c2114b10302d272"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2e543946cd51cdcd7c2114b10302d272">set_unsuback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a>())</td></tr>
<tr class="memdesc:a2e543946cd51cdcd7c2114b10302d272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsuback handler.  <a href="#a2e543946cd51cdcd7c2114b10302d272">More...</a><br /></td></tr>
<tr class="separator:a2e543946cd51cdcd7c2114b10302d272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d2440d99026210a3df92ad2d98e197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a46d2440d99026210a3df92ad2d98e197">set_pingreq_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a>())</td></tr>
<tr class="memdesc:a46d2440d99026210a3df92ad2d98e197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingreq handler.  <a href="#a46d2440d99026210a3df92ad2d98e197">More...</a><br /></td></tr>
<tr class="separator:a46d2440d99026210a3df92ad2d98e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd064ab73c70309c164d7660b8b4c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8fd064ab73c70309c164d7660b8b4c2b">set_pingresp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a>())</td></tr>
<tr class="memdesc:a8fd064ab73c70309c164d7660b8b4c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingresp handler.  <a href="#a8fd064ab73c70309c164d7660b8b4c2b">More...</a><br /></td></tr>
<tr class="separator:a8fd064ab73c70309c164d7660b8b4c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf74f6b98a43f065551647889d9bf507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adf74f6b98a43f065551647889d9bf507">set_disconnect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a>())</td></tr>
<tr class="memdesc:adf74f6b98a43f065551647889d9bf507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set disconnect handler.  <a href="#adf74f6b98a43f065551647889d9bf507">More...</a><br /></td></tr>
<tr class="separator:adf74f6b98a43f065551647889d9bf507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a0ec0c64d6d29ba8ca85a92a07a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3a2a0ec0c64d6d29ba8ca85a92a07a91">start_session</a> (<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3a2a0ec0c64d6d29ba8ca85a92a07a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">start session with a connected endpoint.  <a href="#a3a2a0ec0c64d6d29ba8ca85a92a07a91">More...</a><br /></td></tr>
<tr class="separator:a3a2a0ec0c64d6d29ba8ca85a92a07a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cfde06227d8ef3e4ac7c391dd4649e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad1cfde06227d8ef3e4ac7c391dd4649e">publish_at_most_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:ad1cfde06227d8ef3e4ac7c391dd4649e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#ad1cfde06227d8ef3e4ac7c391dd4649e">More...</a><br /></td></tr>
<tr class="separator:ad1cfde06227d8ef3e4ac7c391dd4649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4739bf14e854b1e14f6b8d02bcb2876f"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4739bf14e854b1e14f6b8d02bcb2876f">publish_at_least_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a4739bf14e854b1e14f6b8d02bcb2876f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a4739bf14e854b1e14f6b8d02bcb2876f">More...</a><br /></td></tr>
<tr class="separator:a4739bf14e854b1e14f6b8d02bcb2876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1398030f3f7c6c6743d6ad9de0ae65b"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac1398030f3f7c6c6743d6ad9de0ae65b">publish_exactly_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:ac1398030f3f7c6c6743d6ad9de0ae65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#ac1398030f3f7c6c6743d6ad9de0ae65b">More...</a><br /></td></tr>
<tr class="separator:ac1398030f3f7c6c6743d6ad9de0ae65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328b9a76013c7181420797c9ab9d2214"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a328b9a76013c7181420797c9ab9d2214">publish</a> (std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:a328b9a76013c7181420797c9ab9d2214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#a328b9a76013c7181420797c9ab9d2214">More...</a><br /></td></tr>
<tr class="separator:a328b9a76013c7181420797c9ab9d2214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272ea8a134a7cb833716839fe5022509"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a272ea8a134a7cb833716839fe5022509"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a272ea8a134a7cb833716839fe5022509">subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:a272ea8a134a7cb833716839fe5022509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a272ea8a134a7cb833716839fe5022509">More...</a><br /></td></tr>
<tr class="separator:a272ea8a134a7cb833716839fe5022509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af37cdb24aaf9b8dd7a691193f21e6"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a49af37cdb24aaf9b8dd7a691193f21e6">subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:a49af37cdb24aaf9b8dd7a691193f21e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a49af37cdb24aaf9b8dd7a691193f21e6">More...</a><br /></td></tr>
<tr class="separator:a49af37cdb24aaf9b8dd7a691193f21e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7972a671a4d3f71e5f22454c1035997b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7972a671a4d3f71e5f22454c1035997b"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7972a671a4d3f71e5f22454c1035997b">unsubscribe</a> (std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:a7972a671a4d3f71e5f22454c1035997b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a7972a671a4d3f71e5f22454c1035997b">More...</a><br /></td></tr>
<tr class="separator:a7972a671a4d3f71e5f22454c1035997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a005460e0e0095a0a31ef9ff7b28a0e"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0a005460e0e0095a0a31ef9ff7b28a0e">unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:a0a005460e0e0095a0a31ef9ff7b28a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a0a005460e0e0095a0a31ef9ff7b28a0e">More...</a><br /></td></tr>
<tr class="separator:a0a005460e0e0095a0a31ef9ff7b28a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a66426c7ca0cb1df2fec65422520f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7a66426c7ca0cb1df2fec65422520f8f">disconnect</a> ()</td></tr>
<tr class="memdesc:a7a66426c7ca0cb1df2fec65422520f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a7a66426c7ca0cb1df2fec65422520f8f" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
  <a href="#a7a66426c7ca0cb1df2fec65422520f8f">More...</a><br /></td></tr>
<tr class="separator:a7a66426c7ca0cb1df2fec65422520f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e5fc04cc1162365d8c63b29dd016c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ada2e5fc04cc1162365d8c63b29dd016c">force_disconnect</a> ()</td></tr>
<tr class="memdesc:ada2e5fc04cc1162365d8c63b29dd016c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#ada2e5fc04cc1162365d8c63b29dd016c" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
  <a href="#ada2e5fc04cc1162365d8c63b29dd016c">More...</a><br /></td></tr>
<tr class="separator:ada2e5fc04cc1162365d8c63b29dd016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea818ea0928213d54f571b7b71f78dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adea818ea0928213d54f571b7b71f78dc">publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:adea818ea0928213d54f571b7b71f78dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#adea818ea0928213d54f571b7b71f78dc">More...</a><br /></td></tr>
<tr class="separator:adea818ea0928213d54f571b7b71f78dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff02dfe9d10e5bd92779b22ad5b866e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8ff02dfe9d10e5bd92779b22ad5b866e">publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a8ff02dfe9d10e5bd92779b22ad5b866e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a8ff02dfe9d10e5bd92779b22ad5b866e">More...</a><br /></td></tr>
<tr class="separator:a8ff02dfe9d10e5bd92779b22ad5b866e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f66fc5265ad392558bf0c3067324531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6f66fc5265ad392558bf0c3067324531">publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:a6f66fc5265ad392558bf0c3067324531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a6f66fc5265ad392558bf0c3067324531">More...</a><br /></td></tr>
<tr class="separator:a6f66fc5265ad392558bf0c3067324531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad661ea2957ceda98efd0cc2a486bbd42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad661ea2957ceda98efd0cc2a486bbd42">publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:ad661ea2957ceda98efd0cc2a486bbd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#ad661ea2957ceda98efd0cc2a486bbd42">More...</a><br /></td></tr>
<tr class="separator:ad661ea2957ceda98efd0cc2a486bbd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caaefa0ba92c4529f155994d6bf312f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5caaefa0ba92c4529f155994d6bf312f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5caaefa0ba92c4529f155994d6bf312f">subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:a5caaefa0ba92c4529f155994d6bf312f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a5caaefa0ba92c4529f155994d6bf312f">More...</a><br /></td></tr>
<tr class="separator:a5caaefa0ba92c4529f155994d6bf312f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795cbaa17a01b4e7e809c5fd885f0659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a795cbaa17a01b4e7e809c5fd885f0659">subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:a795cbaa17a01b4e7e809c5fd885f0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a795cbaa17a01b4e7e809c5fd885f0659">More...</a><br /></td></tr>
<tr class="separator:a795cbaa17a01b4e7e809c5fd885f0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f2c14597dced6b072408053386d3a5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a55f2c14597dced6b072408053386d3a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a55f2c14597dced6b072408053386d3a5">unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:a55f2c14597dced6b072408053386d3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a55f2c14597dced6b072408053386d3a5">More...</a><br /></td></tr>
<tr class="separator:a55f2c14597dced6b072408053386d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f92d7dddfb0179a1ab3246ee1f9623"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac4f92d7dddfb0179a1ab3246ee1f9623">unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:ac4f92d7dddfb0179a1ab3246ee1f9623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#ac4f92d7dddfb0179a1ab3246ee1f9623">More...</a><br /></td></tr>
<tr class="separator:ac4f92d7dddfb0179a1ab3246ee1f9623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78155bba5ba990a1dba632f66b658aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a78155bba5ba990a1dba632f66b658aeb">acquired_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a78155bba5ba990a1dba632f66b658aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with already acquired packet identifier.  <a href="#a78155bba5ba990a1dba632f66b658aeb">More...</a><br /></td></tr>
<tr class="separator:a78155bba5ba990a1dba632f66b658aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0746f42de01fd00fb19325ed36c06bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0746f42de01fd00fb19325ed36c06bcf">acquired_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a0746f42de01fd00fb19325ed36c06bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with already acquired packet identifier.  <a href="#a0746f42de01fd00fb19325ed36c06bcf">More...</a><br /></td></tr>
<tr class="separator:a0746f42de01fd00fb19325ed36c06bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b759e0ef07172994101b5ecf00f070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a96b759e0ef07172994101b5ecf00f070">acquired_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:a96b759e0ef07172994101b5ecf00f070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="#a96b759e0ef07172994101b5ecf00f070">More...</a><br /></td></tr>
<tr class="separator:a96b759e0ef07172994101b5ecf00f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62e3740408ff0eeb7b12ac158518e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab62e3740408ff0eeb7b12ac158518e41">acquired_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:ab62e3740408ff0eeb7b12ac158518e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="#ab62e3740408ff0eeb7b12ac158518e41">More...</a><br /></td></tr>
<tr class="separator:ab62e3740408ff0eeb7b12ac158518e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2169c1b2716f0856bca976752f255f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acf2169c1b2716f0856bca976752f255f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acf2169c1b2716f0856bca976752f255f">acquired_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:acf2169c1b2716f0856bca976752f255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#acf2169c1b2716f0856bca976752f255f">More...</a><br /></td></tr>
<tr class="separator:acf2169c1b2716f0856bca976752f255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127291cea49367f0be3d6e5ff4b25a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a127291cea49367f0be3d6e5ff4b25a54">acquired_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:a127291cea49367f0be3d6e5ff4b25a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#a127291cea49367f0be3d6e5ff4b25a54">More...</a><br /></td></tr>
<tr class="separator:a127291cea49367f0be3d6e5ff4b25a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204e49d556fa517b1743ebb9f33e03c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8204e49d556fa517b1743ebb9f33e03c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8204e49d556fa517b1743ebb9f33e03c">acquired_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:a8204e49d556fa517b1743ebb9f33e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a8204e49d556fa517b1743ebb9f33e03c">More...</a><br /></td></tr>
<tr class="separator:a8204e49d556fa517b1743ebb9f33e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdee25be411d0ec8e749ffba3be75f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4fdee25be411d0ec8e749ffba3be75f3">acquired_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:a4fdee25be411d0ec8e749ffba3be75f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a4fdee25be411d0ec8e749ffba3be75f3">More...</a><br /></td></tr>
<tr class="separator:a4fdee25be411d0ec8e749ffba3be75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421e3230f596187014080dabf78f75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8421e3230f596187014080dabf78f75e">pingreq</a> ()</td></tr>
<tr class="memdesc:a8421e3230f596187014080dabf78f75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a>.  <a href="#a8421e3230f596187014080dabf78f75e">More...</a><br /></td></tr>
<tr class="separator:a8421e3230f596187014080dabf78f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100ce8fd880e5e5ebeba6e70b33bcc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a100ce8fd880e5e5ebeba6e70b33bcc2a">pingresp</a> ()</td></tr>
<tr class="memdesc:a100ce8fd880e5e5ebeba6e70b33bcc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a>.  <a href="#a100ce8fd880e5e5ebeba6e70b33bcc2a">More...</a><br /></td></tr>
<tr class="separator:a100ce8fd880e5e5ebeba6e70b33bcc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe841052b0b07878b8f41d35e56a0828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828">connect</a> (std::uint16_t keep_alive_sec)</td></tr>
<tr class="memdesc:afe841052b0b07878b8f41d35e56a0828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#afe841052b0b07878b8f41d35e56a0828">More...</a><br /></td></tr>
<tr class="separator:afe841052b0b07878b8f41d35e56a0828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd80a5218013143a28ebb9623d7760f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acdd80a5218013143a28ebb9623d7760f">connack</a> (bool session_present, std::uint8_t return_code)</td></tr>
<tr class="memdesc:acdd80a5218013143a28ebb9623d7760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#acdd80a5218013143a28ebb9623d7760f">More...</a><br /></td></tr>
<tr class="separator:acdd80a5218013143a28ebb9623d7760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777bcc7a429a14d280f02cf6568c7041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a777bcc7a429a14d280f02cf6568c7041">puback</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a777bcc7a429a14d280f02cf6568c7041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a>.  <a href="#a777bcc7a429a14d280f02cf6568c7041">More...</a><br /></td></tr>
<tr class="separator:a777bcc7a429a14d280f02cf6568c7041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f38026671e867a67dc539aa1b4ea149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8f38026671e867a67dc539aa1b4ea149">pubrec</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a8f38026671e867a67dc539aa1b4ea149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a>.  <a href="#a8f38026671e867a67dc539aa1b4ea149">More...</a><br /></td></tr>
<tr class="separator:a8f38026671e867a67dc539aa1b4ea149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3cb58db8b272192922190cc259936c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2e3cb58db8b272192922190cc259936c">pubrel</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a2e3cb58db8b272192922190cc259936c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a>.  <a href="#a2e3cb58db8b272192922190cc259936c">More...</a><br /></td></tr>
<tr class="separator:a2e3cb58db8b272192922190cc259936c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65a0434feaff1f020f75b174b63c8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab65a0434feaff1f020f75b174b63c8a8">pubcomp</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:ab65a0434feaff1f020f75b174b63c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a>.  <a href="#ab65a0434feaff1f020f75b174b63c8a8">More...</a><br /></td></tr>
<tr class="separator:ab65a0434feaff1f020f75b174b63c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73813c553db44cc4f86134702ca7ea20"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a73813c553db44cc4f86134702ca7ea20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a73813c553db44cc4f86134702ca7ea20">suback</a> (std::uint16_t packet_id, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a73813c553db44cc4f86134702ca7ea20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos  args additional qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>.  <a href="#a73813c553db44cc4f86134702ca7ea20">More...</a><br /></td></tr>
<tr class="separator:a73813c553db44cc4f86134702ca7ea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca85b157b4e04da873c908bf0a0ea85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeca85b157b4e04da873c908bf0a0ea85">suback</a> (std::uint16_t packet_id, std::vector&lt; std::uint8_t &gt; const &amp;qoss)</td></tr>
<tr class="memdesc:aeca85b157b4e04da873c908bf0a0ea85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>.  <a href="#aeca85b157b4e04da873c908bf0a0ea85">More...</a><br /></td></tr>
<tr class="separator:aeca85b157b4e04da873c908bf0a0ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641bb6d27784043e3dc62b3b022018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a97641bb6d27784043e3dc62b3b022018">unsuback</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a97641bb6d27784043e3dc62b3b022018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a>.  <a href="#a97641bb6d27784043e3dc62b3b022018">More...</a><br /></td></tr>
<tr class="separator:a97641bb6d27784043e3dc62b3b022018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588539439be14827780eebe9304317e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a588539439be14827780eebe9304317e8">async_publish_at_most_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a588539439be14827780eebe9304317e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#a588539439be14827780eebe9304317e8">More...</a><br /></td></tr>
<tr class="separator:a588539439be14827780eebe9304317e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f09fbd7cf18123f1e897400fdb023a"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a73f09fbd7cf18123f1e897400fdb023a">async_publish_at_least_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a73f09fbd7cf18123f1e897400fdb023a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a73f09fbd7cf18123f1e897400fdb023a">More...</a><br /></td></tr>
<tr class="separator:a73f09fbd7cf18123f1e897400fdb023a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7831370898d790df41a86a3447ddacf4"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7831370898d790df41a86a3447ddacf4">async_publish_exactly_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7831370898d790df41a86a3447ddacf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a7831370898d790df41a86a3447ddacf4">More...</a><br /></td></tr>
<tr class="separator:a7831370898d790df41a86a3447ddacf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be37fcf6346a73fa386b67d429ea44e"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9be37fcf6346a73fa386b67d429ea44e">async_publish</a> (std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9be37fcf6346a73fa386b67d429ea44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#a9be37fcf6346a73fa386b67d429ea44e">More...</a><br /></td></tr>
<tr class="separator:a9be37fcf6346a73fa386b67d429ea44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa456b3191a05384dca0b9ed2c76442e8"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa456b3191a05384dca0b9ed2c76442e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, std::uint16_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa456b3191a05384dca0b9ed2c76442e8">async_subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa456b3191a05384dca0b9ed2c76442e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#aa456b3191a05384dca0b9ed2c76442e8">More...</a><br /></td></tr>
<tr class="separator:aa456b3191a05384dca0b9ed2c76442e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd6bc5d779c2da5c1d7d408cf3aeb4"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a58cd6bc5d779c2da5c1d7d408cf3aeb4">async_subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a58cd6bc5d779c2da5c1d7d408cf3aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a58cd6bc5d779c2da5c1d7d408cf3aeb4">More...</a><br /></td></tr>
<tr class="separator:a58cd6bc5d779c2da5c1d7d408cf3aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96332b86a1bfd1fb25eac840466d90da"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a96332b86a1bfd1fb25eac840466d90da">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a96332b86a1bfd1fb25eac840466d90da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a96332b86a1bfd1fb25eac840466d90da">More...</a><br /></td></tr>
<tr class="separator:a96332b86a1bfd1fb25eac840466d90da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5141f47024f3fe791ca1ee9b91b11468"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5141f47024f3fe791ca1ee9b91b11468"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, std::uint16_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5141f47024f3fe791ca1ee9b91b11468">async_unsubscribe</a> (std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5141f47024f3fe791ca1ee9b91b11468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a5141f47024f3fe791ca1ee9b91b11468">More...</a><br /></td></tr>
<tr class="separator:a5141f47024f3fe791ca1ee9b91b11468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbdde4ded4a87b36e3a583787150f51"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0dbdde4ded4a87b36e3a583787150f51">async_unsubscribe</a> (std::string const &amp;topic_name, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0dbdde4ded4a87b36e3a583787150f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a0dbdde4ded4a87b36e3a583787150f51">More...</a><br /></td></tr>
<tr class="separator:a0dbdde4ded4a87b36e3a583787150f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9ce485692af230f3436fee4c7ef41c"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5e9ce485692af230f3436fee4c7ef41c">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a5e9ce485692af230f3436fee4c7ef41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a5e9ce485692af230f3436fee4c7ef41c">More...</a><br /></td></tr>
<tr class="separator:a5e9ce485692af230f3436fee4c7ef41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a06ab65cd7becb1b9b44ee72d7dacf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7a06ab65cd7becb1b9b44ee72d7dacf7">async_disconnect</a> (<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7a06ab65cd7becb1b9b44ee72d7dacf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="#a7a06ab65cd7becb1b9b44ee72d7dacf7">More...</a><br /></td></tr>
<tr class="separator:a7a06ab65cd7becb1b9b44ee72d7dacf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86026e50fd148d4e60705eff1a36a330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a86026e50fd148d4e60705eff1a36a330">async_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a86026e50fd148d4e60705eff1a36a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a86026e50fd148d4e60705eff1a36a330">More...</a><br /></td></tr>
<tr class="separator:a86026e50fd148d4e60705eff1a36a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536d2f27be063d34080fc889ca3ea072"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a536d2f27be063d34080fc889ca3ea072">async_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a536d2f27be063d34080fc889ca3ea072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a536d2f27be063d34080fc889ca3ea072">More...</a><br /></td></tr>
<tr class="separator:a536d2f27be063d34080fc889ca3ea072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f9afa6ff14808036e69eec8b91ad9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a22f9afa6ff14808036e69eec8b91ad9c">async_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a22f9afa6ff14808036e69eec8b91ad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a22f9afa6ff14808036e69eec8b91ad9c">More...</a><br /></td></tr>
<tr class="separator:a22f9afa6ff14808036e69eec8b91ad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81609f8496159dda50134d14fcc1be41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a81609f8496159dda50134d14fcc1be41">async_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a81609f8496159dda50134d14fcc1be41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a81609f8496159dda50134d14fcc1be41">More...</a><br /></td></tr>
<tr class="separator:a81609f8496159dda50134d14fcc1be41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb668cf9e4b21f5953293162689bf4a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4eb668cf9e4b21f5953293162689bf4a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4eb668cf9e4b21f5953293162689bf4a">async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4eb668cf9e4b21f5953293162689bf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a4eb668cf9e4b21f5953293162689bf4a">More...</a><br /></td></tr>
<tr class="separator:a4eb668cf9e4b21f5953293162689bf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acca900fb6ba308b37c6a1d259ccad7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6acca900fb6ba308b37c6a1d259ccad7">async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6acca900fb6ba308b37c6a1d259ccad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a6acca900fb6ba308b37c6a1d259ccad7">More...</a><br /></td></tr>
<tr class="separator:a6acca900fb6ba308b37c6a1d259ccad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0892ce95d342bed4e4ce7bc8147b6d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa0892ce95d342bed4e4ce7bc8147b6d0">async_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa0892ce95d342bed4e4ce7bc8147b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#aa0892ce95d342bed4e4ce7bc8147b6d0">More...</a><br /></td></tr>
<tr class="separator:aa0892ce95d342bed4e4ce7bc8147b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4046e8b41b7efdaa0149078825338d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0b4046e8b41b7efdaa0149078825338d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0b4046e8b41b7efdaa0149078825338d">async_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0b4046e8b41b7efdaa0149078825338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a0b4046e8b41b7efdaa0149078825338d">More...</a><br /></td></tr>
<tr class="separator:a0b4046e8b41b7efdaa0149078825338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4499fa72e042cb0272a657b64a7ed6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8d4499fa72e042cb0272a657b64a7ed6">async_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8d4499fa72e042cb0272a657b64a7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a8d4499fa72e042cb0272a657b64a7ed6">More...</a><br /></td></tr>
<tr class="separator:a8d4499fa72e042cb0272a657b64a7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a108f823c9930b104e42b6cc8e5f702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4a108f823c9930b104e42b6cc8e5f702">acquired_async_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4a108f823c9930b104e42b6cc8e5f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a4a108f823c9930b104e42b6cc8e5f702">More...</a><br /></td></tr>
<tr class="separator:a4a108f823c9930b104e42b6cc8e5f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8747ac11764c03edcfd6b8c8e7e48ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8747ac11764c03edcfd6b8c8e7e48ea8">acquired_async_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8747ac11764c03edcfd6b8c8e7e48ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a8747ac11764c03edcfd6b8c8e7e48ea8">More...</a><br /></td></tr>
<tr class="separator:a8747ac11764c03edcfd6b8c8e7e48ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94f5f6a75d4446a68e1bf7c4920fbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa94f5f6a75d4446a68e1bf7c4920fbc3">acquired_async_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa94f5f6a75d4446a68e1bf7c4920fbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#aa94f5f6a75d4446a68e1bf7c4920fbc3">More...</a><br /></td></tr>
<tr class="separator:aa94f5f6a75d4446a68e1bf7c4920fbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f15e7048d249077302fee9d00fea23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a36f15e7048d249077302fee9d00fea23">acquired_async_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a36f15e7048d249077302fee9d00fea23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a36f15e7048d249077302fee9d00fea23">More...</a><br /></td></tr>
<tr class="separator:a36f15e7048d249077302fee9d00fea23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10777f10a4adfeea508cc34329ca6d3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af10777f10a4adfeea508cc34329ca6d3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af10777f10a4adfeea508cc34329ca6d3">acquired_async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af10777f10a4adfeea508cc34329ca6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#af10777f10a4adfeea508cc34329ca6d3">More...</a><br /></td></tr>
<tr class="separator:af10777f10a4adfeea508cc34329ca6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ff8782e97af60877b9b6e4d850f2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a83ff8782e97af60877b9b6e4d850f2d0">acquired_async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a83ff8782e97af60877b9b6e4d850f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a83ff8782e97af60877b9b6e4d850f2d0">More...</a><br /></td></tr>
<tr class="separator:a83ff8782e97af60877b9b6e4d850f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467560f50758d5be2771c943ca57362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4467560f50758d5be2771c943ca57362">acquired_async_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4467560f50758d5be2771c943ca57362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a4467560f50758d5be2771c943ca57362">More...</a><br /></td></tr>
<tr class="separator:a4467560f50758d5be2771c943ca57362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92663eaa9038f1e45a18dce6144ede09"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a92663eaa9038f1e45a18dce6144ede09"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a92663eaa9038f1e45a18dce6144ede09">acquired_async_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a92663eaa9038f1e45a18dce6144ede09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a92663eaa9038f1e45a18dce6144ede09">More...</a><br /></td></tr>
<tr class="separator:a92663eaa9038f1e45a18dce6144ede09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000364cb51e3704352b9aaac2efbcdfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a000364cb51e3704352b9aaac2efbcdfd">acquired_async_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a000364cb51e3704352b9aaac2efbcdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a000364cb51e3704352b9aaac2efbcdfd">More...</a><br /></td></tr>
<tr class="separator:a000364cb51e3704352b9aaac2efbcdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc287ecee410ea22bdbfa616db54df43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afc287ecee410ea22bdbfa616db54df43">async_pingreq</a> (<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:afc287ecee410ea22bdbfa616db54df43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet.  <a href="#afc287ecee410ea22bdbfa616db54df43">More...</a><br /></td></tr>
<tr class="separator:afc287ecee410ea22bdbfa616db54df43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a428a359046dfe9a540242511e9250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a25a428a359046dfe9a540242511e9250">async_pingresp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a25a428a359046dfe9a540242511e9250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker.  <a href="#a25a428a359046dfe9a540242511e9250">More...</a><br /></td></tr>
<tr class="separator:a25a428a359046dfe9a540242511e9250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d19acddedbef9a64b2ec8508a17682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a69d19acddedbef9a64b2ec8508a17682">async_connect</a> (std::uint16_t keep_alive_sec, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a69d19acddedbef9a64b2ec8508a17682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#a69d19acddedbef9a64b2ec8508a17682">More...</a><br /></td></tr>
<tr class="separator:a69d19acddedbef9a64b2ec8508a17682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab46edf10382483aaf7aa8269b1226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a72ab46edf10382483aaf7aa8269b1226">async_connack</a> (bool session_present, std::uint8_t return_code, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a72ab46edf10382483aaf7aa8269b1226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#a72ab46edf10382483aaf7aa8269b1226">More...</a><br /></td></tr>
<tr class="separator:a72ab46edf10382483aaf7aa8269b1226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecd89e70dce3bb55113fad4d3ed5acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aaecd89e70dce3bb55113fad4d3ed5acc">async_puback</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:aaecd89e70dce3bb55113fad4d3ed5acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  packet id corresponding to publish.  <a href="#aaecd89e70dce3bb55113fad4d3ed5acc">More...</a><br /></td></tr>
<tr class="separator:aaecd89e70dce3bb55113fad4d3ed5acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fbb9b2a24b1279609e928412789a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af9fbb9b2a24b1279609e928412789a18">async_pubrec</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:af9fbb9b2a24b1279609e928412789a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  packet id corresponding to publish.  <a href="#af9fbb9b2a24b1279609e928412789a18">More...</a><br /></td></tr>
<tr class="separator:af9fbb9b2a24b1279609e928412789a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b3feba2ba6694e2ff1ac5707a5f478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac0b3feba2ba6694e2ff1ac5707a5f478">async_pubrel</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac0b3feba2ba6694e2ff1ac5707a5f478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  packet id corresponding to publish.  <a href="#ac0b3feba2ba6694e2ff1ac5707a5f478">More...</a><br /></td></tr>
<tr class="separator:ac0b3feba2ba6694e2ff1ac5707a5f478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f544b9f7fbf8759705a1c2cd5a73806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3f544b9f7fbf8759705a1c2cd5a73806">async_pubcomp</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3f544b9f7fbf8759705a1c2cd5a73806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  packet id corresponding to publish.  <a href="#a3f544b9f7fbf8759705a1c2cd5a73806">More...</a><br /></td></tr>
<tr class="separator:a3f544b9f7fbf8759705a1c2cd5a73806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922ccfb8400aab0cf18b91383c390c2a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a922ccfb8400aab0cf18b91383c390c2a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a922ccfb8400aab0cf18b91383c390c2a">async_suback</a> (std::uint16_t packet_id, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a922ccfb8400aab0cf18b91383c390c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe.  <a href="#a922ccfb8400aab0cf18b91383c390c2a">More...</a><br /></td></tr>
<tr class="separator:a922ccfb8400aab0cf18b91383c390c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b209a0452e933289cb3b72c55a1f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a25b209a0452e933289cb3b72c55a1f76">async_suback</a> (std::uint16_t packet_id, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a25b209a0452e933289cb3b72c55a1f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos.  <a href="#a25b209a0452e933289cb3b72c55a1f76">More...</a><br /></td></tr>
<tr class="separator:a25b209a0452e933289cb3b72c55a1f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e563c28cd4588eb9cb3ba6c8ba0605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a41e563c28cd4588eb9cb3ba6c8ba0605">async_suback</a> (std::uint16_t packet_id, std::vector&lt; std::uint8_t &gt; const &amp;qoss, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:a41e563c28cd4588eb9cb3ba6c8ba0605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos.  <a href="#a41e563c28cd4588eb9cb3ba6c8ba0605">More...</a><br /></td></tr>
<tr class="separator:a41e563c28cd4588eb9cb3ba6c8ba0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e96e19f39cfc3a1b5dbbee4d4f02a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa0e96e19f39cfc3a1b5dbbee4d4f02a2">async_unsuback</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa0e96e19f39cfc3a1b5dbbee4d4f02a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe.  <a href="#aa0e96e19f39cfc3a1b5dbbee4d4f02a2">More...</a><br /></td></tr>
<tr class="separator:aa0e96e19f39cfc3a1b5dbbee4d4f02a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa15ba94d7f94f37b7bd8dc35fd3c5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5fa15ba94d7f94f37b7bd8dc35fd3c5a">handle_close_or_error</a> (boost::system::error_code const &amp;ec)</td></tr>
<tr class="separator:a5fa15ba94d7f94f37b7bd8dc35fd3c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91466fe31d4a409cf1406102363995"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aaf91466fe31d4a409cf1406102363995">connected</a> () const</td></tr>
<tr class="separator:aaf91466fe31d4a409cf1406102363995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1f225431a73fd4af23ef5fde573015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeb1f225431a73fd4af23ef5fde573015">set_connect</a> ()</td></tr>
<tr class="separator:aeb1f225431a73fd4af23ef5fde573015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a1bab156b7281193e9f6015fec546a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a78a1bab156b7281193e9f6015fec546a">clear_stored_publish</a> (std::uint16_t packet_id)</td></tr>
<tr class="separator:a78a1bab156b7281193e9f6015fec546a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739ee2cca2ee28fccf8e8d4e5c5c390a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a739ee2cca2ee28fccf8e8d4e5c5c390a">socket</a> ()</td></tr>
<tr class="separator:a739ee2cca2ee28fccf8e8d4e5c5c390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768a7cc95b98b9999d604bc01f9d185a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a768a7cc95b98b9999d604bc01f9d185a">socket</a> () const</td></tr>
<tr class="separator:a768a7cc95b98b9999d604bc01f9d185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c010c110cebb405cd33aabeddf5e10f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a0c010c110cebb405cd33aabeddf5e10f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0c010c110cebb405cd33aabeddf5e10f">for_each_store</a> (F f)</td></tr>
<tr class="separator:a0c010c110cebb405cd33aabeddf5e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2939608b042f80104fbfb94f60b63"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8fc2939608b042f80104fbfb94f60b63">acquire_unique_packet_id</a> ()</td></tr>
<tr class="separator:a8fc2939608b042f80104fbfb94f60b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab688d9c2c343e4facde63a33f51e25a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab688d9c2c343e4facde63a33f51e25a8">register_packet_id</a> (std::uint16_t packet_id)</td></tr>
<tr class="separator:ab688d9c2c343e4facde63a33f51e25a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f88ab5de17646da38f5a2431721159"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a98f88ab5de17646da38f5a2431721159">release_packet_id</a> (std::uint16_t packet_id)</td></tr>
<tr class="separator:a98f88ab5de17646da38f5a2431721159"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a480e1eda72cf9b7895a78d96fccae85c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a480e1eda72cf9b7895a78d96fccae85c">async_read_control_packet_type</a> (<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;func)</td></tr>
<tr class="separator:a480e1eda72cf9b7895a78d96fccae85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a63b9e9bbefcc4b42a15938ff068e43d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b9e9bbefcc4b42a15938ff068e43d7">&#9670;&nbsp;</a></span>async_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a364af867678842e91c1b32dec2a41367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364af867678842e91c1b32dec2a41367">&#9670;&nbsp;</a></span>close_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close handler </p>

</div>
</div>
<a id="a6e2db4cf296282078f39ea56402b0ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2db4cf296282078f39ea56402b0ef5">&#9670;&nbsp;</a></span>connack_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a> =  std::function&lt;bool(bool session_present, std::uint8_t return_code)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connack handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035</a><br />
 3.2.2.2 Session Present </td></tr>
    <tr><td class="paramname">return_code</td><td><a class="el" href="namespacemqtt_1_1connect__return__code.html">connect_return_code</a><br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035</a><br />
 3.2.2.3 Connect Return code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a09735fb1fb557054eb5e64c4fcdb51e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09735fb1fb557054eb5e64c4fcdb51e5">&#9670;&nbsp;</a></span>connect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a> =  std::function&lt; bool(std::string const&amp; client_id, boost::optional&lt;std::string&gt; const&amp; username, boost::optional&lt;std::string&gt; const&amp; password, boost::optional&lt;<a class="el" href="classmqtt_1_1will.html">will</a>&gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool clean_session, std::uint16_t keep_alive)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>User Name.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">username</td><td>User Name.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349246">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349246</a><br />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, topic, and message.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349232">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349232</a><br />
 3.1.2.5 Will Flag<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349233">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349233</a><br />
 3.1.2.6 Will QoS<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349234">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349234</a><br />
 3.1.2.7 Will Retain<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349243">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349243</a><br />
 3.1.3.2 Will Topic<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349244">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349244</a><br />
 3.1.3.3 Will Message<br />
 </td></tr>
    <tr><td class="paramname">clean_session</td><td>Clean Session<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231</a><br />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349237">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349237</a><br />
 3.1.2.10 Keep Alive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="abd7c3f10ad78e6c698d6bbfef6711c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7c3f10ad78e6c698d6bbfef6711c3b">&#9670;&nbsp;</a></span>disconnect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800463">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800463</a><br />
 3.14 DISCONNECT  Disconnect notification </p>

</div>
</div>
<a id="aecb3fdaee0e81d37bebb9a151e039ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3fdaee0e81d37bebb9a151e039ccf">&#9670;&nbsp;</a></span>error_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c370dcf0b186feb08dce27aeffdaf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c370dcf0b186feb08dce27aeffdaf92">&#9670;&nbsp;</a></span>pingreq_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081</a><br />
 3.13 PINGREQ  PING request </p><dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a0c3ac60054f4c091c07ddc54b565fbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3ac60054f4c091c07ddc54b565fbac">&#9670;&nbsp;</a></span>pingresp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pingresp handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br />
 3.13 PINGRESP  PING response </p><dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad19bd5db5bf78fc249c4846716fb1b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19bd5db5bf78fc249c4846716fb1b11">&#9670;&nbsp;</a></span>pub_res_sent_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a> =  std::function&lt;void(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060</a><br />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebda47243d8f43b27b4ec3e5d1361ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebda47243d8f43b27b4ec3e5d1361ba9">&#9670;&nbsp;</a></span>puback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045</a><br />
 3.4.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a18af7ad4e07dbe398a0d75eb4c4ccfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18af7ad4e07dbe398a0d75eb4c4ccfcd">&#9670;&nbsp;</a></span>pubcomp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubcomp handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060</a><br />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="af733e4f7cf8c99f81f9df87e3136f4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af733e4f7cf8c99f81f9df87e3136f4fc">&#9670;&nbsp;</a></span>publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a> =  std::function&lt;bool(std::uint8_t fixed_header, boost::optional&lt;std::uint16_t&gt; packet_id, std::string topic_name, std::string contents)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1 Fixed header<br />
 You can check the fixed header using <a class="el" href="namespacemqtt_1_1publish.html">mqtt::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 If received publish's QoS is 0, packet_id is boost::none.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718039">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718039</a><br />
 3.3.2 Variable header </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">contents</td><td>Published contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a2c7b758532793dd312300f2865bc33d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7b758532793dd312300f2865bc33d7">&#9670;&nbsp;</a></span>pubrec_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubrec handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718050">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718050</a><br />
 3.5.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ac8fa6923cbee75e2ae2e15e240eee4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fa6923cbee75e2ae2e15e240eee4e9">&#9670;&nbsp;</a></span>pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubrel handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349791">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349791</a><br />
 3.6.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a8523cd39c11406669dd46bde2ba5b3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8523cd39c11406669dd46bde2ba5b3f0">&#9670;&nbsp;</a></span>suback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;boost::optional&lt;std::uint8_t&gt; &gt; qoss)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718070">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718070</a><br />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">qoss</td><td>Collection of QoS that is corresponding to subscribed topic order.<br />
 If subscription is failure, the value is boost::none.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718071">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718071</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a2f2c91b53ab913165efe9e2d87b7607a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2c91b53ab913165efe9e2d87b7607a">&#9670;&nbsp;</a></span>subscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;std::tuple&lt;std::string, std::uint8_t&gt; &gt; entries)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349801">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349801</a><br />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349802">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349802</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ab5df280004bb38ce2aff3b0dd415f807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5df280004bb38ce2aff3b0dd415f807">&#9670;&nbsp;</a></span>unsuback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a> =  std::function&lt;bool(std::uint16_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsuback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045</a><br />
 3.11.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="af63219b61745484e9bb0fe07a764a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63219b61745484e9bb0fe07a764a9a9">&#9670;&nbsp;</a></span>unsubscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;std::string&gt; topics)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsubscribe handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349810">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349810</a><br />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800448">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800448</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adbe67ee0ca6a224565117954514faba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe67ee0ca6a224565117954514faba7">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">as::io_service &amp;&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for client. </p>

</div>
</div>
<a id="a5b2c15b9d4eb3536f235e2954164fa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2c15b9d4eb3536f235e2954164fa10">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Socket &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for server. socket should have already been connected with another endpoint. </p>

</div>
</div>
<a id="a3ae5d899567068fab9e09b92b57a16fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5d899567068fab9e09b92b57a16fb">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fc2939608b042f80104fbfb94f60b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2939608b042f80104fbfb94f60b63">&#9670;&nbsp;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa94f5f6a75d4446a68e1bf7c4920fbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94f5f6a75d4446a68e1bf7c4920fbc3">&#9670;&nbsp;</a></span>acquired_async_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a108f823c9930b104e42b6cc8e5f702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a108f823c9930b104e42b6cc8e5f702">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36f15e7048d249077302fee9d00fea23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f15e7048d249077302fee9d00fea23">&#9670;&nbsp;</a></span>acquired_async_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8747ac11764c03edcfd6b8c8e7e48ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8747ac11764c03edcfd6b8c8e7e48ea8">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10777f10a4adfeea508cc34329ca6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10777f10a4adfeea508cc34329ca6d3">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, void &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be some pairs of topic_name and qos to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83ff8782e97af60877b9b6e4d850f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ff8782e97af60877b9b6e4d850f2d0">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4467560f50758d5be2771c943ca57362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4467560f50758d5be2771c943ca57362">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92663eaa9038f1e45a18dce6144ede09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92663eaa9038f1e45a18dce6144ede09">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0 &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000364cb51e3704352b9aaac2efbcdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000364cb51e3704352b9aaac2efbcdfd">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96b759e0ef07172994101b5ecf00f070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b759e0ef07172994101b5ecf00f070">&#9670;&nbsp;</a></span>acquired_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78155bba5ba990a1dba632f66b658aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78155bba5ba990a1dba632f66b658aeb">&#9670;&nbsp;</a></span>acquired_publish_at_least_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab62e3740408ff0eeb7b12ac158518e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62e3740408ff0eeb7b12ac158518e41">&#9670;&nbsp;</a></span>acquired_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0746f42de01fd00fb19325ed36c06bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0746f42de01fd00fb19325ed36c06bcf">&#9670;&nbsp;</a></span>acquired_publish_exactly_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf2169c1b2716f0856bca976752f255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2169c1b2716f0856bca976752f255f">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a127291cea49367f0be3d6e5ff4b25a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127291cea49367f0be3d6e5ff4b25a54">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8204e49d556fa517b1743ebb9f33e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204e49d556fa517b1743ebb9f33e03c">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fdee25be411d0ec8e749ffba3be75f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdee25be411d0ec8e749ffba3be75f3">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72ab46edf10382483aaf7aa8269b1226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ab46edf10382483aaf7aa8269b1226">&#9670;&nbsp;</a></span>async_connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>return_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d19acddedbef9a64b2ec8508a17682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d19acddedbef9a64b2ec8508a17682">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a06ab65cd7becb1b9b44ee72d7dacf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a06ab65cd7becb1b9b44ee72d7dacf7">&#9670;&nbsp;</a></span>async_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a7a66426c7ca0cb1df2fec65422520f8f" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc287ecee410ea22bdbfa616db54df43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc287ecee410ea22bdbfa616db54df43">&#9670;&nbsp;</a></span>async_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_pingreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25a428a359046dfe9a540242511e9250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a428a359046dfe9a540242511e9250">&#9670;&nbsp;</a></span>async_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_pingresp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaecd89e70dce3bb55113fad4d3ed5acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecd89e70dce3bb55113fad4d3ed5acc">&#9670;&nbsp;</a></span>async_puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f544b9f7fbf8759705a1c2cd5a73806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f544b9f7fbf8759705a1c2cd5a73806">&#9670;&nbsp;</a></span>async_pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be37fcf6346a73fa386b67d429ea44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be37fcf6346a73fa386b67d429ea44e">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a22f9afa6ff14808036e69eec8b91ad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f9afa6ff14808036e69eec8b91ad9c">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a73f09fbd7cf18123f1e897400fdb023a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f09fbd7cf18123f1e897400fdb023a">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a86026e50fd148d4e60705eff1a36a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86026e50fd148d4e60705eff1a36a330">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a588539439be14827780eebe9304317e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588539439be14827780eebe9304317e8">&#9670;&nbsp;</a></span>async_publish_at_most_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81609f8496159dda50134d14fcc1be41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81609f8496159dda50134d14fcc1be41">&#9670;&nbsp;</a></span>async_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a7831370898d790df41a86a3447ddacf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7831370898d790df41a86a3447ddacf4">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a536d2f27be063d34080fc889ca3ea072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536d2f27be063d34080fc889ca3ea072">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="af9fbb9b2a24b1279609e928412789a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fbb9b2a24b1279609e928412789a18">&#9670;&nbsp;</a></span>async_pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b3feba2ba6694e2ff1ac5707a5f478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b3feba2ba6694e2ff1ac5707a5f478">&#9670;&nbsp;</a></span>async_pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a480e1eda72cf9b7895a78d96fccae85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480e1eda72cf9b7895a78d96fccae85c">&#9670;&nbsp;</a></span>async_read_control_packet_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_read_control_packet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a922ccfb8400aab0cf18b91383c390c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922ccfb8400aab0cf18b91383c390c2a">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0 &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>args should be some qos corresponding to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25b209a0452e933289cb3b72c55a1f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b209a0452e933289cb3b72c55a1f76">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41e563c28cd4588eb9cb3ba6c8ba0605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e563c28cd4588eb9cb3ba6c8ba0605">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>qoss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa456b3191a05384dca0b9ed2c76442e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa456b3191a05384dca0b9ed2c76442e8">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, std::uint16_t &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be some pairs of topic_name and qos to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a58cd6bc5d779c2da5c1d7d408cf3aeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cd6bc5d779c2da5c1d7d408cf3aeb4">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a96332b86a1bfd1fb25eac840466d90da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96332b86a1bfd1fb25eac840466d90da">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a4eb668cf9e4b21f5953293162689bf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb668cf9e4b21f5953293162689bf4a">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, bool &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="a6acca900fb6ba308b37c6a1d259ccad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acca900fb6ba308b37c6a1d259ccad7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="aa0892ce95d342bed4e4ce7bc8147b6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0892ce95d342bed4e4ce7bc8147b6d0">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="aa0e96e19f39cfc3a1b5dbbee4d4f02a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e96e19f39cfc3a1b5dbbee4d4f02a2">&#9670;&nbsp;</a></span>async_unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5141f47024f3fe791ca1ee9b91b11468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5141f47024f3fe791ca1ee9b91b11468">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, std::uint16_t &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names to unsubscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a0dbdde4ded4a87b36e3a583787150f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbdde4ded4a87b36e3a583787150f51">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a5e9ce485692af230f3436fee4c7ef41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9ce485692af230f3436fee4c7ef41c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a0b4046e8b41b7efdaa0149078825338d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4046e8b41b7efdaa0149078825338d">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, bool &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names to unsubscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a8d4499fa72e042cb0272a657b64a7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4499fa72e042cb0272a657b64a7ed6">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a78a1bab156b7281193e9f6015fec546a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a1bab156b7281193e9f6015fec546a">&#9670;&nbsp;</a></span>clear_stored_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::clear_stored_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd80a5218013143a28ebb9623d7760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd80a5218013143a28ebb9623d7760f">&#9670;&nbsp;</a></span>connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>return_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256</a> See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe841052b0b07878b8f41d35e56a0828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe841052b0b07878b8f41d35e56a0828">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238</a> See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf91466fe31d4a409cf1406102363995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf91466fe31d4a409cf1406102363995">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a66426c7ca0cb1df2fec65422520f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a66426c7ca0cb1df2fec65422520f8f">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a7a66426c7ca0cb1df2fec65422520f8f" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
 </p>

</div>
</div>
<a id="a0c010c110cebb405cd33aabeddf5e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c010c110cebb405cd33aabeddf5e10f">&#9670;&nbsp;</a></span>for_each_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada2e5fc04cc1162365d8c63b29dd016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2e5fc04cc1162365d8c63b29dd016c">&#9670;&nbsp;</a></span>force_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::force_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#ada2e5fc04cc1162365d8c63b29dd016c" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
 </p>

</div>
</div>
<a id="a5fa15ba94d7f94f37b7bd8dc35fd3c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa15ba94d7f94f37b7bd8dc35fd3c5a">&#9670;&nbsp;</a></span>handle_close_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::handle_close_or_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a717c3ffaa30c1102b5d293c97533324f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717c3ffaa30c1102b5d293c97533324f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8421e3230f596187014080dabf78f75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8421e3230f596187014080dabf78f75e">&#9670;&nbsp;</a></span>pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a>. </p>

</div>
</div>
<a id="a100ce8fd880e5e5ebeba6e70b33bcc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100ce8fd880e5e5ebeba6e70b33bcc2a">&#9670;&nbsp;</a></span>pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a>. </p>

</div>
</div>
<a id="a777bcc7a429a14d280f02cf6568c7041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777bcc7a429a14d280f02cf6568c7041">&#9670;&nbsp;</a></span>puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::puback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a>. </p>

</div>
</div>
<a id="ab65a0434feaff1f020f75b174b63c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65a0434feaff1f020f75b174b63c8a8">&#9670;&nbsp;</a></span>pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::pubcomp </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a>. </p>

</div>
</div>
<a id="a328b9a76013c7181420797c9ab9d2214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328b9a76013c7181420797c9ab9d2214">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a6f66fc5265ad392558bf0c3067324531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f66fc5265ad392558bf0c3067324531">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a4739bf14e854b1e14f6b8d02bcb2876f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4739bf14e854b1e14f6b8d02bcb2876f">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="adea818ea0928213d54f571b7b71f78dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea818ea0928213d54f571b7b71f78dc">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ad1cfde06227d8ef3e4ac7c391dd4649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cfde06227d8ef3e4ac7c391dd4649e">&#9670;&nbsp;</a></span>publish_at_most_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad661ea2957ceda98efd0cc2a486bbd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661ea2957ceda98efd0cc2a486bbd42">&#9670;&nbsp;</a></span>publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ac1398030f3f7c6c6743d6ad9de0ae65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1398030f3f7c6c6743d6ad9de0ae65b">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a8ff02dfe9d10e5bd92779b22ad5b866e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff02dfe9d10e5bd92779b22ad5b866e">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a8f38026671e867a67dc539aa1b4ea149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f38026671e867a67dc539aa1b4ea149">&#9670;&nbsp;</a></span>pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::pubrec </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a>. </p>

</div>
</div>
<a id="a2e3cb58db8b272192922190cc259936c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3cb58db8b272192922190cc259936c">&#9670;&nbsp;</a></span>pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::pubrel </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a>. </p>

</div>
</div>
<a id="ab688d9c2c343e4facde63a33f51e25a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab688d9c2c343e4facde63a33f51e25a8">&#9670;&nbsp;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98f88ab5de17646da38f5a2431721159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f88ab5de17646da38f5a2431721159">&#9670;&nbsp;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ff3b8838f85a217a690e5adcd0d1c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff3b8838f85a217a690e5adcd0d1c7a">&#9670;&nbsp;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set auto publish response mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>set value</td></tr>
  </table>
  </dd>
</dl>
<p>When set auto publish response mode to true, puback, pubrec, pubrel,and pub comp automatically send.<br />
 </p>

</div>
</div>
<a id="a3bceb4fd28a4842b56a09cb5e5fecbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bceb4fd28a4842b56a09cb5e5fecbe7">&#9670;&nbsp;</a></span>set_clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_clean_session </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set clean session. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>clean session</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029</a><br />
 3.1.2.4 Clean Session<br />
 After constructing a endpoint, the clean session is set to false. </p>

</div>
</div>
<a id="a5291b48d933fa8f48db17903de48f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5291b48d933fa8f48db17903de48f7cb">&#9670;&nbsp;</a></span>set_client_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_client_id </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set endpoint id. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>endpoint id</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.1 Client Identifier </p>

</div>
</div>
<a id="ae2324d7ba670c34bd0ea9c59139d38fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2324d7ba670c34bd0ea9c59139d38fb">&#9670;&nbsp;</a></span>set_close_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_close_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a364af867678842e91c1b32dec2a41367">close_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set close handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a75def55f0ef79ec36401a1c401695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a75def55f0ef79ec36401a1c401695">&#9670;&nbsp;</a></span>set_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_connack_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a6e2db4cf296282078f39ea56402b0ef5">connack_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb1f225431a73fd4af23ef5fde573015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1f225431a73fd4af23ef5fde573015">&#9670;&nbsp;</a></span>set_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b7b3797009df1b4c58bef6f1c4e4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b7b3797009df1b4c58bef6f1c4e4b9">&#9670;&nbsp;</a></span>set_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_connect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a09735fb1fb557054eb5e64c4fcdb51e5">connect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf74f6b98a43f065551647889d9bf507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf74f6b98a43f065551647889d9bf507">&#9670;&nbsp;</a></span>set_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_disconnect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#abd7c3f10ad78e6c698d6bbfef6711c3b">disconnect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set disconnect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be7c8d8c65f6e101088dc9f0db6261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be7c8d8c65f6e101088dc9f0db6261d">&#9670;&nbsp;</a></span>set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aecb3fdaee0e81d37bebb9a151e039ccf">error_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set error handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c44bf215bc14d93a5ef1802130f9602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c44bf215bc14d93a5ef1802130f9602">&#9670;&nbsp;</a></span>set_password()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_password </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set password. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>password</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.5 Password </p>

</div>
</div>
<a id="a46d2440d99026210a3df92ad2d98e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d2440d99026210a3df92ad2d98e197">&#9670;&nbsp;</a></span>set_pingreq_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pingreq_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a6c370dcf0b186feb08dce27aeffdaf92">pingreq_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingreq handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fd064ab73c70309c164d7660b8b4c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd064ab73c70309c164d7660b8b4c2b">&#9670;&nbsp;</a></span>set_pingresp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pingresp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0c3ac60054f4c091c07ddc54b565fbac">pingresp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingresp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29aeb6d564015de6a35c9fec7180910d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aeb6d564015de6a35c9fec7180910d">&#9670;&nbsp;</a></span>set_pub_res_sent_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pub_res_sent_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad19bd5db5bf78fc249c4846716fb1b11">pub_res_sent_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ff41688bb7c646e49b9b453082a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ff41688bb7c646e49b9b453082a0b3">&#9670;&nbsp;</a></span>set_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_puback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aebda47243d8f43b27b4ec3e5d1361ba9">puback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae85b61e3a087e6668797ad269b52467e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85b61e3a087e6668797ad269b52467e">&#9670;&nbsp;</a></span>set_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pubcomp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a18af7ad4e07dbe398a0d75eb4c4ccfcd">pubcomp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0a85da3750bf33f92ebf754128d25a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a85da3750bf33f92ebf754128d25a0">&#9670;&nbsp;</a></span>set_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_publish_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#af733e4f7cf8c99f81f9df87e3136f4fc">publish_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb309bc9a2b42206b3a4b77f31a7d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb309bc9a2b42206b3a4b77f31a7d64">&#9670;&nbsp;</a></span>set_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pubrec_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a2c7b758532793dd312300f2865bc33d7">pubrec_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96c65a8e44cb53fc11fd87a37b3e6f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c65a8e44cb53fc11fd87a37b3e6f14">&#9670;&nbsp;</a></span>set_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_pubrel_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ac8fa6923cbee75e2ae2e15e240eee4e9">pubrel_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f0eb0d98dcc1dc7feda6b8ba8dbca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f0eb0d98dcc1dc7feda6b8ba8dbca6">&#9670;&nbsp;</a></span>set_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_suback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a8523cd39c11406669dd46bde2ba5b3f0">suback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a336a1b0be761cea662fa58e68889e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336a1b0be761cea662fa58e68889e71a">&#9670;&nbsp;</a></span>set_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_subscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a2f2c91b53ab913165efe9e2d87b7607a">subscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e543946cd51cdcd7c2114b10302d272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e543946cd51cdcd7c2114b10302d272">&#9670;&nbsp;</a></span>set_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_unsuback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ab5df280004bb38ce2aff3b0dd415f807">unsuback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8b56791dd5a42146af701bac9a89498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b56791dd5a42146af701bac9a89498">&#9670;&nbsp;</a></span>set_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#af63219b61745484e9bb0fe07a764a9a9">unsubscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4334acb6ead803c6248f6f3d7795a4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4334acb6ead803c6248f6f3d7795a4dc">&#9670;&nbsp;</a></span>set_user_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_user_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set username. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>username</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.4 User Name </p>

</div>
</div>
<a id="a5d430aa25b01e26cb33cefea88d7dc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d430aa25b01e26cb33cefea88d7dc35">&#9670;&nbsp;</a></span>set_will()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::set_will </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1will.html">will</a>&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>will</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#afe841052b0b07878b8f41d35e56a0828" title="Send connect packet. ">connect()</a>.<br />
 'will' would be send when endpoint is disconnected without calling <a class="el" href="classmqtt_1_1endpoint.html#a7a66426c7ca0cb1df2fec65422520f8f" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>. </p>

</div>
</div>
<a id="a739ee2cca2ee28fccf8e8d4e5c5c390a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739ee2cca2ee28fccf8e8d4e5c5c390a">&#9670;&nbsp;</a></span>socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt;&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a768a7cc95b98b9999d604bc01f9d185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768a7cc95b98b9999d604bc01f9d185a">&#9670;&nbsp;</a></span>socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt; const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a2a0ec0c64d6d29ba8ca85a92a07a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a0ec0c64d6d29ba8ca85a92a07a91">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::start_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a63b9e9bbefcc4b42a15938ff068e43d7">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start session with a connected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>finish handler that is called when the session is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73813c553db44cc4f86134702ca7ea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73813c553db44cc4f86134702ca7ea20">&#9670;&nbsp;</a></span>suback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos  args additional qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>. </p>

</div>
</div>
<a id="aeca85b157b4e04da873c908bf0a0ea85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca85b157b4e04da873c908bf0a0ea85">&#9670;&nbsp;</a></span>suback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>qoss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>. </p>

</div>
</div>
<a id="a272ea8a134a7cb833716839fe5022509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272ea8a134a7cb833716839fe5022509">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a49af37cdb24aaf9b8dd7a691193f21e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49af37cdb24aaf9b8dd7a691193f21e6">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a5caaefa0ba92c4529f155994d6bf312f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caaefa0ba92c4529f155994d6bf312f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="a795cbaa17a01b4e7e809c5fd885f0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795cbaa17a01b4e7e809c5fd885f0659">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="a97641bb6d27784043e3dc62b3b022018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641bb6d27784043e3dc62b3b022018">&#9670;&nbsp;</a></span>unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a>. </p>

</div>
</div>
<a id="a7972a671a4d3f71e5f22454c1035997b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7972a671a4d3f71e5f22454c1035997b">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a0a005460e0e0095a0a31ef9ff7b28a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a005460e0e0095a0a31ef9ff7b28a0e">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a55f2c14597dced6b072408053386d3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f2c14597dced6b072408053386d3a5">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="ac4f92d7dddfb0179a1ab3246ee1f9623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f92d7dddfb0179a1ab3246ee1f9623">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Strand, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Strand, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/mqtt_client_cpp/include/mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
