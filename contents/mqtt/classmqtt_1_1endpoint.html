<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mqtt_cpp: mqtt::endpoint&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mqtt_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemqtt.html">mqtt</a></li><li class="navelem"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmqtt_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::endpoint&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mqtt::endpoint&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmqtt_1_1endpoint__inherit__graph.png" border="0" usemap="#mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map" id="mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_inherit__map">
<area shape="rect"  title=" " alt="" coords="264,20,523,61"/>
<area shape="rect"  title=" " alt="" coords="5,5,216,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mqtt::endpoint&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmqtt_1_1endpoint__coll__graph.png" border="0" usemap="#mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map" id="mqtt_1_1endpoint_3_01Socket_00_01Mutex_00_01LockGuard_00_01PacketIdBytes_01_4_coll__map">
<area shape="rect"  title=" " alt="" coords="264,20,523,61"/>
<area shape="rect"  title=" " alt="" coords="5,5,216,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3b0c60837d4b3509b8d76475ffcc258b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:a3b0c60837d4b3509b8d76475ffcc258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564cd0242f23b05aaf94e65ad7effd3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> = typename <a class="el" href="structmqtt_1_1packet__id__type.html">packet_id_type</a>&lt; PacketIdBytes &gt;::type</td></tr>
<tr class="separator:a564cd0242f23b05aaf94e65ad7effd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d6bdb586acc735d5c784196094c361"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="memdesc:aa0d6bdb586acc735d5c784196094c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br />
 3.13 PINGREQ – PING request.  <a href="#aa0d6bdb586acc735d5c784196094c361">More...</a><br /></td></tr>
<tr class="separator:aa0d6bdb586acc735d5c784196094c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb95a7462c4a8466c63c860978b2d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="memdesc:ad1bb95a7462c4a8466c63c860978b2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pingresp handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a><br />
 3.13 PINGRESP – PING response.  <a href="#ad1bb95a7462c4a8466c63c860978b2d9">More...</a><br /></td></tr>
<tr class="separator:ad1bb95a7462c4a8466c63c860978b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd6c11f298bc4860cd0739febdbe634"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a> = std::function&lt; bool(std::string const  &amp;client_id, mqtt::optional&lt; std::string &gt; const  &amp;username, mqtt::optional&lt; std::string &gt; const  &amp;password, mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#a4959f781bc2fbb20a64bc67629b40ddf">clean_session</a>, std::uint16_t keep_alive)&gt;</td></tr>
<tr class="memdesc:acdd6c11f298bc4860cd0739febdbe634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect handler.  <a href="#acdd6c11f298bc4860cd0739febdbe634">More...</a><br /></td></tr>
<tr class="separator:acdd6c11f298bc4860cd0739febdbe634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4550598ca356a864d9c6ba430ecea5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a> = std::function&lt; bool(bool session_present, std::uint8_t return_code)&gt;</td></tr>
<tr class="memdesc:aee4550598ca356a864d9c6ba430ecea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connack handler.  <a href="#aee4550598ca356a864d9c6ba430ecea5">More...</a><br /></td></tr>
<tr class="separator:aee4550598ca356a864d9c6ba430ecea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191dc1774a8eab18da4bfa9f84029e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a> = std::function&lt; bool(std::uint8_t fixed_header, mqtt::optional&lt; <a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> &gt; packet_id, std::string topic_name, std::string contents)&gt;</td></tr>
<tr class="memdesc:a9191dc1774a8eab18da4bfa9f84029e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish handler.  <a href="#a9191dc1774a8eab18da4bfa9f84029e4">More...</a><br /></td></tr>
<tr class="separator:a9191dc1774a8eab18da4bfa9f84029e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21324ca4cb279339cf739bef07007182"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:a21324ca4cb279339cf739bef07007182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puback handler.  <a href="#a21324ca4cb279339cf739bef07007182">More...</a><br /></td></tr>
<tr class="separator:a21324ca4cb279339cf739bef07007182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c00e6f461f7eaa6f1b61f2011e203b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:ab1c00e6f461f7eaa6f1b61f2011e203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrec handler.  <a href="#ab1c00e6f461f7eaa6f1b61f2011e203b">More...</a><br /></td></tr>
<tr class="separator:ab1c00e6f461f7eaa6f1b61f2011e203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068ab8287621c9facae754d58e1e9e90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:a068ab8287621c9facae754d58e1e9e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrel handler.  <a href="#a068ab8287621c9facae754d58e1e9e90">More...</a><br /></td></tr>
<tr class="separator:a068ab8287621c9facae754d58e1e9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cfc609fd1a72bfe4594d9f0a7d42a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:a97cfc609fd1a72bfe4594d9f0a7d42a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubcomp handler.  <a href="#a97cfc609fd1a72bfe4594d9f0a7d42a8">More...</a><br /></td></tr>
<tr class="separator:a97cfc609fd1a72bfe4594d9f0a7d42a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4209361313b60fc85a657c9109a91231"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt; &gt; entries)&gt;</td></tr>
<tr class="memdesc:a4209361313b60fc85a657c9109a91231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe handler.  <a href="#a4209361313b60fc85a657c9109a91231">More...</a><br /></td></tr>
<tr class="separator:a4209361313b60fc85a657c9109a91231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e70c3f92c2e16a66b3287bc5349da5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; mqtt::optional&lt; std::uint8_t &gt; &gt; qoss)&gt;</td></tr>
<tr class="memdesc:a5e70c3f92c2e16a66b3287bc5349da5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suback handler.  <a href="#a5e70c3f92c2e16a66b3287bc5349da5a">More...</a><br /></td></tr>
<tr class="separator:a5e70c3f92c2e16a66b3287bc5349da5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38cdc0242dbbe0516e391434250c15e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; topics)&gt;</td></tr>
<tr class="memdesc:ae38cdc0242dbbe0516e391434250c15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe handler.  <a href="#ae38cdc0242dbbe0516e391434250c15e">More...</a><br /></td></tr>
<tr class="separator:ae38cdc0242dbbe0516e391434250c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb934072e5052d34fdc5810b1abe8d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>)&gt;</td></tr>
<tr class="memdesc:a1cb934072e5052d34fdc5810b1abe8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsuback handler.  <a href="#a1cb934072e5052d34fdc5810b1abe8d0">More...</a><br /></td></tr>
<tr class="separator:a1cb934072e5052d34fdc5810b1abe8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad197af50cca897a66b5b569342145042"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:ad197af50cca897a66b5b569342145042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463</a><br />
 3.14 DISCONNECT – Disconnect notification.  <a href="#ad197af50cca897a66b5b569342145042">More...</a><br /></td></tr>
<tr class="separator:ad197af50cca897a66b5b569342145042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632d951eddb30b18108d6bc4dbac81c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a> = std::function&lt; bool(std::string const  &amp;client_id, mqtt::optional&lt; std::string &gt; const  &amp;username, mqtt::optional&lt; std::string &gt; const  &amp;password, mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#afb1dff57ee4ebe5e9b17f70354772d0c">clean_start</a>, std::uint16_t keep_alive, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a632d951eddb30b18108d6bc4dbac81c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect handler.  <a href="#a632d951eddb30b18108d6bc4dbac81c0">More...</a><br /></td></tr>
<tr class="separator:a632d951eddb30b18108d6bc4dbac81c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030b892a8e24eb83a322ee336d411f36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a> = std::function&lt; bool(bool session_present, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a030b892a8e24eb83a322ee336d411f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connack handler.  <a href="#a030b892a8e24eb83a322ee336d411f36">More...</a><br /></td></tr>
<tr class="separator:a030b892a8e24eb83a322ee336d411f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05b370879b50e3c87fdaf131d587a78"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a> = std::function&lt; bool(std::uint8_t fixed_header, mqtt::optional&lt; <a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> &gt; packet_id, std::string topic_name, std::string contents, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:af05b370879b50e3c87fdaf131d587a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish handler.  <a href="#af05b370879b50e3c87fdaf131d587a78">More...</a><br /></td></tr>
<tr class="separator:af05b370879b50e3c87fdaf131d587a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae1974ed82284cd8deb9f5597b5e56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a7eae1974ed82284cd8deb9f5597b5e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puback handler.  <a href="#a7eae1974ed82284cd8deb9f5597b5e56">More...</a><br /></td></tr>
<tr class="separator:a7eae1974ed82284cd8deb9f5597b5e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70bfc06f9c5a565c23380c55ada5ae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:ae70bfc06f9c5a565c23380c55ada5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrec handler.  <a href="#ae70bfc06f9c5a565c23380c55ada5ae4">More...</a><br /></td></tr>
<tr class="separator:ae70bfc06f9c5a565c23380c55ada5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac700f606579048afc30e571f71514836"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:ac700f606579048afc30e571f71514836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubrel handler.  <a href="#ac700f606579048afc30e571f71514836">More...</a><br /></td></tr>
<tr class="separator:ac700f606579048afc30e571f71514836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10847e9fe9331cd8ce1fc8a16dba18e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a10847e9fe9331cd8ce1fc8a16dba18e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pubcomp handler.  <a href="#a10847e9fe9331cd8ce1fc8a16dba18e3">More...</a><br /></td></tr>
<tr class="separator:a10847e9fe9331cd8ce1fc8a16dba18e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbcb705b084e7a61e5c54145a636fab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt; &gt; entries, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a1fbcb705b084e7a61e5c54145a636fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe handler.  <a href="#a1fbcb705b084e7a61e5c54145a636fab">More...</a><br /></td></tr>
<tr class="separator:a1fbcb705b084e7a61e5c54145a636fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5885dff8fbe5e74fdf99d1cd77d5293"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:af5885dff8fbe5e74fdf99d1cd77d5293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suback handler.  <a href="#af5885dff8fbe5e74fdf99d1cd77d5293">More...</a><br /></td></tr>
<tr class="separator:af5885dff8fbe5e74fdf99d1cd77d5293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65060d5a517664f63899fcfcc5f39607"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; topics, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a65060d5a517664f63899fcfcc5f39607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe handler.  <a href="#a65060d5a517664f63899fcfcc5f39607">More...</a><br /></td></tr>
<tr class="separator:a65060d5a517664f63899fcfcc5f39607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb50e8b139acb089940258c841731278"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:abb50e8b139acb089940258c841731278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsuback handler.  <a href="#abb50e8b139acb089940258c841731278">More...</a><br /></td></tr>
<tr class="separator:abb50e8b139acb089940258c841731278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9d8e8241a0a01307717ce9cac2135e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a> = std::function&lt; void(std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:a2e9d8e8241a0a01307717ce9cac2135e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br />
 3.14 DISCONNECT – Disconnect notification.  <a href="#a2e9d8e8241a0a01307717ce9cac2135e">More...</a><br /></td></tr>
<tr class="separator:a2e9d8e8241a0a01307717ce9cac2135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec77935e0706fd72187b340a1a8d4d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a> = std::function&lt; bool(std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props) &gt;</td></tr>
<tr class="memdesc:acec77935e0706fd72187b340a1a8d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auth handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217</a><br />
 3.15 AUTH – Authentication exchange.  <a href="#acec77935e0706fd72187b340a1a8d4d5">More...</a><br /></td></tr>
<tr class="separator:acec77935e0706fd72187b340a1a8d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a838b7bc8f903e00c05a725d015165"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:ae7a838b7bc8f903e00c05a725d015165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close handler.  <a href="#ae7a838b7bc8f903e00c05a725d015165">More...</a><br /></td></tr>
<tr class="separator:ae7a838b7bc8f903e00c05a725d015165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48f7b609189aa01111d2b5dc33ac80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="memdesc:aac48f7b609189aa01111d2b5dc33ac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handler.  <a href="#aac48f7b609189aa01111d2b5dc33ac80">More...</a><br /></td></tr>
<tr class="separator:aac48f7b609189aa01111d2b5dc33ac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b07e4580973cd48becf78b4ea289ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:a56b07e4580973cd48becf78b4ea289ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2.  <a href="#a56b07e4580973cd48becf78b4ea289ac">More...</a><br /></td></tr>
<tr class="separator:a56b07e4580973cd48becf78b4ea289ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa1defa357702169040bfc7b16fa54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a> = std::function&lt; void(basic_publish_message&lt; PacketIdBytes &gt; msg)&gt;</td></tr>
<tr class="memdesc:a3cfa1defa357702169040bfc7b16fa54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#a3cfa1defa357702169040bfc7b16fa54">More...</a><br /></td></tr>
<tr class="separator:a3cfa1defa357702169040bfc7b16fa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5737b8a9b39dbe81c74ff2e28ffe492"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt; msg)&gt;</td></tr>
<tr class="memdesc:ae5737b8a9b39dbe81c74ff2e28ffe492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#ae5737b8a9b39dbe81c74ff2e28ffe492">More...</a><br /></td></tr>
<tr class="separator:ae5737b8a9b39dbe81c74ff2e28ffe492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08d527a83ba699572cb14a4294b392"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, char const  *data, std::size_t <a class="el" href="namespacemqtt.html#aa24e4521fa74b1a541b17ef757e22906">size</a>)&gt;</td></tr>
<tr class="memdesc:a7c08d527a83ba699572cb14a4294b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#a7c08d527a83ba699572cb14a4294b392">More...</a><br /></td></tr>
<tr class="separator:a7c08d527a83ba699572cb14a4294b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f6de4972fb8a792fae5000c340d969"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a> = std::function&lt; void(basic_pubrel_message&lt; PacketIdBytes &gt; msg)&gt;</td></tr>
<tr class="memdesc:ab5f6de4972fb8a792fae5000c340d969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#ab5f6de4972fb8a792fae5000c340d969">More...</a><br /></td></tr>
<tr class="separator:ab5f6de4972fb8a792fae5000c340d969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e3f811f69990b8be27e681e00e414c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a> = std::function&lt; void(<a class="el" href="structmqtt_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg)&gt;</td></tr>
<tr class="memdesc:a25e3f811f69990b8be27e681e00e414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#a25e3f811f69990b8be27e681e00e414c">More...</a><br /></td></tr>
<tr class="separator:a25e3f811f69990b8be27e681e00e414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753823cea6186f17d19f50b61f706eec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, char const  *data, std::size_t <a class="el" href="namespacemqtt.html#aa24e4521fa74b1a541b17ef757e22906">size</a>)&gt;</td></tr>
<tr class="memdesc:a753823cea6186f17d19f50b61f706eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>.  <a href="#a753823cea6186f17d19f50b61f706eec">More...</a><br /></td></tr>
<tr class="separator:a753823cea6186f17d19f50b61f706eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ad8841aa15503d13798ee9f682cba1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td></tr>
<tr class="memdesc:ae5ad8841aa15503d13798ee9f682cba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove serialized message.  <a href="#ae5ad8841aa15503d13798ee9f682cba1">More...</a><br /></td></tr>
<tr class="separator:ae5ad8841aa15503d13798ee9f682cba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529c52ec7d0ff059cc8bf07c30cfe4e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:a529c52ec7d0ff059cc8bf07c30cfe4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-send handler This handler is called when any mqtt control packet is decided to send.  <a href="#a529c52ec7d0ff059cc8bf07c30cfe4e8">More...</a><br /></td></tr>
<tr class="separator:a529c52ec7d0ff059cc8bf07c30cfe4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2715b79875b9b659721ccd712bbd28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a> = std::function&lt; bool(std::uint8_t control_packet_type, std::size_t <a class="el" href="namespacemqtt.html#aca02f83807fbe2a21419cf6013cfc4aa">remaining_length</a>)&gt;</td></tr>
<tr class="memdesc:a0a2715b79875b9b659721ccd712bbd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">is valid length handler This handler is called when remaining length is received.  <a href="#a0a2715b79875b9b659721ccd712bbd28">More...</a><br /></td></tr>
<tr class="separator:a0a2715b79875b9b659721ccd712bbd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac296e84701849b0309bbe33616314744"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a> = std::function&lt; void(<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func)&gt;</td></tr>
<tr class="memdesc:ac296e84701849b0309bbe33616314744"><td class="mdescLeft">&#160;</td><td class="mdescRight">next read handler This handler is called when the current mqtt message has been processed.  <a href="#ac296e84701849b0309bbe33616314744">More...</a><br /></td></tr>
<tr class="separator:ac296e84701849b0309bbe33616314744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a961a875c2704582bda9a2bc96568d53c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a961a875c2704582bda9a2bc96568d53c">endpoint</a> (<a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a> version=<a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>)</td></tr>
<tr class="memdesc:a961a875c2704582bda9a2bc96568d53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for client.  <a href="#a961a875c2704582bda9a2bc96568d53c">More...</a><br /></td></tr>
<tr class="separator:a961a875c2704582bda9a2bc96568d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4a6f112dfee3007e3fc2d44ec24f48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aea4a6f112dfee3007e3fc2d44ec24f48">endpoint</a> (std::unique_ptr&lt; Socket &gt; <a class="el" href="classmqtt_1_1endpoint.html#a343315ef280f69efadc7be61fe658909">socket</a>, <a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a> version=<a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a>)</td></tr>
<tr class="memdesc:aea4a6f112dfee3007e3fc2d44ec24f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for server. socket should have already been connected with another endpoint.  <a href="#aea4a6f112dfee3007e3fc2d44ec24f48">More...</a><br /></td></tr>
<tr class="separator:aea4a6f112dfee3007e3fc2d44ec24f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1cc09e00f54e16e1655851fb544a68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acf1cc09e00f54e16e1655851fb544a68">endpoint</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:acf1cc09e00f54e16e1655851fb544a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eddccd2328ef084fb5efb3f2edb1a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a83eddccd2328ef084fb5efb3f2edb1a3">endpoint</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a83eddccd2328ef084fb5efb3f2edb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16667e5dc589cdfdaa218ebfdfac5d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a16667e5dc589cdfdaa218ebfdfac5d6a">operator=</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:a16667e5dc589cdfdaa218ebfdfac5d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4092561fca03e915f102636ef86c8f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4092561fca03e915f102636ef86c8f57">operator=</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a4092561fca03e915f102636ef86c8f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4959f781bc2fbb20a64bc67629b40ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4959f781bc2fbb20a64bc67629b40ddf">clean_session</a> () const</td></tr>
<tr class="memdesc:a4959f781bc2fbb20a64bc67629b40ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean session.  <a href="#a4959f781bc2fbb20a64bc67629b40ddf">More...</a><br /></td></tr>
<tr class="separator:a4959f781bc2fbb20a64bc67629b40ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1dff57ee4ebe5e9b17f70354772d0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afb1dff57ee4ebe5e9b17f70354772d0c">clean_start</a> () const</td></tr>
<tr class="memdesc:afb1dff57ee4ebe5e9b17f70354772d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clean start.  <a href="#afb1dff57ee4ebe5e9b17f70354772d0c">More...</a><br /></td></tr>
<tr class="separator:afb1dff57ee4ebe5e9b17f70354772d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c24deff5585866eb79b9e66e2629d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac5c24deff5585866eb79b9e66e2629d6">set_auto_pub_response</a> (bool b=true, bool async=true)</td></tr>
<tr class="memdesc:ac5c24deff5585866eb79b9e66e2629d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set auto publish response mode.  <a href="#ac5c24deff5585866eb79b9e66e2629d6">More...</a><br /></td></tr>
<tr class="separator:ac5c24deff5585866eb79b9e66e2629d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d1ea159fc6368d4ac01be528d81eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a32d1ea159fc6368d4ac01be528d81eb7">set_pingreq_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a>())</td></tr>
<tr class="memdesc:a32d1ea159fc6368d4ac01be528d81eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingreq handler.  <a href="#a32d1ea159fc6368d4ac01be528d81eb7">More...</a><br /></td></tr>
<tr class="separator:a32d1ea159fc6368d4ac01be528d81eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0822d2b2f95d48f35d651a6024ade705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0822d2b2f95d48f35d651a6024ade705">set_pingresp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a>())</td></tr>
<tr class="memdesc:a0822d2b2f95d48f35d651a6024ade705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingresp handler.  <a href="#a0822d2b2f95d48f35d651a6024ade705">More...</a><br /></td></tr>
<tr class="separator:a0822d2b2f95d48f35d651a6024ade705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c39872a0536fd810f6de35913d553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af21c39872a0536fd810f6de35913d553">get_pingreq_handler</a> () const</td></tr>
<tr class="memdesc:af21c39872a0536fd810f6de35913d553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pingreq handler.  <a href="#af21c39872a0536fd810f6de35913d553">More...</a><br /></td></tr>
<tr class="separator:af21c39872a0536fd810f6de35913d553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cf126dc8ec6d16610b3b1cdc750bbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a78cf126dc8ec6d16610b3b1cdc750bbd">get_pingresp_handler</a> () const</td></tr>
<tr class="memdesc:a78cf126dc8ec6d16610b3b1cdc750bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pingresp handler.  <a href="#a78cf126dc8ec6d16610b3b1cdc750bbd">More...</a><br /></td></tr>
<tr class="separator:a78cf126dc8ec6d16610b3b1cdc750bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7991849053391086331329214cc6fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad7991849053391086331329214cc6fef">set_connect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a>())</td></tr>
<tr class="memdesc:ad7991849053391086331329214cc6fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connect handler.  <a href="#ad7991849053391086331329214cc6fef">More...</a><br /></td></tr>
<tr class="separator:ad7991849053391086331329214cc6fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c59c267632d2310994214a3491fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6b4c59c267632d2310994214a3491fcc">set_connack_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a>())</td></tr>
<tr class="memdesc:a6b4c59c267632d2310994214a3491fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connack handler.  <a href="#a6b4c59c267632d2310994214a3491fcc">More...</a><br /></td></tr>
<tr class="separator:a6b4c59c267632d2310994214a3491fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea5620671a58af756f88c97a565baa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abea5620671a58af756f88c97a565baa2">set_publish_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a>())</td></tr>
<tr class="memdesc:abea5620671a58af756f88c97a565baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set publish handler.  <a href="#abea5620671a58af756f88c97a565baa2">More...</a><br /></td></tr>
<tr class="separator:abea5620671a58af756f88c97a565baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae70487ff52d27f7d45d21661097520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acae70487ff52d27f7d45d21661097520">set_puback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a>())</td></tr>
<tr class="memdesc:acae70487ff52d27f7d45d21661097520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#acae70487ff52d27f7d45d21661097520">More...</a><br /></td></tr>
<tr class="separator:acae70487ff52d27f7d45d21661097520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a680331c2e7a41eea85aef9345ec51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab6a680331c2e7a41eea85aef9345ec51">set_pubrec_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a>())</td></tr>
<tr class="memdesc:ab6a680331c2e7a41eea85aef9345ec51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrec handler.  <a href="#ab6a680331c2e7a41eea85aef9345ec51">More...</a><br /></td></tr>
<tr class="separator:ab6a680331c2e7a41eea85aef9345ec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813778af548b866f85cbeb73ae0e7996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a813778af548b866f85cbeb73ae0e7996">set_pubrel_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a>())</td></tr>
<tr class="memdesc:a813778af548b866f85cbeb73ae0e7996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrel handler.  <a href="#a813778af548b866f85cbeb73ae0e7996">More...</a><br /></td></tr>
<tr class="separator:a813778af548b866f85cbeb73ae0e7996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631fd18141650364fae8d43c1351c63b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a631fd18141650364fae8d43c1351c63b">set_pubcomp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a>())</td></tr>
<tr class="memdesc:a631fd18141650364fae8d43c1351c63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#a631fd18141650364fae8d43c1351c63b">More...</a><br /></td></tr>
<tr class="separator:a631fd18141650364fae8d43c1351c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ac9c540e7e4546f4779c17fb384a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a19ac9c540e7e4546f4779c17fb384a43">set_subscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a>())</td></tr>
<tr class="memdesc:a19ac9c540e7e4546f4779c17fb384a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subscribe handler.  <a href="#a19ac9c540e7e4546f4779c17fb384a43">More...</a><br /></td></tr>
<tr class="separator:a19ac9c540e7e4546f4779c17fb384a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b4bb03ec5e5cf80618390e9d5a7aa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a95b4bb03ec5e5cf80618390e9d5a7aa1">set_suback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a>())</td></tr>
<tr class="memdesc:a95b4bb03ec5e5cf80618390e9d5a7aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set suback handler.  <a href="#a95b4bb03ec5e5cf80618390e9d5a7aa1">More...</a><br /></td></tr>
<tr class="separator:a95b4bb03ec5e5cf80618390e9d5a7aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecd32bb7334f6dbc2e012ef030bd8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afecd32bb7334f6dbc2e012ef030bd8a3">set_unsubscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a>())</td></tr>
<tr class="memdesc:afecd32bb7334f6dbc2e012ef030bd8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsubscribe handler.  <a href="#afecd32bb7334f6dbc2e012ef030bd8a3">More...</a><br /></td></tr>
<tr class="separator:afecd32bb7334f6dbc2e012ef030bd8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e45217f530112a2af7d9ca20dc86e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa7e45217f530112a2af7d9ca20dc86e9">set_unsuback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a>())</td></tr>
<tr class="memdesc:aa7e45217f530112a2af7d9ca20dc86e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsuback handler.  <a href="#aa7e45217f530112a2af7d9ca20dc86e9">More...</a><br /></td></tr>
<tr class="separator:aa7e45217f530112a2af7d9ca20dc86e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594c81d0aa3c6935bb06aac33909c989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a594c81d0aa3c6935bb06aac33909c989">set_disconnect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a>())</td></tr>
<tr class="memdesc:a594c81d0aa3c6935bb06aac33909c989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set disconnect handler.  <a href="#a594c81d0aa3c6935bb06aac33909c989">More...</a><br /></td></tr>
<tr class="separator:a594c81d0aa3c6935bb06aac33909c989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd386317d159f41b6ab21a28927d192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0bd386317d159f41b6ab21a28927d192">get_connect_handler</a> () const</td></tr>
<tr class="memdesc:a0bd386317d159f41b6ab21a28927d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connect handler.  <a href="#a0bd386317d159f41b6ab21a28927d192">More...</a><br /></td></tr>
<tr class="separator:a0bd386317d159f41b6ab21a28927d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc44cbca5561e4558b4d03c94a617bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aacc44cbca5561e4558b4d03c94a617bb">get_connack_handler</a> () const</td></tr>
<tr class="memdesc:aacc44cbca5561e4558b4d03c94a617bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connack handler.  <a href="#aacc44cbca5561e4558b4d03c94a617bb">More...</a><br /></td></tr>
<tr class="separator:aacc44cbca5561e4558b4d03c94a617bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e567e76a501e1317708ab5989a284a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a69e567e76a501e1317708ab5989a284a">get_publish_handler</a> () const</td></tr>
<tr class="memdesc:a69e567e76a501e1317708ab5989a284a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set publish handler.  <a href="#a69e567e76a501e1317708ab5989a284a">More...</a><br /></td></tr>
<tr class="separator:a69e567e76a501e1317708ab5989a284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7918e800d3927c9ec56d63f3e24da5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7918e800d3927c9ec56d63f3e24da5f3">get_puback_handler</a> () const</td></tr>
<tr class="memdesc:a7918e800d3927c9ec56d63f3e24da5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get puback handler.  <a href="#a7918e800d3927c9ec56d63f3e24da5f3">More...</a><br /></td></tr>
<tr class="separator:a7918e800d3927c9ec56d63f3e24da5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4539bdca9db75ab6bb473b5692ce42c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4539bdca9db75ab6bb473b5692ce42c8">get_pubrec_handler</a> () const</td></tr>
<tr class="memdesc:a4539bdca9db75ab6bb473b5692ce42c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubrec handler.  <a href="#a4539bdca9db75ab6bb473b5692ce42c8">More...</a><br /></td></tr>
<tr class="separator:a4539bdca9db75ab6bb473b5692ce42c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be9a5c119122023caed6a0700f5200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a33be9a5c119122023caed6a0700f5200">get_pubrel_handler</a> () const</td></tr>
<tr class="memdesc:a33be9a5c119122023caed6a0700f5200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubrel handler.  <a href="#a33be9a5c119122023caed6a0700f5200">More...</a><br /></td></tr>
<tr class="separator:a33be9a5c119122023caed6a0700f5200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af863ee97d993e12f4d5465333e29cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5af863ee97d993e12f4d5465333e29cf">get_pubcomp_handler</a> () const</td></tr>
<tr class="memdesc:a5af863ee97d993e12f4d5465333e29cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubcomp handler.  <a href="#a5af863ee97d993e12f4d5465333e29cf">More...</a><br /></td></tr>
<tr class="separator:a5af863ee97d993e12f4d5465333e29cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0c215c287daec36dd5e249d7a034f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9db0c215c287daec36dd5e249d7a034f">get_subscribe_handler</a> () const</td></tr>
<tr class="memdesc:a9db0c215c287daec36dd5e249d7a034f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get subscribe handler.  <a href="#a9db0c215c287daec36dd5e249d7a034f">More...</a><br /></td></tr>
<tr class="separator:a9db0c215c287daec36dd5e249d7a034f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d9880df0f6df5d806ac786272739a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a49d9880df0f6df5d806ac786272739a1">get_suback_handler</a> () const</td></tr>
<tr class="memdesc:a49d9880df0f6df5d806ac786272739a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get suback handler.  <a href="#a49d9880df0f6df5d806ac786272739a1">More...</a><br /></td></tr>
<tr class="separator:a49d9880df0f6df5d806ac786272739a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab313bbd5fe065037be3d890a5bb20180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab313bbd5fe065037be3d890a5bb20180">get_unsubscribe_handler</a> () const</td></tr>
<tr class="memdesc:ab313bbd5fe065037be3d890a5bb20180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get unsubscribe handler.  <a href="#ab313bbd5fe065037be3d890a5bb20180">More...</a><br /></td></tr>
<tr class="separator:ab313bbd5fe065037be3d890a5bb20180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f7dfac2d8e5951d3e9deb06f4ee106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a06f7dfac2d8e5951d3e9deb06f4ee106">get_unsuback_handler</a> () const</td></tr>
<tr class="memdesc:a06f7dfac2d8e5951d3e9deb06f4ee106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get unsuback handler.  <a href="#a06f7dfac2d8e5951d3e9deb06f4ee106">More...</a><br /></td></tr>
<tr class="separator:a06f7dfac2d8e5951d3e9deb06f4ee106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217409dab62840d59ef137cb666629c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a217409dab62840d59ef137cb666629c9">get_disconnect_handler</a> () const</td></tr>
<tr class="memdesc:a217409dab62840d59ef137cb666629c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get disconnect handler.  <a href="#a217409dab62840d59ef137cb666629c9">More...</a><br /></td></tr>
<tr class="separator:a217409dab62840d59ef137cb666629c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d654d25027b2ff58ee64cbbb30177f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0d654d25027b2ff58ee64cbbb30177f2">set_v5_connect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a>())</td></tr>
<tr class="memdesc:a0d654d25027b2ff58ee64cbbb30177f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connect handler.  <a href="#a0d654d25027b2ff58ee64cbbb30177f2">More...</a><br /></td></tr>
<tr class="separator:a0d654d25027b2ff58ee64cbbb30177f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db9c1927f33bfa0e3e6b3ebaf963768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7db9c1927f33bfa0e3e6b3ebaf963768">set_v5_connack_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a>())</td></tr>
<tr class="memdesc:a7db9c1927f33bfa0e3e6b3ebaf963768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connack handler.  <a href="#a7db9c1927f33bfa0e3e6b3ebaf963768">More...</a><br /></td></tr>
<tr class="separator:a7db9c1927f33bfa0e3e6b3ebaf963768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bd780f601f9d861f9651a515f01e07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af0bd780f601f9d861f9651a515f01e07">set_v5_publish_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a>())</td></tr>
<tr class="memdesc:af0bd780f601f9d861f9651a515f01e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set publish handler.  <a href="#af0bd780f601f9d861f9651a515f01e07">More...</a><br /></td></tr>
<tr class="separator:af0bd780f601f9d861f9651a515f01e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc3fa1f95f31e4985d6eca3c1a844ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adfc3fa1f95f31e4985d6eca3c1a844ff">set_v5_puback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a>())</td></tr>
<tr class="memdesc:adfc3fa1f95f31e4985d6eca3c1a844ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#adfc3fa1f95f31e4985d6eca3c1a844ff">More...</a><br /></td></tr>
<tr class="separator:adfc3fa1f95f31e4985d6eca3c1a844ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452640ab312e93ef3c91b641ae0eea45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a452640ab312e93ef3c91b641ae0eea45">set_v5_pubrec_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a>())</td></tr>
<tr class="memdesc:a452640ab312e93ef3c91b641ae0eea45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrec handler.  <a href="#a452640ab312e93ef3c91b641ae0eea45">More...</a><br /></td></tr>
<tr class="separator:a452640ab312e93ef3c91b641ae0eea45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab30ff8232298b2196c185876b361d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aab30ff8232298b2196c185876b361d34">set_v5_pubrel_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a>())</td></tr>
<tr class="memdesc:aab30ff8232298b2196c185876b361d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrel handler.  <a href="#aab30ff8232298b2196c185876b361d34">More...</a><br /></td></tr>
<tr class="separator:aab30ff8232298b2196c185876b361d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083b480ea82750577ef63dd6b99b2d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a083b480ea82750577ef63dd6b99b2d2a">set_v5_pubcomp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a>())</td></tr>
<tr class="memdesc:a083b480ea82750577ef63dd6b99b2d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#a083b480ea82750577ef63dd6b99b2d2a">More...</a><br /></td></tr>
<tr class="separator:a083b480ea82750577ef63dd6b99b2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1756a1b5632ee546097132bf079c861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af1756a1b5632ee546097132bf079c861">set_v5_subscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a>())</td></tr>
<tr class="memdesc:af1756a1b5632ee546097132bf079c861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subscribe handler.  <a href="#af1756a1b5632ee546097132bf079c861">More...</a><br /></td></tr>
<tr class="separator:af1756a1b5632ee546097132bf079c861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d211deb953ab4d1d5df6516ab91d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a183d211deb953ab4d1d5df6516ab91d5">set_v5_suback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a>())</td></tr>
<tr class="memdesc:a183d211deb953ab4d1d5df6516ab91d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set suback handler.  <a href="#a183d211deb953ab4d1d5df6516ab91d5">More...</a><br /></td></tr>
<tr class="separator:a183d211deb953ab4d1d5df6516ab91d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46001164a6cc4e94022ccc7565339999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a46001164a6cc4e94022ccc7565339999">set_v5_unsubscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a>())</td></tr>
<tr class="memdesc:a46001164a6cc4e94022ccc7565339999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsubscribe handler.  <a href="#a46001164a6cc4e94022ccc7565339999">More...</a><br /></td></tr>
<tr class="separator:a46001164a6cc4e94022ccc7565339999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f40f2e30f7f20e2cf1de5b91bc09cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3f40f2e30f7f20e2cf1de5b91bc09cad">set_v5_unsuback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a>())</td></tr>
<tr class="memdesc:a3f40f2e30f7f20e2cf1de5b91bc09cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsuback handler.  <a href="#a3f40f2e30f7f20e2cf1de5b91bc09cad">More...</a><br /></td></tr>
<tr class="separator:a3f40f2e30f7f20e2cf1de5b91bc09cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8786469e0003b6c7f8022f6a92febb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8786469e0003b6c7f8022f6a92febb0e">set_v5_disconnect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a>())</td></tr>
<tr class="memdesc:a8786469e0003b6c7f8022f6a92febb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set disconnect handler.  <a href="#a8786469e0003b6c7f8022f6a92febb0e">More...</a><br /></td></tr>
<tr class="separator:a8786469e0003b6c7f8022f6a92febb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf739ddb456257c1c033d0b3d0adc7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acf739ddb456257c1c033d0b3d0adc7ba">set_v5_auth_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a>())</td></tr>
<tr class="memdesc:acf739ddb456257c1c033d0b3d0adc7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set auth handler.  <a href="#acf739ddb456257c1c033d0b3d0adc7ba">More...</a><br /></td></tr>
<tr class="separator:acf739ddb456257c1c033d0b3d0adc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c4d43e48e8b3eb35cece5f98124358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a83c4d43e48e8b3eb35cece5f98124358">get_v5_connect_handler</a> () const</td></tr>
<tr class="memdesc:a83c4d43e48e8b3eb35cece5f98124358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connect handler.  <a href="#a83c4d43e48e8b3eb35cece5f98124358">More...</a><br /></td></tr>
<tr class="separator:a83c4d43e48e8b3eb35cece5f98124358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfdff9b4ebbeb165a6eaca111cd0edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afbfdff9b4ebbeb165a6eaca111cd0edc">get_v5_connack_handler</a> () const</td></tr>
<tr class="memdesc:afbfdff9b4ebbeb165a6eaca111cd0edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connack handler.  <a href="#afbfdff9b4ebbeb165a6eaca111cd0edc">More...</a><br /></td></tr>
<tr class="separator:afbfdff9b4ebbeb165a6eaca111cd0edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6c7f6eeb3c82349f4537d3ed458e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9bb6c7f6eeb3c82349f4537d3ed458e9">get_v5_publish_handler</a> () const</td></tr>
<tr class="memdesc:a9bb6c7f6eeb3c82349f4537d3ed458e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set publish handler.  <a href="#a9bb6c7f6eeb3c82349f4537d3ed458e9">More...</a><br /></td></tr>
<tr class="separator:a9bb6c7f6eeb3c82349f4537d3ed458e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1644dfe7b9bcdc1686d5d18acc4b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4f1644dfe7b9bcdc1686d5d18acc4b64">get_v5_puback_handler</a> () const</td></tr>
<tr class="memdesc:a4f1644dfe7b9bcdc1686d5d18acc4b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get puback handler.  <a href="#a4f1644dfe7b9bcdc1686d5d18acc4b64">More...</a><br /></td></tr>
<tr class="separator:a4f1644dfe7b9bcdc1686d5d18acc4b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8397c86d51dda1a9ac6c3c0c2256a830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8397c86d51dda1a9ac6c3c0c2256a830">get_v5_pubrec_handler</a> () const</td></tr>
<tr class="memdesc:a8397c86d51dda1a9ac6c3c0c2256a830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubrec handler.  <a href="#a8397c86d51dda1a9ac6c3c0c2256a830">More...</a><br /></td></tr>
<tr class="separator:a8397c86d51dda1a9ac6c3c0c2256a830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071a92a014d5233238f5ae28152fd986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a071a92a014d5233238f5ae28152fd986">get_v5_pubrel_handler</a> () const</td></tr>
<tr class="memdesc:a071a92a014d5233238f5ae28152fd986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubrel handler.  <a href="#a071a92a014d5233238f5ae28152fd986">More...</a><br /></td></tr>
<tr class="separator:a071a92a014d5233238f5ae28152fd986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9570b4057ad94f411edb1e2e277b55dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9570b4057ad94f411edb1e2e277b55dc">get_v5_pubcomp_handler</a> () const</td></tr>
<tr class="memdesc:a9570b4057ad94f411edb1e2e277b55dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pubcomp handler.  <a href="#a9570b4057ad94f411edb1e2e277b55dc">More...</a><br /></td></tr>
<tr class="separator:a9570b4057ad94f411edb1e2e277b55dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16328227abda36b6a1f2545ca93c37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac16328227abda36b6a1f2545ca93c37e">get_v5_subscribe_handler</a> () const</td></tr>
<tr class="memdesc:ac16328227abda36b6a1f2545ca93c37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get subscribe handler.  <a href="#ac16328227abda36b6a1f2545ca93c37e">More...</a><br /></td></tr>
<tr class="separator:ac16328227abda36b6a1f2545ca93c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d1f7f25d2c751070b46cb54378a3de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a38d1f7f25d2c751070b46cb54378a3de">get_v5_suback_handler</a> () const</td></tr>
<tr class="memdesc:a38d1f7f25d2c751070b46cb54378a3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get suback handler.  <a href="#a38d1f7f25d2c751070b46cb54378a3de">More...</a><br /></td></tr>
<tr class="separator:a38d1f7f25d2c751070b46cb54378a3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5718b99355d4a38efeb98bb06cf3b680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5718b99355d4a38efeb98bb06cf3b680">get_v5_unsubscribe_handler</a> () const</td></tr>
<tr class="memdesc:a5718b99355d4a38efeb98bb06cf3b680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get unsubscribe handler.  <a href="#a5718b99355d4a38efeb98bb06cf3b680">More...</a><br /></td></tr>
<tr class="separator:a5718b99355d4a38efeb98bb06cf3b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9918787471e777e77103597e86f6aaf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9918787471e777e77103597e86f6aaf0">get_v5_unsuback_handler</a> () const</td></tr>
<tr class="memdesc:a9918787471e777e77103597e86f6aaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get unsuback handler.  <a href="#a9918787471e777e77103597e86f6aaf0">More...</a><br /></td></tr>
<tr class="separator:a9918787471e777e77103597e86f6aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d1330266d13ff0b170e4c657abb6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a27d1330266d13ff0b170e4c657abb6de">get_v5_disconnect_handler</a> () const</td></tr>
<tr class="memdesc:a27d1330266d13ff0b170e4c657abb6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get disconnect handler.  <a href="#a27d1330266d13ff0b170e4c657abb6de">More...</a><br /></td></tr>
<tr class="separator:a27d1330266d13ff0b170e4c657abb6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673781bf813e38aa898da18c927d4223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a673781bf813e38aa898da18c927d4223">get_v5_auth_handler</a> () const</td></tr>
<tr class="memdesc:a673781bf813e38aa898da18c927d4223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get auth handler.  <a href="#a673781bf813e38aa898da18c927d4223">More...</a><br /></td></tr>
<tr class="separator:a673781bf813e38aa898da18c927d4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9182698035a15d040fa02686819188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7b9182698035a15d040fa02686819188">set_close_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a>())</td></tr>
<tr class="memdesc:a7b9182698035a15d040fa02686819188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set close handler.  <a href="#a7b9182698035a15d040fa02686819188">More...</a><br /></td></tr>
<tr class="separator:a7b9182698035a15d040fa02686819188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb12b84bd8f3e0b64d18d70181fa15f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afb12b84bd8f3e0b64d18d70181fa15f4">set_error_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a>())</td></tr>
<tr class="memdesc:afb12b84bd8f3e0b64d18d70181fa15f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error handler.  <a href="#afb12b84bd8f3e0b64d18d70181fa15f4">More...</a><br /></td></tr>
<tr class="separator:afb12b84bd8f3e0b64d18d70181fa15f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b1d3ecbe48f24369c21c7d9fa2b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2b4b1d3ecbe48f24369c21c7d9fa2b5f">set_pub_res_sent_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a>())</td></tr>
<tr class="memdesc:a2b4b1d3ecbe48f24369c21c7d9fa2b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#a2b4b1d3ecbe48f24369c21c7d9fa2b5f">More...</a><br /></td></tr>
<tr class="separator:a2b4b1d3ecbe48f24369c21c7d9fa2b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf8bc427d46b88f2ce4d95d1b73728c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acaf8bc427d46b88f2ce4d95d1b73728c">set_serialize_handlers</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a> h_publish, <a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a> h_pubrel, <a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> h_remove)</td></tr>
<tr class="memdesc:acaf8bc427d46b88f2ce4d95d1b73728c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serialize handlers.  <a href="#acaf8bc427d46b88f2ce4d95d1b73728c">More...</a><br /></td></tr>
<tr class="separator:acaf8bc427d46b88f2ce4d95d1b73728c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c2704b2e3bd6a90c2287c2f9c7a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3d9c2704b2e3bd6a90c2287c2f9c7a64">set_v5_serialize_handlers</a> (<a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a> h_publish, <a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a> h_pubrel, <a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> h_remove)</td></tr>
<tr class="memdesc:a3d9c2704b2e3bd6a90c2287c2f9c7a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serialize handlers.  <a href="#a3d9c2704b2e3bd6a90c2287c2f9c7a64">More...</a><br /></td></tr>
<tr class="separator:a3d9c2704b2e3bd6a90c2287c2f9c7a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0fc63bf8a29e40b7fba95915ac96a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1a0fc63bf8a29e40b7fba95915ac96a6">set_serialize_handlers</a> (<a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a> h_publish, <a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a> h_pubrel, <a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> h_remove)</td></tr>
<tr class="memdesc:a1a0fc63bf8a29e40b7fba95915ac96a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serialize handlers.  <a href="#a1a0fc63bf8a29e40b7fba95915ac96a6">More...</a><br /></td></tr>
<tr class="separator:a1a0fc63bf8a29e40b7fba95915ac96a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94d3c72c95c6d769ec269cb83d81c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4e94d3c72c95c6d769ec269cb83d81c5">set_v5_serialize_handlers</a> (<a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a> h_publish, <a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a> h_pubrel, <a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> h_remove)</td></tr>
<tr class="memdesc:a4e94d3c72c95c6d769ec269cb83d81c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serialize handlers.  <a href="#a4e94d3c72c95c6d769ec269cb83d81c5">More...</a><br /></td></tr>
<tr class="separator:a4e94d3c72c95c6d769ec269cb83d81c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af44bacd086ce8ed70bf72360f124b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3af44bacd086ce8ed70bf72360f124b0">set_serialize_handlers</a> ()</td></tr>
<tr class="memdesc:a3af44bacd086ce8ed70bf72360f124b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear serialize handlers.  <a href="#a3af44bacd086ce8ed70bf72360f124b0">More...</a><br /></td></tr>
<tr class="separator:a3af44bacd086ce8ed70bf72360f124b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c863cba3f3195e3c4c29be06fa2beca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5c863cba3f3195e3c4c29be06fa2beca">set_pre_send_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a>())</td></tr>
<tr class="memdesc:a5c863cba3f3195e3c4c29be06fa2beca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pre-send handler.  <a href="#a5c863cba3f3195e3c4c29be06fa2beca">More...</a><br /></td></tr>
<tr class="separator:a5c863cba3f3195e3c4c29be06fa2beca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc3a33dc1d8e00d524481fec3ab86e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7fc3a33dc1d8e00d524481fec3ab86e3">set_is_valid_length_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a>())</td></tr>
<tr class="memdesc:a7fc3a33dc1d8e00d524481fec3ab86e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set check length handler.  <a href="#a7fc3a33dc1d8e00d524481fec3ab86e3">More...</a><br /></td></tr>
<tr class="separator:a7fc3a33dc1d8e00d524481fec3ab86e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73abc104827371983fcb8af0b220b9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a73abc104827371983fcb8af0b220b9a5">get_close_handler</a> () const</td></tr>
<tr class="memdesc:a73abc104827371983fcb8af0b220b9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get close handler.  <a href="#a73abc104827371983fcb8af0b220b9a5">More...</a><br /></td></tr>
<tr class="separator:a73abc104827371983fcb8af0b220b9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2737f82e37d85c04afc191c8ed07d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad2737f82e37d85c04afc191c8ed07d83">get_error_handler</a> () const</td></tr>
<tr class="memdesc:ad2737f82e37d85c04afc191c8ed07d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error handler.  <a href="#ad2737f82e37d85c04afc191c8ed07d83">More...</a><br /></td></tr>
<tr class="separator:ad2737f82e37d85c04afc191c8ed07d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda1f7f42e5e4d8e2edefd8fe3b62db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7dda1f7f42e5e4d8e2edefd8fe3b62db">get_pub_res_sent_handler</a> () const</td></tr>
<tr class="memdesc:a7dda1f7f42e5e4d8e2edefd8fe3b62db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get publish response sent handler.  <a href="#a7dda1f7f42e5e4d8e2edefd8fe3b62db">More...</a><br /></td></tr>
<tr class="separator:a7dda1f7f42e5e4d8e2edefd8fe3b62db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa7cfeb1316cb56900fd9cd45c287cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0fa7cfeb1316cb56900fd9cd45c287cf">get_serialize_publish_message_handler</a> () const</td></tr>
<tr class="memdesc:a0fa7cfeb1316cb56900fd9cd45c287cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get serialize publish handler.  <a href="#a0fa7cfeb1316cb56900fd9cd45c287cf">More...</a><br /></td></tr>
<tr class="separator:a0fa7cfeb1316cb56900fd9cd45c287cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b713463a8008618f99ce1f4cd521e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a510b713463a8008618f99ce1f4cd521e">get_serialize_pubrel_message_handler</a> () const</td></tr>
<tr class="memdesc:a510b713463a8008618f99ce1f4cd521e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get serialize pubrel handler.  <a href="#a510b713463a8008618f99ce1f4cd521e">More...</a><br /></td></tr>
<tr class="separator:a510b713463a8008618f99ce1f4cd521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2a3122979eaf1ab78d0136f928c5ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1f2a3122979eaf1ab78d0136f928c5ad">get_serialize_v5_publish_message_handler</a> () const</td></tr>
<tr class="memdesc:a1f2a3122979eaf1ab78d0136f928c5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get serialize publish handler.  <a href="#a1f2a3122979eaf1ab78d0136f928c5ad">More...</a><br /></td></tr>
<tr class="separator:a1f2a3122979eaf1ab78d0136f928c5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc383e509fe83245a7d6eb9a8732e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1bc383e509fe83245a7d6eb9a8732e20">get_serialize_v5_pubrel_message_handler</a> () const</td></tr>
<tr class="memdesc:a1bc383e509fe83245a7d6eb9a8732e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get serialize pubrel handler.  <a href="#a1bc383e509fe83245a7d6eb9a8732e20">More...</a><br /></td></tr>
<tr class="separator:a1bc383e509fe83245a7d6eb9a8732e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeba1a1c3d324b405517144d5fa27ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6eeba1a1c3d324b405517144d5fa27ad">get_serialize_remove_handler</a> () const</td></tr>
<tr class="memdesc:a6eeba1a1c3d324b405517144d5fa27ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get serialize remove handler.  <a href="#a6eeba1a1c3d324b405517144d5fa27ad">More...</a><br /></td></tr>
<tr class="separator:a6eeba1a1c3d324b405517144d5fa27ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8480ad5495be1044208edc96658ae51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8480ad5495be1044208edc96658ae51d">get_pre_send_handler</a> () const</td></tr>
<tr class="memdesc:a8480ad5495be1044208edc96658ae51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pre-send handler.  <a href="#a8480ad5495be1044208edc96658ae51d">More...</a><br /></td></tr>
<tr class="separator:a8480ad5495be1044208edc96658ae51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e05a3ab36d615db8e8dfd1cf92f236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a01e05a3ab36d615db8e8dfd1cf92f236">get_is_valid_length_handler</a> () const</td></tr>
<tr class="memdesc:a01e05a3ab36d615db8e8dfd1cf92f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get check length handler.  <a href="#a01e05a3ab36d615db8e8dfd1cf92f236">More...</a><br /></td></tr>
<tr class="separator:a01e05a3ab36d615db8e8dfd1cf92f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f251407d9db5cc5b3d761fdf74ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac29f251407d9db5cc5b3d761fdf74ac7">start_session</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac29f251407d9db5cc5b3d761fdf74ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">start session with a connected endpoint.  <a href="#ac29f251407d9db5cc5b3d761fdf74ac7">More...</a><br /></td></tr>
<tr class="separator:ac29f251407d9db5cc5b3d761fdf74ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098ab1eb391de503160cc3eacd91d7b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a098ab1eb391de503160cc3eacd91d7b1">publish_at_most_once</a> (<a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a098ab1eb391de503160cc3eacd91d7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#a098ab1eb391de503160cc3eacd91d7b1">More...</a><br /></td></tr>
<tr class="separator:a098ab1eb391de503160cc3eacd91d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2a89c0408ff18be15f31aa8240de3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afd2a89c0408ff18be15f31aa8240de3a">publish_at_most_once</a> (as::const_buffer topic_name, as::const_buffer contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:afd2a89c0408ff18be15f31aa8240de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#afd2a89c0408ff18be15f31aa8240de3a">More...</a><br /></td></tr>
<tr class="separator:afd2a89c0408ff18be15f31aa8240de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660a7db26317eef7718077bfe68d0df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a660a7db26317eef7718077bfe68d0df4">publish_at_least_once</a> (std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a660a7db26317eef7718077bfe68d0df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a660a7db26317eef7718077bfe68d0df4">More...</a><br /></td></tr>
<tr class="separator:a660a7db26317eef7718077bfe68d0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77537cee66c89dd2f8ea952e0aaafe7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a77537cee66c89dd2f8ea952e0aaafe7c">publish_at_least_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a77537cee66c89dd2f8ea952e0aaafe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a77537cee66c89dd2f8ea952e0aaafe7c">More...</a><br /></td></tr>
<tr class="separator:a77537cee66c89dd2f8ea952e0aaafe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141c7130c2afa94f927af2004529c3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a141c7130c2afa94f927af2004529c3a0">publish_exactly_once</a> (std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a141c7130c2afa94f927af2004529c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a141c7130c2afa94f927af2004529c3a0">More...</a><br /></td></tr>
<tr class="separator:a141c7130c2afa94f927af2004529c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f81eb299829767c8f31e5c9f7ba1cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0f81eb299829767c8f31e5c9f7ba1cb4">publish_exactly_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0f81eb299829767c8f31e5c9f7ba1cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a0f81eb299829767c8f31e5c9f7ba1cb4">More...</a><br /></td></tr>
<tr class="separator:a0f81eb299829767c8f31e5c9f7ba1cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12f48e7b0fbb01b378dddbe58192fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9c12f48e7b0fbb01b378dddbe58192fb">publish</a> (std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9c12f48e7b0fbb01b378dddbe58192fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#a9c12f48e7b0fbb01b378dddbe58192fb">More...</a><br /></td></tr>
<tr class="separator:a9c12f48e7b0fbb01b378dddbe58192fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f21b3c942ee014d22834bae3ed3b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac7f21b3c942ee014d22834bae3ed3b77">publish</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ac7f21b3c942ee014d22834bae3ed3b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#ac7f21b3c942ee014d22834bae3ed3b77">More...</a><br /></td></tr>
<tr class="separator:ac7f21b3c942ee014d22834bae3ed3b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa1691905481eb92e742dfe733d95a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a12aa1691905481eb92e742dfe733d95a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a12aa1691905481eb92e742dfe733d95a">subscribe</a> (<a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, std::uint8_t option, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a12aa1691905481eb92e742dfe733d95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a12aa1691905481eb92e742dfe733d95a">More...</a><br /></td></tr>
<tr class="separator:a12aa1691905481eb92e742dfe733d95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b11d79e8db71d62ee9e0eb1683fd0c9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8b11d79e8db71d62ee9e0eb1683fd0c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8b11d79e8db71d62ee9e0eb1683fd0c9">subscribe</a> (as::const_buffer topic_name, std::uint8_t option, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8b11d79e8db71d62ee9e0eb1683fd0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a8b11d79e8db71d62ee9e0eb1683fd0c9">More...</a><br /></td></tr>
<tr class="separator:a8b11d79e8db71d62ee9e0eb1683fd0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecb3cd35541b9f418375799d7314149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acecb3cd35541b9f418375799d7314149">subscribe</a> (std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:acecb3cd35541b9f418375799d7314149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#acecb3cd35541b9f418375799d7314149">More...</a><br /></td></tr>
<tr class="separator:acecb3cd35541b9f418375799d7314149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4659f80cfc111a4e5d0d2c4acb100a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4659f80cfc111a4e5d0d2c4acb100a0c">subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a4659f80cfc111a4e5d0d2c4acb100a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a4659f80cfc111a4e5d0d2c4acb100a0c">More...</a><br /></td></tr>
<tr class="separator:a4659f80cfc111a4e5d0d2c4acb100a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76c10839fa3ee9b9b5351def86354bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac76c10839fa3ee9b9b5351def86354bb">unsubscribe</a> (std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ac76c10839fa3ee9b9b5351def86354bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#ac76c10839fa3ee9b9b5351def86354bb">More...</a><br /></td></tr>
<tr class="separator:ac76c10839fa3ee9b9b5351def86354bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165bb916cd66aa0293d4d485b664d4c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a165bb916cd66aa0293d4d485b664d4c3">unsubscribe</a> (std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a165bb916cd66aa0293d4d485b664d4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a165bb916cd66aa0293d4d485b664d4c3">More...</a><br /></td></tr>
<tr class="separator:a165bb916cd66aa0293d4d485b664d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5e7183594b79954804007f82a25390"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afe5e7183594b79954804007f82a25390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afe5e7183594b79954804007f82a25390">unsubscribe</a> (<a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afe5e7183594b79954804007f82a25390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#afe5e7183594b79954804007f82a25390">More...</a><br /></td></tr>
<tr class="separator:afe5e7183594b79954804007f82a25390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d4df813aaeb1677044593891d9a6f0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a81d4df813aaeb1677044593891d9a6f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a81d4df813aaeb1677044593891d9a6f0">unsubscribe</a> (as::const_buffer topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a81d4df813aaeb1677044593891d9a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a81d4df813aaeb1677044593891d9a6f0">More...</a><br /></td></tr>
<tr class="separator:a81d4df813aaeb1677044593891d9a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb6e58ae2d3bec844e15ebc17f59e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e">disconnect</a> (mqtt::optional&lt; std::uint8_t &gt; reason=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a4eb6e58ae2d3bec844e15ebc17f59e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br />
  <a href="#a4eb6e58ae2d3bec844e15ebc17f59e7e">More...</a><br /></td></tr>
<tr class="separator:a4eb6e58ae2d3bec844e15ebc17f59e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ff6a5a8c30331e90bd6ae3b36e7ce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a92ff6a5a8c30331e90bd6ae3b36e7ce2">force_disconnect</a> ()</td></tr>
<tr class="memdesc:a92ff6a5a8c30331e90bd6ae3b36e7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a92ff6a5a8c30331e90bd6ae3b36e7ce2" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
  <a href="#a92ff6a5a8c30331e90bd6ae3b36e7ce2">More...</a><br /></td></tr>
<tr class="separator:a92ff6a5a8c30331e90bd6ae3b36e7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531135e53a9f39d976a7140854c8b02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a531135e53a9f39d976a7140854c8b02f">publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a531135e53a9f39d976a7140854c8b02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a531135e53a9f39d976a7140854c8b02f">More...</a><br /></td></tr>
<tr class="separator:a531135e53a9f39d976a7140854c8b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f9be4a0929ab22f3082ed76b1459d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a598f9be4a0929ab22f3082ed76b1459d">publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a598f9be4a0929ab22f3082ed76b1459d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a598f9be4a0929ab22f3082ed76b1459d">More...</a><br /></td></tr>
<tr class="separator:a598f9be4a0929ab22f3082ed76b1459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d92500fe04217befe3fddd7f241ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aef5d92500fe04217befe3fddd7f241ff">publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aef5d92500fe04217befe3fddd7f241ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#aef5d92500fe04217befe3fddd7f241ff">More...</a><br /></td></tr>
<tr class="separator:aef5d92500fe04217befe3fddd7f241ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97de973ad1d5537fdb71bc5c38dba1b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a97de973ad1d5537fdb71bc5c38dba1b9">publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a97de973ad1d5537fdb71bc5c38dba1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a97de973ad1d5537fdb71bc5c38dba1b9">More...</a><br /></td></tr>
<tr class="separator:a97de973ad1d5537fdb71bc5c38dba1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3efe8c8d95e4d75273067b98eb0b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1a3efe8c8d95e4d75273067b98eb0b76">publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a1a3efe8c8d95e4d75273067b98eb0b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a1a3efe8c8d95e4d75273067b98eb0b76">More...</a><br /></td></tr>
<tr class="separator:a1a3efe8c8d95e4d75273067b98eb0b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c09561f95d0fe2e721b633663480cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a91c09561f95d0fe2e721b633663480cb">publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a91c09561f95d0fe2e721b633663480cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a91c09561f95d0fe2e721b633663480cb">More...</a><br /></td></tr>
<tr class="separator:a91c09561f95d0fe2e721b633663480cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f05a35511d94933ed13564ef33c85ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7f05a35511d94933ed13564ef33c85ca">publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a7f05a35511d94933ed13564ef33c85ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a7f05a35511d94933ed13564ef33c85ca">More...</a><br /></td></tr>
<tr class="separator:a7f05a35511d94933ed13564ef33c85ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0984154e1e1618f6b2db3fdd9ff928ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0984154e1e1618f6b2db3fdd9ff928ed">publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0984154e1e1618f6b2db3fdd9ff928ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a0984154e1e1618f6b2db3fdd9ff928ed">More...</a><br /></td></tr>
<tr class="separator:a0984154e1e1618f6b2db3fdd9ff928ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cd77e26c42dcb3f59d69daa62ac655"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa8cd77e26c42dcb3f59d69daa62ac655"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa8cd77e26c42dcb3f59d69daa62ac655">subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa8cd77e26c42dcb3f59d69daa62ac655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#aa8cd77e26c42dcb3f59d69daa62ac655">More...</a><br /></td></tr>
<tr class="separator:aa8cd77e26c42dcb3f59d69daa62ac655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed35731778382040034756d751e23dd9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aed35731778382040034756d751e23dd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aed35731778382040034756d751e23dd9">subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aed35731778382040034756d751e23dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#aed35731778382040034756d751e23dd9">More...</a><br /></td></tr>
<tr class="separator:aed35731778382040034756d751e23dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0308c6430ad11699c4e4c47cdbf50880"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0308c6430ad11699c4e4c47cdbf50880">subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0308c6430ad11699c4e4c47cdbf50880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a0308c6430ad11699c4e4c47cdbf50880">More...</a><br /></td></tr>
<tr class="separator:a0308c6430ad11699c4e4c47cdbf50880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5767724773143980305d04bf4ac671b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5767724773143980305d04bf4ac671b8">subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a5767724773143980305d04bf4ac671b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a5767724773143980305d04bf4ac671b8">More...</a><br /></td></tr>
<tr class="separator:a5767724773143980305d04bf4ac671b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57967a376162f169a0d5201ab947684e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a57967a376162f169a0d5201ab947684e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a57967a376162f169a0d5201ab947684e">unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a57967a376162f169a0d5201ab947684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a57967a376162f169a0d5201ab947684e">More...</a><br /></td></tr>
<tr class="separator:a57967a376162f169a0d5201ab947684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bab39826018e2b4ec82a269b6dd806"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab4bab39826018e2b4ec82a269b6dd806"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab4bab39826018e2b4ec82a269b6dd806">unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab4bab39826018e2b4ec82a269b6dd806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#ab4bab39826018e2b4ec82a269b6dd806">More...</a><br /></td></tr>
<tr class="separator:ab4bab39826018e2b4ec82a269b6dd806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9446ef8e8bddaf753278414eb884886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae9446ef8e8bddaf753278414eb884886">unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ae9446ef8e8bddaf753278414eb884886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#ae9446ef8e8bddaf753278414eb884886">More...</a><br /></td></tr>
<tr class="separator:ae9446ef8e8bddaf753278414eb884886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c011f9283903c3273de2e463e7544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a688c011f9283903c3273de2e463e7544">unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a688c011f9283903c3273de2e463e7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a688c011f9283903c3273de2e463e7544">More...</a><br /></td></tr>
<tr class="separator:a688c011f9283903c3273de2e463e7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f88e8c9c612942523fa07db997def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aab7f88e8c9c612942523fa07db997def">acquired_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:aab7f88e8c9c612942523fa07db997def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with already acquired packet identifier.  <a href="#aab7f88e8c9c612942523fa07db997def">More...</a><br /></td></tr>
<tr class="separator:aab7f88e8c9c612942523fa07db997def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45ef5ec0fc07ae35ac9cceda2347223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac45ef5ec0fc07ae35ac9cceda2347223">acquired_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ac45ef5ec0fc07ae35ac9cceda2347223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with already acquired packet identifier.  <a href="#ac45ef5ec0fc07ae35ac9cceda2347223">More...</a><br /></td></tr>
<tr class="separator:ac45ef5ec0fc07ae35ac9cceda2347223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acabc70b2dd8e98d28dce706fa7de92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0acabc70b2dd8e98d28dce706fa7de92">acquired_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a0acabc70b2dd8e98d28dce706fa7de92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with already acquired packet identifier.  <a href="#a0acabc70b2dd8e98d28dce706fa7de92">More...</a><br /></td></tr>
<tr class="separator:a0acabc70b2dd8e98d28dce706fa7de92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6217da64862947352d98d56e641c8fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6217da64862947352d98d56e641c8fcc">acquired_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a6217da64862947352d98d56e641c8fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with already acquired packet identifier.  <a href="#a6217da64862947352d98d56e641c8fcc">More...</a><br /></td></tr>
<tr class="separator:a6217da64862947352d98d56e641c8fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdef235db5197c39969edc147a5aba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acfdef235db5197c39969edc147a5aba3">acquired_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:acfdef235db5197c39969edc147a5aba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="#acfdef235db5197c39969edc147a5aba3">More...</a><br /></td></tr>
<tr class="separator:acfdef235db5197c39969edc147a5aba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098c5e3eb30065aedd3b5b26de64f65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab098c5e3eb30065aedd3b5b26de64f65">acquired_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ab098c5e3eb30065aedd3b5b26de64f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="#ab098c5e3eb30065aedd3b5b26de64f65">More...</a><br /></td></tr>
<tr class="separator:ab098c5e3eb30065aedd3b5b26de64f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b912be2c99475b000d643ca4dabc39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad3b912be2c99475b000d643ca4dabc39">acquired_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ad3b912be2c99475b000d643ca4dabc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="#ad3b912be2c99475b000d643ca4dabc39">More...</a><br /></td></tr>
<tr class="separator:ad3b912be2c99475b000d643ca4dabc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48286ccbfcf8f1d62f56cd093ef765ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a48286ccbfcf8f1d62f56cd093ef765ea">acquired_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a48286ccbfcf8f1d62f56cd093ef765ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="#a48286ccbfcf8f1d62f56cd093ef765ea">More...</a><br /></td></tr>
<tr class="separator:a48286ccbfcf8f1d62f56cd093ef765ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799bf2aa9a36ef1714e0952428e02f7b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a799bf2aa9a36ef1714e0952428e02f7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a799bf2aa9a36ef1714e0952428e02f7b">acquired_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a799bf2aa9a36ef1714e0952428e02f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#a799bf2aa9a36ef1714e0952428e02f7b">More...</a><br /></td></tr>
<tr class="separator:a799bf2aa9a36ef1714e0952428e02f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93fcd23f1333c58071512a122b2f10"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aed93fcd23f1333c58071512a122b2f10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aed93fcd23f1333c58071512a122b2f10">acquired_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aed93fcd23f1333c58071512a122b2f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#aed93fcd23f1333c58071512a122b2f10">More...</a><br /></td></tr>
<tr class="separator:aed93fcd23f1333c58071512a122b2f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbcf2c9c9d1a55fca04ddb18f95f5b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#addbcf2c9c9d1a55fca04ddb18f95f5b9">acquired_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:addbcf2c9c9d1a55fca04ddb18f95f5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#addbcf2c9c9d1a55fca04ddb18f95f5b9">More...</a><br /></td></tr>
<tr class="separator:addbcf2c9c9d1a55fca04ddb18f95f5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda888186b26358c858a6a24826065f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5eda888186b26358c858a6a24826065f">acquired_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a5eda888186b26358c858a6a24826065f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#a5eda888186b26358c858a6a24826065f">More...</a><br /></td></tr>
<tr class="separator:a5eda888186b26358c858a6a24826065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67cc59266aec74cde509c02c7110dfa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab67cc59266aec74cde509c02c7110dfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab67cc59266aec74cde509c02c7110dfa">acquired_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab67cc59266aec74cde509c02c7110dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#ab67cc59266aec74cde509c02c7110dfa">More...</a><br /></td></tr>
<tr class="separator:ab67cc59266aec74cde509c02c7110dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329511b3be22f974810269dfd7e08c60"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a329511b3be22f974810269dfd7e08c60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a329511b3be22f974810269dfd7e08c60">acquired_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a329511b3be22f974810269dfd7e08c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a329511b3be22f974810269dfd7e08c60">More...</a><br /></td></tr>
<tr class="separator:a329511b3be22f974810269dfd7e08c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b469fbf436f0acd8d1023713dc8026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a60b469fbf436f0acd8d1023713dc8026">acquired_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a60b469fbf436f0acd8d1023713dc8026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a60b469fbf436f0acd8d1023713dc8026">More...</a><br /></td></tr>
<tr class="separator:a60b469fbf436f0acd8d1023713dc8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d256414e14691cea13770011c0cc5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9d256414e14691cea13770011c0cc5c2">acquired_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a9d256414e14691cea13770011c0cc5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a9d256414e14691cea13770011c0cc5c2">More...</a><br /></td></tr>
<tr class="separator:a9d256414e14691cea13770011c0cc5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf3e15fafd93b1b4ff5d21ea0ae2824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9cf3e15fafd93b1b4ff5d21ea0ae2824">pingreq</a> ()</td></tr>
<tr class="memdesc:a9cf3e15fafd93b1b4ff5d21ea0ae2824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>.  <a href="#a9cf3e15fafd93b1b4ff5d21ea0ae2824">More...</a><br /></td></tr>
<tr class="separator:a9cf3e15fafd93b1b4ff5d21ea0ae2824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f660a85f6f57610c861ae56c0873474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7f660a85f6f57610c861ae56c0873474">pingresp</a> ()</td></tr>
<tr class="memdesc:a7f660a85f6f57610c861ae56c0873474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>.  <a href="#a7f660a85f6f57610c861ae56c0873474">More...</a><br /></td></tr>
<tr class="separator:a7f660a85f6f57610c861ae56c0873474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a59580f4c6fc57f64c8c140ddccc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a214a59580f4c6fc57f64c8c140ddccc4">auth</a> (mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a214a59580f4c6fc57f64c8c140ddccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>.  <a href="#a214a59580f4c6fc57f64c8c140ddccc4">More...</a><br /></td></tr>
<tr class="separator:a214a59580f4c6fc57f64c8c140ddccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ba0fefb75d423e8a513093163f7da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab9ba0fefb75d423e8a513093163f7da3">connect</a> (std::string const &amp;client_id, mqtt::optional&lt; std::string &gt; const &amp;user_name, mqtt::optional&lt; std::string &gt; const &amp;password, mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;w, std::uint16_t keep_alive_sec, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:ab9ba0fefb75d423e8a513093163f7da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#ab9ba0fefb75d423e8a513093163f7da3">More...</a><br /></td></tr>
<tr class="separator:ab9ba0fefb75d423e8a513093163f7da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291492f077f86217d4b6bc401e701519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a291492f077f86217d4b6bc401e701519">connack</a> (bool session_present, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a291492f077f86217d4b6bc401e701519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#a291492f077f86217d4b6bc401e701519">More...</a><br /></td></tr>
<tr class="separator:a291492f077f86217d4b6bc401e701519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afced92bd371c878c45bf9b357c0d9e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afced92bd371c878c45bf9b357c0d9e99">puback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:afced92bd371c878c45bf9b357c0d9e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="#afced92bd371c878c45bf9b357c0d9e99">More...</a><br /></td></tr>
<tr class="separator:afced92bd371c878c45bf9b357c0d9e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b982f1f1472a467cab3389f7727601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a26b982f1f1472a467cab3389f7727601">pubrec</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a26b982f1f1472a467cab3389f7727601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="#a26b982f1f1472a467cab3389f7727601">More...</a><br /></td></tr>
<tr class="separator:a26b982f1f1472a467cab3389f7727601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6237c9a7bdcce57ffd76f25695e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a57f6237c9a7bdcce57ffd76f25695e84">pubrel</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a57f6237c9a7bdcce57ffd76f25695e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="#a57f6237c9a7bdcce57ffd76f25695e84">More...</a><br /></td></tr>
<tr class="separator:a57f6237c9a7bdcce57ffd76f25695e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93187695d57b90e5c879169216cdaa4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a93187695d57b90e5c879169216cdaa4a">pubcomp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a93187695d57b90e5c879169216cdaa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="#a93187695d57b90e5c879169216cdaa4a">More...</a><br /></td></tr>
<tr class="separator:a93187695d57b90e5c879169216cdaa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384515a1105c2efa19a8172797b45590"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a384515a1105c2efa19a8172797b45590"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a384515a1105c2efa19a8172797b45590">suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a384515a1105c2efa19a8172797b45590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a384515a1105c2efa19a8172797b45590">More...</a><br /></td></tr>
<tr class="separator:a384515a1105c2efa19a8172797b45590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55ff86d5383fde631c78039d519f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5c55ff86d5383fde631c78039d519f51">suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a5c55ff86d5383fde631c78039d519f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a5c55ff86d5383fde631c78039d519f51">More...</a><br /></td></tr>
<tr class="separator:a5c55ff86d5383fde631c78039d519f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ecdf3b7c671aa3f2c0993380a634b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a199ecdf3b7c671aa3f2c0993380a634b">unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a199ecdf3b7c671aa3f2c0993380a634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#a199ecdf3b7c671aa3f2c0993380a634b">More...</a><br /></td></tr>
<tr class="separator:a199ecdf3b7c671aa3f2c0993380a634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3bada4794beb926418b1e144e0c849"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aec3bada4794beb926418b1e144e0c849"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aec3bada4794beb926418b1e144e0c849">unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aec3bada4794beb926418b1e144e0c849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#aec3bada4794beb926418b1e144e0c849">More...</a><br /></td></tr>
<tr class="separator:aec3bada4794beb926418b1e144e0c849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17ae6c772649a38ec6bc32e58b7197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5e17ae6c772649a38ec6bc32e58b7197">unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={})</td></tr>
<tr class="memdesc:a5e17ae6c772649a38ec6bc32e58b7197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#a5e17ae6c772649a38ec6bc32e58b7197">More...</a><br /></td></tr>
<tr class="separator:a5e17ae6c772649a38ec6bc32e58b7197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fead2a16725e99fe2633356faf2f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a32fead2a16725e99fe2633356faf2f74">async_publish_at_most_once</a> (std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a32fead2a16725e99fe2633356faf2f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#a32fead2a16725e99fe2633356faf2f74">More...</a><br /></td></tr>
<tr class="separator:a32fead2a16725e99fe2633356faf2f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd544032c17fd7fadd22b99fcb2a604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afcd544032c17fd7fadd22b99fcb2a604">async_publish_at_most_once</a> (std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:afcd544032c17fd7fadd22b99fcb2a604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#afcd544032c17fd7fadd22b99fcb2a604">More...</a><br /></td></tr>
<tr class="separator:afcd544032c17fd7fadd22b99fcb2a604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80cdd7418f7447d9a31d82e15bef80a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad80cdd7418f7447d9a31d82e15bef80a">async_publish_at_most_once</a> (as::const_buffer topic_name, as::const_buffer contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad80cdd7418f7447d9a31d82e15bef80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0 topic_name and contents are reference type. So caller need to keep the lifetime of them until func is called.  <a href="#ad80cdd7418f7447d9a31d82e15bef80a">More...</a><br /></td></tr>
<tr class="separator:ad80cdd7418f7447d9a31d82e15bef80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3284712b74ef9ebe38e54dc1f3df4aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3284712b74ef9ebe38e54dc1f3df4aaf">async_publish_at_most_once</a> (as::const_buffer topic_name, as::const_buffer contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3284712b74ef9ebe38e54dc1f3df4aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0 topic_name and contents are reference type. So caller need to keep the lifetime of them until func is called.  <a href="#a3284712b74ef9ebe38e54dc1f3df4aaf">More...</a><br /></td></tr>
<tr class="separator:a3284712b74ef9ebe38e54dc1f3df4aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640deeafc6f9097f08e045152541a503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a640deeafc6f9097f08e045152541a503">async_publish_at_least_once</a> (std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a640deeafc6f9097f08e045152541a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a640deeafc6f9097f08e045152541a503">More...</a><br /></td></tr>
<tr class="separator:a640deeafc6f9097f08e045152541a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcf11e590444584b5219a33742cb9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aebcf11e590444584b5219a33742cb9cb">async_publish_at_least_once</a> (std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aebcf11e590444584b5219a33742cb9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#aebcf11e590444584b5219a33742cb9cb">More...</a><br /></td></tr>
<tr class="separator:aebcf11e590444584b5219a33742cb9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e3b7c23c9ddebd0c5fa95c2ee854b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af5e3b7c23c9ddebd0c5fa95c2ee854b2">async_publish_at_least_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:af5e3b7c23c9ddebd0c5fa95c2ee854b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#af5e3b7c23c9ddebd0c5fa95c2ee854b2">More...</a><br /></td></tr>
<tr class="separator:af5e3b7c23c9ddebd0c5fa95c2ee854b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a03775a57b335cd32bbfa316f039654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9a03775a57b335cd32bbfa316f039654">async_publish_at_least_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9a03775a57b335cd32bbfa316f039654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a9a03775a57b335cd32bbfa316f039654">More...</a><br /></td></tr>
<tr class="separator:a9a03775a57b335cd32bbfa316f039654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0508571c30b1a4ad9bc50cace564108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae0508571c30b1a4ad9bc50cace564108">async_publish_exactly_once</a> (std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae0508571c30b1a4ad9bc50cace564108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#ae0508571c30b1a4ad9bc50cace564108">More...</a><br /></td></tr>
<tr class="separator:ae0508571c30b1a4ad9bc50cace564108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cef7a5440ee2439fc6ccd054af1cee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6cef7a5440ee2439fc6ccd054af1cee9">async_publish_exactly_once</a> (std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6cef7a5440ee2439fc6ccd054af1cee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a6cef7a5440ee2439fc6ccd054af1cee9">More...</a><br /></td></tr>
<tr class="separator:a6cef7a5440ee2439fc6ccd054af1cee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1649e77478a8b1f3be2823cc57cb9b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa1649e77478a8b1f3be2823cc57cb9b6">async_publish_exactly_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa1649e77478a8b1f3be2823cc57cb9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#aa1649e77478a8b1f3be2823cc57cb9b6">More...</a><br /></td></tr>
<tr class="separator:aa1649e77478a8b1f3be2823cc57cb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b1eebe57b5ba3bb0c3297214aafa3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a06b1eebe57b5ba3bb0c3297214aafa3e">async_publish_exactly_once</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a06b1eebe57b5ba3bb0c3297214aafa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a06b1eebe57b5ba3bb0c3297214aafa3e">More...</a><br /></td></tr>
<tr class="separator:a06b1eebe57b5ba3bb0c3297214aafa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9833983e228c66aa115f99686d8cae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac9833983e228c66aa115f99686d8cae5">async_publish</a> (std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac9833983e228c66aa115f99686d8cae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#ac9833983e228c66aa115f99686d8cae5">More...</a><br /></td></tr>
<tr class="separator:ac9833983e228c66aa115f99686d8cae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7c7fb987127c3c500dcca0b59c01ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1a7c7fb987127c3c500dcca0b59c01ba">async_publish</a> (std::string topic_name, std::string contents, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1a7c7fb987127c3c500dcca0b59c01ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#a1a7c7fb987127c3c500dcca0b59c01ba">More...</a><br /></td></tr>
<tr class="separator:a1a7c7fb987127c3c500dcca0b59c01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf56f436991204cc0cb2bd8544b3db35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adf56f436991204cc0cb2bd8544b3db35">async_publish</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:adf56f436991204cc0cb2bd8544b3db35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#adf56f436991204cc0cb2bd8544b3db35">More...</a><br /></td></tr>
<tr class="separator:adf56f436991204cc0cb2bd8544b3db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad892eeecf8833c85d823cfee20183d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aad892eeecf8833c85d823cfee20183d3">async_publish</a> (as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aad892eeecf8833c85d823cfee20183d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#aad892eeecf8833c85d823cfee20183d3">More...</a><br /></td></tr>
<tr class="separator:aad892eeecf8833c85d823cfee20183d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eca16a3c6f85e5ab855037d87ce62ab"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a1eca16a3c6f85e5ab855037d87ce62ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1eca16a3c6f85e5ab855037d87ce62ab">async_subscribe</a> (std::string topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1eca16a3c6f85e5ab855037d87ce62ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a1eca16a3c6f85e5ab855037d87ce62ab">More...</a><br /></td></tr>
<tr class="separator:a1eca16a3c6f85e5ab855037d87ce62ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10044aa182827121804834af339058ca"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a10044aa182827121804834af339058ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a10044aa182827121804834af339058ca">async_subscribe</a> (as::const_buffer topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a10044aa182827121804834af339058ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a10044aa182827121804834af339058ca">More...</a><br /></td></tr>
<tr class="separator:a10044aa182827121804834af339058ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642b16c1f176cf6ecaba4d18d03e72b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6642b16c1f176cf6ecaba4d18d03e72b">async_subscribe</a> (std::string topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6642b16c1f176cf6ecaba4d18d03e72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a6642b16c1f176cf6ecaba4d18d03e72b">More...</a><br /></td></tr>
<tr class="separator:a6642b16c1f176cf6ecaba4d18d03e72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f202861ab13efe6544a45c466c32595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2f202861ab13efe6544a45c466c32595">async_subscribe</a> (std::string topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2f202861ab13efe6544a45c466c32595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a2f202861ab13efe6544a45c466c32595">More...</a><br /></td></tr>
<tr class="separator:a2f202861ab13efe6544a45c466c32595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc5ba17b9186ffc82b10d715c3beac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abbc5ba17b9186ffc82b10d715c3beac2">async_subscribe</a> (as::const_buffer topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:abbc5ba17b9186ffc82b10d715c3beac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#abbc5ba17b9186ffc82b10d715c3beac2">More...</a><br /></td></tr>
<tr class="separator:abbc5ba17b9186ffc82b10d715c3beac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae252d4539d022728bb79d2bd02a458f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae252d4539d022728bb79d2bd02a458f7">async_subscribe</a> (as::const_buffer topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae252d4539d022728bb79d2bd02a458f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ae252d4539d022728bb79d2bd02a458f7">More...</a><br /></td></tr>
<tr class="separator:ae252d4539d022728bb79d2bd02a458f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e721d4e8dbd880a5942591af8ba76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac1e721d4e8dbd880a5942591af8ba76c">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac1e721d4e8dbd880a5942591af8ba76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ac1e721d4e8dbd880a5942591af8ba76c">More...</a><br /></td></tr>
<tr class="separator:ac1e721d4e8dbd880a5942591af8ba76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af276c5baa6729834f546df75df986ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af276c5baa6729834f546df75df986ed6">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:af276c5baa6729834f546df75df986ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#af276c5baa6729834f546df75df986ed6">More...</a><br /></td></tr>
<tr class="separator:af276c5baa6729834f546df75df986ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6765d88c3832e0241b247b96401b21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac6765d88c3832e0241b247b96401b21f">async_subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac6765d88c3832e0241b247b96401b21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ac6765d88c3832e0241b247b96401b21f">More...</a><br /></td></tr>
<tr class="separator:ac6765d88c3832e0241b247b96401b21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da37a719954e6c323f34ce145d582f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab4da37a719954e6c323f34ce145d582f">async_subscribe</a> (std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab4da37a719954e6c323f34ce145d582f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ab4da37a719954e6c323f34ce145d582f">More...</a><br /></td></tr>
<tr class="separator:ab4da37a719954e6c323f34ce145d582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3d6bc1fae013220a62d3c935318662"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a1d3d6bc1fae013220a62d3c935318662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1d3d6bc1fae013220a62d3c935318662">async_unsubscribe</a> (std::string topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1d3d6bc1fae013220a62d3c935318662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a1d3d6bc1fae013220a62d3c935318662">More...</a><br /></td></tr>
<tr class="separator:a1d3d6bc1fae013220a62d3c935318662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adc91b8fa6c23b4687f8ac41061089d"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a0adc91b8fa6c23b4687f8ac41061089d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0adc91b8fa6c23b4687f8ac41061089d">async_unsubscribe</a> (as::const_buffer topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0adc91b8fa6c23b4687f8ac41061089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a0adc91b8fa6c23b4687f8ac41061089d">More...</a><br /></td></tr>
<tr class="separator:a0adc91b8fa6c23b4687f8ac41061089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af7fdd038c9ef2bf73a4f27a1543c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a17af7fdd038c9ef2bf73a4f27a1543c2">async_unsubscribe</a> (std::string topic_name, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a17af7fdd038c9ef2bf73a4f27a1543c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a17af7fdd038c9ef2bf73a4f27a1543c2">More...</a><br /></td></tr>
<tr class="separator:a17af7fdd038c9ef2bf73a4f27a1543c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5b6145475d0e5e516d5d909041eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeac5b6145475d0e5e516d5d909041eeb">async_unsubscribe</a> (std::string topic_name, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aeac5b6145475d0e5e516d5d909041eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#aeac5b6145475d0e5e516d5d909041eeb">More...</a><br /></td></tr>
<tr class="separator:aeac5b6145475d0e5e516d5d909041eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081ad8d4698b52a10c64f94b7b157642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a081ad8d4698b52a10c64f94b7b157642">async_unsubscribe</a> (as::const_buffer topic_name, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a081ad8d4698b52a10c64f94b7b157642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a081ad8d4698b52a10c64f94b7b157642">More...</a><br /></td></tr>
<tr class="separator:a081ad8d4698b52a10c64f94b7b157642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1819d0d9dc391f71991d796dcd42bc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1819d0d9dc391f71991d796dcd42bc3a">async_unsubscribe</a> (as::const_buffer topic_name, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1819d0d9dc391f71991d796dcd42bc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a1819d0d9dc391f71991d796dcd42bc3a">More...</a><br /></td></tr>
<tr class="separator:a1819d0d9dc391f71991d796dcd42bc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cd149702675befb6ec9a1439c28713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a30cd149702675befb6ec9a1439c28713">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a30cd149702675befb6ec9a1439c28713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a30cd149702675befb6ec9a1439c28713">More...</a><br /></td></tr>
<tr class="separator:a30cd149702675befb6ec9a1439c28713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e882926f184d2513dcea4a7d1aa1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7b4e882926f184d2513dcea4a7d1aa1c">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7b4e882926f184d2513dcea4a7d1aa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a7b4e882926f184d2513dcea4a7d1aa1c">More...</a><br /></td></tr>
<tr class="separator:a7b4e882926f184d2513dcea4a7d1aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b3cc083ed32b475f93191e8b348f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac87b3cc083ed32b475f93191e8b348f9">async_unsubscribe</a> (std::vector&lt; as::const_buffer &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac87b3cc083ed32b475f93191e8b348f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#ac87b3cc083ed32b475f93191e8b348f9">More...</a><br /></td></tr>
<tr class="separator:ac87b3cc083ed32b475f93191e8b348f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723563c06d9f938200680434389f65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0723563c06d9f938200680434389f65c">async_unsubscribe</a> (std::vector&lt; as::const_buffer &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0723563c06d9f938200680434389f65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a0723563c06d9f938200680434389f65c">More...</a><br /></td></tr>
<tr class="separator:a0723563c06d9f938200680434389f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f874efc0ace8b41427bcf8680f3830b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7f874efc0ace8b41427bcf8680f3830b">async_disconnect</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7f874efc0ace8b41427bcf8680f3830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="#a7f874efc0ace8b41427bcf8680f3830b">More...</a><br /></td></tr>
<tr class="separator:a7f874efc0ace8b41427bcf8680f3830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e9326b8dda7b25ee456b6cc30583a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab9e9326b8dda7b25ee456b6cc30583a1">async_disconnect</a> (std::uint8_t reason, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab9e9326b8dda7b25ee456b6cc30583a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="#ab9e9326b8dda7b25ee456b6cc30583a1">More...</a><br /></td></tr>
<tr class="separator:ab9e9326b8dda7b25ee456b6cc30583a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103df82c9a2ca4391bd25168e22c5cf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a103df82c9a2ca4391bd25168e22c5cf6">async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a103df82c9a2ca4391bd25168e22c5cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a103df82c9a2ca4391bd25168e22c5cf6">More...</a><br /></td></tr>
<tr class="separator:a103df82c9a2ca4391bd25168e22c5cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b4fa94de568fddd84f5fea07b0fa21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a95b4fa94de568fddd84f5fea07b0fa21">async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a95b4fa94de568fddd84f5fea07b0fa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a95b4fa94de568fddd84f5fea07b0fa21">More...</a><br /></td></tr>
<tr class="separator:a95b4fa94de568fddd84f5fea07b0fa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eccad04139b5c96110b12f1ffd352f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac2eccad04139b5c96110b12f1ffd352f">async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac2eccad04139b5c96110b12f1ffd352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#ac2eccad04139b5c96110b12f1ffd352f">More...</a><br /></td></tr>
<tr class="separator:ac2eccad04139b5c96110b12f1ffd352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8228eb186c0dd827ffbc90c276f65ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac8228eb186c0dd827ffbc90c276f65ef">async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac8228eb186c0dd827ffbc90c276f65ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#ac8228eb186c0dd827ffbc90c276f65ef">More...</a><br /></td></tr>
<tr class="separator:ac8228eb186c0dd827ffbc90c276f65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1937a0d5bfafdee2a31de9096cef199f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1937a0d5bfafdee2a31de9096cef199f">async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1937a0d5bfafdee2a31de9096cef199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a1937a0d5bfafdee2a31de9096cef199f">More...</a><br /></td></tr>
<tr class="separator:a1937a0d5bfafdee2a31de9096cef199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3efe36b15caa7b83cdfc3f980aed6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afd3efe36b15caa7b83cdfc3f980aed6f">async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:afd3efe36b15caa7b83cdfc3f980aed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#afd3efe36b15caa7b83cdfc3f980aed6f">More...</a><br /></td></tr>
<tr class="separator:afd3efe36b15caa7b83cdfc3f980aed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732de6062dffd24d3e375e608ec7703e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a732de6062dffd24d3e375e608ec7703e">async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a732de6062dffd24d3e375e608ec7703e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a732de6062dffd24d3e375e608ec7703e">More...</a><br /></td></tr>
<tr class="separator:a732de6062dffd24d3e375e608ec7703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6832d220adfeeb90fbbbf7fccbbf10bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6832d220adfeeb90fbbbf7fccbbf10bf">async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6832d220adfeeb90fbbbf7fccbbf10bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a6832d220adfeeb90fbbbf7fccbbf10bf">More...</a><br /></td></tr>
<tr class="separator:a6832d220adfeeb90fbbbf7fccbbf10bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf9daaf190cd177ba2148e31bc7db31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afdf9daaf190cd177ba2148e31bc7db31">async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:afdf9daaf190cd177ba2148e31bc7db31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#afdf9daaf190cd177ba2148e31bc7db31">More...</a><br /></td></tr>
<tr class="separator:afdf9daaf190cd177ba2148e31bc7db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceca01c1e14f3e1bea87be99959b0dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afceca01c1e14f3e1bea87be99959b0dd">async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:afceca01c1e14f3e1bea87be99959b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#afceca01c1e14f3e1bea87be99959b0dd">More...</a><br /></td></tr>
<tr class="separator:afceca01c1e14f3e1bea87be99959b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2bf2be0d8a76d4eff06a55e43c9cdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afe2bf2be0d8a76d4eff06a55e43c9cdc">async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:afe2bf2be0d8a76d4eff06a55e43c9cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#afe2bf2be0d8a76d4eff06a55e43c9cdc">More...</a><br /></td></tr>
<tr class="separator:afe2bf2be0d8a76d4eff06a55e43c9cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93d7c49f362a7798df5d0b548358d94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab93d7c49f362a7798df5d0b548358d94">async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab93d7c49f362a7798df5d0b548358d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#ab93d7c49f362a7798df5d0b548358d94">More...</a><br /></td></tr>
<tr class="separator:ab93d7c49f362a7798df5d0b548358d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85f124d5be68a5c0ffd35474cab9b01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab85f124d5be68a5c0ffd35474cab9b01">async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab85f124d5be68a5c0ffd35474cab9b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#ab85f124d5be68a5c0ffd35474cab9b01">More...</a><br /></td></tr>
<tr class="separator:ab85f124d5be68a5c0ffd35474cab9b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae8ae1655623fe8572a03179506f9ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abae8ae1655623fe8572a03179506f9ae">async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:abae8ae1655623fe8572a03179506f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#abae8ae1655623fe8572a03179506f9ae">More...</a><br /></td></tr>
<tr class="separator:abae8ae1655623fe8572a03179506f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82fa998b282d19169f2ee52ffd5a518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae82fa998b282d19169f2ee52ffd5a518">async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae82fa998b282d19169f2ee52ffd5a518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#ae82fa998b282d19169f2ee52ffd5a518">More...</a><br /></td></tr>
<tr class="separator:ae82fa998b282d19169f2ee52ffd5a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8917be1a8888bb88b94683cf69f28a5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8917be1a8888bb88b94683cf69f28a5b">async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8917be1a8888bb88b94683cf69f28a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a8917be1a8888bb88b94683cf69f28a5b">More...</a><br /></td></tr>
<tr class="separator:a8917be1a8888bb88b94683cf69f28a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d40b13797ac00c4021009a00af491f"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a59d40b13797ac00c4021009a00af491f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a59d40b13797ac00c4021009a00af491f">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a59d40b13797ac00c4021009a00af491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a59d40b13797ac00c4021009a00af491f">More...</a><br /></td></tr>
<tr class="separator:a59d40b13797ac00c4021009a00af491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d784f450b7039e748e8732ad4b18348"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a5d784f450b7039e748e8732ad4b18348"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5d784f450b7039e748e8732ad4b18348">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5d784f450b7039e748e8732ad4b18348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a5d784f450b7039e748e8732ad4b18348">More...</a><br /></td></tr>
<tr class="separator:a5d784f450b7039e748e8732ad4b18348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478e71e1328eda6966ec735b5f49d399"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a478e71e1328eda6966ec735b5f49d399">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a478e71e1328eda6966ec735b5f49d399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a478e71e1328eda6966ec735b5f49d399">More...</a><br /></td></tr>
<tr class="separator:a478e71e1328eda6966ec735b5f49d399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff974827dfda9a99d35588167ee752c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aaff974827dfda9a99d35588167ee752c">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aaff974827dfda9a99d35588167ee752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#aaff974827dfda9a99d35588167ee752c">More...</a><br /></td></tr>
<tr class="separator:aaff974827dfda9a99d35588167ee752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bce4c55ec09fcf6dd3052f3e6556d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad5bce4c55ec09fcf6dd3052f3e6556d1">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad5bce4c55ec09fcf6dd3052f3e6556d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ad5bce4c55ec09fcf6dd3052f3e6556d1">More...</a><br /></td></tr>
<tr class="separator:ad5bce4c55ec09fcf6dd3052f3e6556d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab265cf5d301db95942ff30a5347a466f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab265cf5d301db95942ff30a5347a466f">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab265cf5d301db95942ff30a5347a466f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ab265cf5d301db95942ff30a5347a466f">More...</a><br /></td></tr>
<tr class="separator:ab265cf5d301db95942ff30a5347a466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274b84d7322c92b55e6eb6eb404cfe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac274b84d7322c92b55e6eb6eb404cfe5">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac274b84d7322c92b55e6eb6eb404cfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ac274b84d7322c92b55e6eb6eb404cfe5">More...</a><br /></td></tr>
<tr class="separator:ac274b84d7322c92b55e6eb6eb404cfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa3e7d4e8478a423b2f7a3b3eaeab50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6fa3e7d4e8478a423b2f7a3b3eaeab50">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a6fa3e7d4e8478a423b2f7a3b3eaeab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a6fa3e7d4e8478a423b2f7a3b3eaeab50">More...</a><br /></td></tr>
<tr class="separator:a6fa3e7d4e8478a423b2f7a3b3eaeab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ba40c82db50e6f8aa9d2c7a6459716"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a48ba40c82db50e6f8aa9d2c7a6459716">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a48ba40c82db50e6f8aa9d2c7a6459716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a48ba40c82db50e6f8aa9d2c7a6459716">More...</a><br /></td></tr>
<tr class="separator:a48ba40c82db50e6f8aa9d2c7a6459716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378982884babca66babaee989301756e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a378982884babca66babaee989301756e">async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a378982884babca66babaee989301756e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a378982884babca66babaee989301756e">More...</a><br /></td></tr>
<tr class="separator:a378982884babca66babaee989301756e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c65d2e437c52f4ecb3be863fcf338"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ada8c65d2e437c52f4ecb3be863fcf338"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ada8c65d2e437c52f4ecb3be863fcf338">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ada8c65d2e437c52f4ecb3be863fcf338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#ada8c65d2e437c52f4ecb3be863fcf338">More...</a><br /></td></tr>
<tr class="separator:ada8c65d2e437c52f4ecb3be863fcf338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac96dd36834c2124e486ff9c0bd21b6"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a6ac96dd36834c2124e486ff9c0bd21b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6ac96dd36834c2124e486ff9c0bd21b6">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ac96dd36834c2124e486ff9c0bd21b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a6ac96dd36834c2124e486ff9c0bd21b6">More...</a><br /></td></tr>
<tr class="separator:a6ac96dd36834c2124e486ff9c0bd21b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300604f424d7224ef19d432a5d938f60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a300604f424d7224ef19d432a5d938f60">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a300604f424d7224ef19d432a5d938f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a300604f424d7224ef19d432a5d938f60">More...</a><br /></td></tr>
<tr class="separator:a300604f424d7224ef19d432a5d938f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a6a306460b1b7d49f664148c794088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a27a6a306460b1b7d49f664148c794088">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a27a6a306460b1b7d49f664148c794088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a27a6a306460b1b7d49f664148c794088">More...</a><br /></td></tr>
<tr class="separator:a27a6a306460b1b7d49f664148c794088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c722ef52e6e5b2ff15cbbb3f596929"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae7c722ef52e6e5b2ff15cbbb3f596929">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae7c722ef52e6e5b2ff15cbbb3f596929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#ae7c722ef52e6e5b2ff15cbbb3f596929">More...</a><br /></td></tr>
<tr class="separator:ae7c722ef52e6e5b2ff15cbbb3f596929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa9a7011f029e376353fe1f4dee3c32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aaaa9a7011f029e376353fe1f4dee3c32">async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; const &amp;params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aaaa9a7011f029e376353fe1f4dee3c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#aaaa9a7011f029e376353fe1f4dee3c32">More...</a><br /></td></tr>
<tr class="separator:aaaa9a7011f029e376353fe1f4dee3c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08d68c1bbd840941ca81a601a09b9f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad08d68c1bbd840941ca81a601a09b9f1">acquired_async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad08d68c1bbd840941ca81a601a09b9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#ad08d68c1bbd840941ca81a601a09b9f1">More...</a><br /></td></tr>
<tr class="separator:ad08d68c1bbd840941ca81a601a09b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8e67d6c196cf347592373ce6eae5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a96c8e67d6c196cf347592373ce6eae5b">acquired_async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a96c8e67d6c196cf347592373ce6eae5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a96c8e67d6c196cf347592373ce6eae5b">More...</a><br /></td></tr>
<tr class="separator:a96c8e67d6c196cf347592373ce6eae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cf1e9973a3af7a94daeed11103cbe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a16cf1e9973a3af7a94daeed11103cbe8">acquired_async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a16cf1e9973a3af7a94daeed11103cbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a16cf1e9973a3af7a94daeed11103cbe8">More...</a><br /></td></tr>
<tr class="separator:a16cf1e9973a3af7a94daeed11103cbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482b270a38ceb3c7ca4615de3b98194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae482b270a38ceb3c7ca4615de3b98194">acquired_async_publish_at_least_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae482b270a38ceb3c7ca4615de3b98194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#ae482b270a38ceb3c7ca4615de3b98194">More...</a><br /></td></tr>
<tr class="separator:ae482b270a38ceb3c7ca4615de3b98194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f20161c3920f24163ee71c03b68887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af6f20161c3920f24163ee71c03b68887">acquired_async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:af6f20161c3920f24163ee71c03b68887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#af6f20161c3920f24163ee71c03b68887">More...</a><br /></td></tr>
<tr class="separator:af6f20161c3920f24163ee71c03b68887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2d2c34e5908221fe8b90d8d7d06e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3e2d2c34e5908221fe8b90d8d7d06e7a">acquired_async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3e2d2c34e5908221fe8b90d8d7d06e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a3e2d2c34e5908221fe8b90d8d7d06e7a">More...</a><br /></td></tr>
<tr class="separator:a3e2d2c34e5908221fe8b90d8d7d06e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6cbc431cc2ca2c99a9f2903280973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a77f6cbc431cc2ca2c99a9f2903280973">acquired_async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a77f6cbc431cc2ca2c99a9f2903280973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a77f6cbc431cc2ca2c99a9f2903280973">More...</a><br /></td></tr>
<tr class="separator:a77f6cbc431cc2ca2c99a9f2903280973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a39b4e96e1d08daa1ab08ccda037183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4a39b4e96e1d08daa1ab08ccda037183">acquired_async_publish_exactly_once</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4a39b4e96e1d08daa1ab08ccda037183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a4a39b4e96e1d08daa1ab08ccda037183">More...</a><br /></td></tr>
<tr class="separator:a4a39b4e96e1d08daa1ab08ccda037183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e181da0361a311b735726b3fc0066d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa5e181da0361a311b735726b3fc0066d">acquired_async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa5e181da0361a311b735726b3fc0066d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#aa5e181da0361a311b735726b3fc0066d">More...</a><br /></td></tr>
<tr class="separator:aa5e181da0361a311b735726b3fc0066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89211189102aa25d2ea1ed2a27ef2f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a89211189102aa25d2ea1ed2a27ef2f7a">acquired_async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a89211189102aa25d2ea1ed2a27ef2f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a89211189102aa25d2ea1ed2a27ef2f7a">More...</a><br /></td></tr>
<tr class="separator:a89211189102aa25d2ea1ed2a27ef2f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2c2877266eaf7ad6fbdaf2e1e20d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8fc2c2877266eaf7ad6fbdaf2e1e20d5">acquired_async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8fc2c2877266eaf7ad6fbdaf2e1e20d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a8fc2c2877266eaf7ad6fbdaf2e1e20d5">More...</a><br /></td></tr>
<tr class="separator:a8fc2c2877266eaf7ad6fbdaf2e1e20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1700da73f17dcff1fcfb773b5a72e7d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1700da73f17dcff1fcfb773b5a72e7d7">acquired_async_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1700da73f17dcff1fcfb773b5a72e7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a1700da73f17dcff1fcfb773b5a72e7d7">More...</a><br /></td></tr>
<tr class="separator:a1700da73f17dcff1fcfb773b5a72e7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24037fd1bf10e5062e804e6742f742c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a24037fd1bf10e5062e804e6742f742c1">acquired_async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a24037fd1bf10e5062e804e6742f742c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a24037fd1bf10e5062e804e6742f742c1">More...</a><br /></td></tr>
<tr class="separator:a24037fd1bf10e5062e804e6742f742c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4d86c49edaf4910c2d7edcff6e6695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aef4d86c49edaf4910c2d7edcff6e6695">acquired_async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::string contents, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aef4d86c49edaf4910c2d7edcff6e6695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#aef4d86c49edaf4910c2d7edcff6e6695">More...</a><br /></td></tr>
<tr class="separator:aef4d86c49edaf4910c2d7edcff6e6695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea77fddd9cc130c9afc2a8bb5ea252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a60ea77fddd9cc130c9afc2a8bb5ea252">acquired_async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a60ea77fddd9cc130c9afc2a8bb5ea252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a60ea77fddd9cc130c9afc2a8bb5ea252">More...</a><br /></td></tr>
<tr class="separator:a60ea77fddd9cc130c9afc2a8bb5ea252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d3101edd529ad96c0ee372320aaf38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af9d3101edd529ad96c0ee372320aaf38">acquired_async_publish_dup</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, as::const_buffer contents, mqtt::any life_keeper, std::uint8_t qos, bool retain, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:af9d3101edd529ad96c0ee372320aaf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#af9d3101edd529ad96c0ee372320aaf38">More...</a><br /></td></tr>
<tr class="separator:af9d3101edd529ad96c0ee372320aaf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358cf52197813c9e456f51ecd89413a3"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a358cf52197813c9e456f51ecd89413a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a358cf52197813c9e456f51ecd89413a3">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a358cf52197813c9e456f51ecd89413a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a358cf52197813c9e456f51ecd89413a3">More...</a><br /></td></tr>
<tr class="separator:a358cf52197813c9e456f51ecd89413a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922a30774801b072244036fee609b31d"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a922a30774801b072244036fee609b31d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a922a30774801b072244036fee609b31d">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a922a30774801b072244036fee609b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a922a30774801b072244036fee609b31d">More...</a><br /></td></tr>
<tr class="separator:a922a30774801b072244036fee609b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2667a5a25c42daf06fd75982cfc39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aea2667a5a25c42daf06fd75982cfc39f">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aea2667a5a25c42daf06fd75982cfc39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#aea2667a5a25c42daf06fd75982cfc39f">More...</a><br /></td></tr>
<tr class="separator:aea2667a5a25c42daf06fd75982cfc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4d793a5f9ae71ed3a6bfbee530bbb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1c4d793a5f9ae71ed3a6bfbee530bbb8">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1c4d793a5f9ae71ed3a6bfbee530bbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a1c4d793a5f9ae71ed3a6bfbee530bbb8">More...</a><br /></td></tr>
<tr class="separator:a1c4d793a5f9ae71ed3a6bfbee530bbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a145cff70125f4326932288922691d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa8a145cff70125f4326932288922691d">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa8a145cff70125f4326932288922691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#aa8a145cff70125f4326932288922691d">More...</a><br /></td></tr>
<tr class="separator:aa8a145cff70125f4326932288922691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d089a72e9364286eb7163cb2d981ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0d089a72e9364286eb7163cb2d981ce7">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, std::uint8_t option, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0d089a72e9364286eb7163cb2d981ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a0d089a72e9364286eb7163cb2d981ce7">More...</a><br /></td></tr>
<tr class="separator:a0d089a72e9364286eb7163cb2d981ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceff57062abd8ddcc19080de826cec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adceff57062abd8ddcc19080de826cec5">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:adceff57062abd8ddcc19080de826cec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#adceff57062abd8ddcc19080de826cec5">More...</a><br /></td></tr>
<tr class="separator:adceff57062abd8ddcc19080de826cec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3350319184f35c4ca0b86ed19c4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7ed3350319184f35c4ca0b86ed19c4dd">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7ed3350319184f35c4ca0b86ed19c4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a7ed3350319184f35c4ca0b86ed19c4dd">More...</a><br /></td></tr>
<tr class="separator:a7ed3350319184f35c4ca0b86ed19c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da9c4cf5ea485d585c7538818a96e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4da9c4cf5ea485d585c7538818a96e41">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4da9c4cf5ea485d585c7538818a96e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a4da9c4cf5ea485d585c7538818a96e41">More...</a><br /></td></tr>
<tr class="separator:a4da9c4cf5ea485d585c7538818a96e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab785cf0faa04874e70e7f7b4c2f8ee5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab785cf0faa04874e70e7f7b4c2f8ee5d">acquired_async_subscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ab785cf0faa04874e70e7f7b4c2f8ee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#ab785cf0faa04874e70e7f7b4c2f8ee5d">More...</a><br /></td></tr>
<tr class="separator:ab785cf0faa04874e70e7f7b4c2f8ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33918e8224d46e1909004fd395fd56e4"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a33918e8224d46e1909004fd395fd56e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a33918e8224d46e1909004fd395fd56e4">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::string topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a33918e8224d46e1909004fd395fd56e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a33918e8224d46e1909004fd395fd56e4">More...</a><br /></td></tr>
<tr class="separator:a33918e8224d46e1909004fd395fd56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53622e9d0690a5b0a1f2e9033eb14ae"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ac53622e9d0690a5b0a1f2e9033eb14ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac53622e9d0690a5b0a1f2e9033eb14ae">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, as::const_buffer topic_name, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac53622e9d0690a5b0a1f2e9033eb14ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#ac53622e9d0690a5b0a1f2e9033eb14ae">More...</a><br /></td></tr>
<tr class="separator:ac53622e9d0690a5b0a1f2e9033eb14ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f94457610fb3fb2d38e966b5865130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a34f94457610fb3fb2d38e966b5865130">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a34f94457610fb3fb2d38e966b5865130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a34f94457610fb3fb2d38e966b5865130">More...</a><br /></td></tr>
<tr class="separator:a34f94457610fb3fb2d38e966b5865130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1628a6b5c97464ffb35c83f83509f1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1628a6b5c97464ffb35c83f83509f1f1">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::string &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1628a6b5c97464ffb35c83f83509f1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a1628a6b5c97464ffb35c83f83509f1f1">More...</a><br /></td></tr>
<tr class="separator:a1628a6b5c97464ffb35c83f83509f1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6da0d99b2ccd4501c9926bace6a7b52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af6da0d99b2ccd4501c9926bace6a7b52">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:af6da0d99b2ccd4501c9926bace6a7b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#af6da0d99b2ccd4501c9926bace6a7b52">More...</a><br /></td></tr>
<tr class="separator:af6da0d99b2ccd4501c9926bace6a7b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e6cf64761b4e76dc7ef91573ea108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1c4e6cf64761b4e76dc7ef91573ea108">acquired_async_unsubscribe</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; as::const_buffer &gt; params, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1c4e6cf64761b4e76dc7ef91573ea108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a1c4e6cf64761b4e76dc7ef91573ea108">More...</a><br /></td></tr>
<tr class="separator:a1c4e6cf64761b4e76dc7ef91573ea108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11230cd247801c5d6d85efd8e4e4b568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a11230cd247801c5d6d85efd8e4e4b568">async_pingreq</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a11230cd247801c5d6d85efd8e4e4b568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet.  <a href="#a11230cd247801c5d6d85efd8e4e4b568">More...</a><br /></td></tr>
<tr class="separator:a11230cd247801c5d6d85efd8e4e4b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9083fee8e1d585159550fbf85e505f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2e9083fee8e1d585159550fbf85e505f">async_pingresp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2e9083fee8e1d585159550fbf85e505f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker.  <a href="#a2e9083fee8e1d585159550fbf85e505f">More...</a><br /></td></tr>
<tr class="separator:a2e9083fee8e1d585159550fbf85e505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31cefea6066e2f06a6f6b5089522008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac31cefea6066e2f06a6f6b5089522008">async_auth</a> (mqtt::optional&lt; std::uint8_t &gt; reason_code=mqtt::nullopt, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props={}, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac31cefea6066e2f06a6f6b5089522008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send auth packet.  <a href="#ac31cefea6066e2f06a6f6b5089522008">More...</a><br /></td></tr>
<tr class="separator:ac31cefea6066e2f06a6f6b5089522008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218ebf1af18477a192434573de9d7095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a218ebf1af18477a192434573de9d7095">async_connect</a> (std::string const &amp;client_id, mqtt::optional&lt; std::string &gt; const &amp;user_name, mqtt::optional&lt; std::string &gt; const &amp;password, mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;w, std::uint16_t keep_alive_sec, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a218ebf1af18477a192434573de9d7095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#a218ebf1af18477a192434573de9d7095">More...</a><br /></td></tr>
<tr class="separator:a218ebf1af18477a192434573de9d7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5d89685e72378cea501e8ba5cfaa3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0b5d89685e72378cea501e8ba5cfaa3e">async_connect</a> (std::string const &amp;client_id, mqtt::optional&lt; std::string &gt; const &amp;user_name, mqtt::optional&lt; std::string &gt; const &amp;password, mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;w, std::uint16_t keep_alive_sec, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0b5d89685e72378cea501e8ba5cfaa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#a0b5d89685e72378cea501e8ba5cfaa3e">More...</a><br /></td></tr>
<tr class="separator:a0b5d89685e72378cea501e8ba5cfaa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2784a5d25a1bfd6603e15cf1f796503e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2784a5d25a1bfd6603e15cf1f796503e">async_connack</a> (bool session_present, std::uint8_t reason_code, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2784a5d25a1bfd6603e15cf1f796503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#a2784a5d25a1bfd6603e15cf1f796503e">More...</a><br /></td></tr>
<tr class="separator:a2784a5d25a1bfd6603e15cf1f796503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf45dc1594c63e911b814317e19e27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aecf45dc1594c63e911b814317e19e27f">async_connack</a> (bool session_present, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aecf45dc1594c63e911b814317e19e27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#aecf45dc1594c63e911b814317e19e27f">More...</a><br /></td></tr>
<tr class="separator:aecf45dc1594c63e911b814317e19e27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee368cd21c8060a5dd276df761c3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a11ee368cd21c8060a5dd276df761c3d0">async_puback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a11ee368cd21c8060a5dd276df761c3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="#a11ee368cd21c8060a5dd276df761c3d0">More...</a><br /></td></tr>
<tr class="separator:a11ee368cd21c8060a5dd276df761c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc0d56eef84a4b9730c283bf094e0fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2cc0d56eef84a4b9730c283bf094e0fa">async_puback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2cc0d56eef84a4b9730c283bf094e0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  <a href="#a2cc0d56eef84a4b9730c283bf094e0fa">More...</a><br /></td></tr>
<tr class="separator:a2cc0d56eef84a4b9730c283bf094e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a5e26b566889a1c6b8f632149d860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a786a5e26b566889a1c6b8f632149d860">async_pubrec</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a786a5e26b566889a1c6b8f632149d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="#a786a5e26b566889a1c6b8f632149d860">More...</a><br /></td></tr>
<tr class="separator:a786a5e26b566889a1c6b8f632149d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a321c7968bc9c44aad9dcdeb2326b9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2a321c7968bc9c44aad9dcdeb2326b9f">async_pubrec</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2a321c7968bc9c44aad9dcdeb2326b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  <a href="#a2a321c7968bc9c44aad9dcdeb2326b9f">More...</a><br /></td></tr>
<tr class="separator:a2a321c7968bc9c44aad9dcdeb2326b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa814c1f25e218fbacb6912208c6f6642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa814c1f25e218fbacb6912208c6f6642">async_pubrel</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa814c1f25e218fbacb6912208c6f6642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="#aa814c1f25e218fbacb6912208c6f6642">More...</a><br /></td></tr>
<tr class="separator:aa814c1f25e218fbacb6912208c6f6642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0224a7239b0ddfa0f64632f3bb4bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1f0224a7239b0ddfa0f64632f3bb4bda">async_pubrel</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1f0224a7239b0ddfa0f64632f3bb4bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  <a href="#a1f0224a7239b0ddfa0f64632f3bb4bda">More...</a><br /></td></tr>
<tr class="separator:a1f0224a7239b0ddfa0f64632f3bb4bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d9f2a049dfccc2c88007819a4c8f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a03d9f2a049dfccc2c88007819a4c8f6d">async_pubcomp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a03d9f2a049dfccc2c88007819a4c8f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="#a03d9f2a049dfccc2c88007819a4c8f6d">More...</a><br /></td></tr>
<tr class="separator:a03d9f2a049dfccc2c88007819a4c8f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca08caa9162d59db52fe0cdb7daed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeaca08caa9162d59db52fe0cdb7daed1">async_pubcomp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:aeaca08caa9162d59db52fe0cdb7daed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  <a href="#aeaca08caa9162d59db52fe0cdb7daed1">More...</a><br /></td></tr>
<tr class="separator:aeaca08caa9162d59db52fe0cdb7daed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055cdce0175f1bce02ab1f81c8591793"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a055cdce0175f1bce02ab1f81c8591793"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a055cdce0175f1bce02ab1f81c8591793">async_suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a055cdce0175f1bce02ab1f81c8591793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a055cdce0175f1bce02ab1f81c8591793">More...</a><br /></td></tr>
<tr class="separator:a055cdce0175f1bce02ab1f81c8591793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8005fa7c219c6e42e35838dbfe2876b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac8005fa7c219c6e42e35838dbfe2876b">async_suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac8005fa7c219c6e42e35838dbfe2876b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#ac8005fa7c219c6e42e35838dbfe2876b">More...</a><br /></td></tr>
<tr class="separator:ac8005fa7c219c6e42e35838dbfe2876b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fe2e23301b898410206945c345e995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a00fe2e23301b898410206945c345e995">async_suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a00fe2e23301b898410206945c345e995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a00fe2e23301b898410206945c345e995">More...</a><br /></td></tr>
<tr class="separator:a00fe2e23301b898410206945c345e995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d0e1526a7d82895017268f2edd550d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a32d0e1526a7d82895017268f2edd550d">async_suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a32d0e1526a7d82895017268f2edd550d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a32d0e1526a7d82895017268f2edd550d">More...</a><br /></td></tr>
<tr class="separator:a32d0e1526a7d82895017268f2edd550d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed8ff917fbfb34faf502fc190b8ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a86ed8ff917fbfb34faf502fc190b8ea3">async_suback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a86ed8ff917fbfb34faf502fc190b8ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  <a href="#a86ed8ff917fbfb34faf502fc190b8ea3">More...</a><br /></td></tr>
<tr class="separator:a86ed8ff917fbfb34faf502fc190b8ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa1b64f191519714e8febbfd5724353"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:afaa1b64f191519714e8febbfd5724353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afaa1b64f191519714e8febbfd5724353">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afaa1b64f191519714e8febbfd5724353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#afaa1b64f191519714e8febbfd5724353">More...</a><br /></td></tr>
<tr class="separator:afaa1b64f191519714e8febbfd5724353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073afbfce14cbbd269cb618206fa14a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3073afbfce14cbbd269cb618206fa14a">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3073afbfce14cbbd269cb618206fa14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#a3073afbfce14cbbd269cb618206fa14a">More...</a><br /></td></tr>
<tr class="separator:a3073afbfce14cbbd269cb618206fa14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243c953c02a91d64fdcc9ffb8ef8bd5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a243c953c02a91d64fdcc9ffb8ef8bd5d">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a243c953c02a91d64fdcc9ffb8ef8bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#a243c953c02a91d64fdcc9ffb8ef8bd5d">More...</a><br /></td></tr>
<tr class="separator:a243c953c02a91d64fdcc9ffb8ef8bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b179cec296dade14363ab6f88040092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2b179cec296dade14363ab6f88040092">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2b179cec296dade14363ab6f88040092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#a2b179cec296dade14363ab6f88040092">More...</a><br /></td></tr>
<tr class="separator:a2b179cec296dade14363ab6f88040092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c0664cf14ee7e4adb3fc1b9d3df7cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad0c0664cf14ee7e4adb3fc1b9d3df7cc">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt; std::uint8_t &gt; reasons, std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt; props, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:ad0c0664cf14ee7e4adb3fc1b9d3df7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  <a href="#ad0c0664cf14ee7e4adb3fc1b9d3df7cc">More...</a><br /></td></tr>
<tr class="separator:ad0c0664cf14ee7e4adb3fc1b9d3df7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5630023d857c3ba948e6c633e7a952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3d5630023d857c3ba948e6c633e7a952">async_unsuback</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func=<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>())</td></tr>
<tr class="memdesc:a3d5630023d857c3ba948e6c633e7a952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send ununsuback packet. This function is for broker.  <a href="#a3d5630023d857c3ba948e6c633e7a952">More...</a><br /></td></tr>
<tr class="separator:a3d5630023d857c3ba948e6c633e7a952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d11dcacb8c97035b4b75baafe794f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a20d11dcacb8c97035b4b75baafe794f8">clear_stored_publish</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a20d11dcacb8c97035b4b75baafe794f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stored publish message that has packet_id.  <a href="#a20d11dcacb8c97035b4b75baafe794f8">More...</a><br /></td></tr>
<tr class="separator:a20d11dcacb8c97035b4b75baafe794f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343315ef280f69efadc7be61fe658909"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a343315ef280f69efadc7be61fe658909">socket</a> ()</td></tr>
<tr class="memdesc:a343315ef280f69efadc7be61fe658909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Socket unique_ptr reference.  <a href="#a343315ef280f69efadc7be61fe658909">More...</a><br /></td></tr>
<tr class="separator:a343315ef280f69efadc7be61fe658909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2a59f50ac9f19c63ef57a50f0d80ca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afd2a59f50ac9f19c63ef57a50f0d80ca">socket</a> () const</td></tr>
<tr class="memdesc:afd2a59f50ac9f19c63ef57a50f0d80ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Socket unique_ptr const reference.  <a href="#afd2a59f50ac9f19c63ef57a50f0d80ca">More...</a><br /></td></tr>
<tr class="separator:afd2a59f50ac9f19c63ef57a50f0d80ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca56d4103e725936758a86d1c67595e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0ca56d4103e725936758a86d1c67595e">for_each_store</a> (std::function&lt; void(char const *, std::size_t)&gt; const &amp;f)</td></tr>
<tr class="memdesc:a0ca56d4103e725936758a86d1c67595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="#a0ca56d4103e725936758a86d1c67595e">More...</a><br /></td></tr>
<tr class="separator:a0ca56d4103e725936758a86d1c67595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2a947dd1d437bcd87a872a70c5d118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abf2a947dd1d437bcd87a872a70c5d118">for_each_store</a> (std::function&lt; void(<a class="el" href="namespacemqtt.html#a76c9863f7830ff23b2d56e3db1370a76">message_variant</a> const &amp;)&gt; const &amp;f)</td></tr>
<tr class="memdesc:abf2a947dd1d437bcd87a872a70c5d118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  <a href="#abf2a947dd1d437bcd87a872a70c5d118">More...</a><br /></td></tr>
<tr class="separator:abf2a947dd1d437bcd87a872a70c5d118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee7f28e1714c862c57ce8d055d5c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a64ee7f28e1714c862c57ce8d055d5c9d">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:a64ee7f28e1714c862c57ce8d055d5c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structmqtt_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="#a64ee7f28e1714c862c57ce8d055d5c9d">More...</a><br /></td></tr>
<tr class="separator:a64ee7f28e1714c862c57ce8d055d5c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3eb55085955b355c390dc8f01cb70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a42c3eb55085955b355c390dc8f01cb70">register_packet_id</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a42c3eb55085955b355c390dc8f01cb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="#a42c3eb55085955b355c390dc8f01cb70">More...</a><br /></td></tr>
<tr class="separator:a42c3eb55085955b355c390dc8f01cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d34346e1c7cb25a8bcad42029e91dd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0d34346e1c7cb25a8bcad42029e91dd2">release_packet_id</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)</td></tr>
<tr class="memdesc:a0d34346e1c7cb25a8bcad42029e91dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packet_id.  <a href="#a0d34346e1c7cb25a8bcad42029e91dd2">More...</a><br /></td></tr>
<tr class="separator:a0d34346e1c7cb25a8bcad42029e91dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26a0e0373f2d767c6702ede2bdf737a"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:af26a0e0373f2d767c6702ede2bdf737a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a">restore_serialized_message</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>, Iterator b, Iterator e)</td></tr>
<tr class="memdesc:af26a0e0373f2d767c6702ede2bdf737a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function should be called before connect.  <a href="#af26a0e0373f2d767c6702ede2bdf737a">More...</a><br /></td></tr>
<tr class="separator:af26a0e0373f2d767c6702ede2bdf737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa710a32bf5d1cd297c30f6233001f6dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa710a32bf5d1cd297c30f6233001f6dc">restore_serialized_message</a> (basic_publish_message&lt; PacketIdBytes &gt; msg, mqtt::any life_keeper)</td></tr>
<tr class="memdesc:aa710a32bf5d1cd297c30f6233001f6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function should be called before connect.  <a href="#aa710a32bf5d1cd297c30f6233001f6dc">More...</a><br /></td></tr>
<tr class="separator:aa710a32bf5d1cd297c30f6233001f6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54f8c6f33c6e5d40cf0cb33d6f1b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9d54f8c6f33c6e5d40cf0cb33d6f1b8d">restore_serialized_message</a> (basic_pubrel_message&lt; PacketIdBytes &gt; msg)</td></tr>
<tr class="memdesc:a9d54f8c6f33c6e5d40cf0cb33d6f1b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function should be called before connect.  <a href="#a9d54f8c6f33c6e5d40cf0cb33d6f1b8d">More...</a><br /></td></tr>
<tr class="separator:a9d54f8c6f33c6e5d40cf0cb33d6f1b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf7a8b0cdf901fc720ca60f838fbc3"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a7abf7a8b0cdf901fc720ca60f838fbc3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; typename Iterator::value_type, char &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7abf7a8b0cdf901fc720ca60f838fbc3">restore_v5_serialized_message</a> (<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>, Iterator b, Iterator e)</td></tr>
<tr class="memdesc:a7abf7a8b0cdf901fc720ca60f838fbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function shouold be called before connect.  <a href="#a7abf7a8b0cdf901fc720ca60f838fbc3">More...</a><br /></td></tr>
<tr class="separator:a7abf7a8b0cdf901fc720ca60f838fbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d4a070a29cfb96a4da468192e4533c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a76d4a070a29cfb96a4da468192e4533c">restore_v5_serialized_message</a> (<a class="el" href="classmqtt_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt; msg, mqtt::any life_keeper)</td></tr>
<tr class="memdesc:a76d4a070a29cfb96a4da468192e4533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish message. This function shouold be called before connect.  <a href="#a76d4a070a29cfb96a4da468192e4533c">More...</a><br /></td></tr>
<tr class="separator:a76d4a070a29cfb96a4da468192e4533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162918944bb931f6dc9e5e0722dab116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a162918944bb931f6dc9e5e0722dab116">restore_v5_serialized_message</a> (<a class="el" href="structmqtt_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt; msg, mqtt::any life_keeper)</td></tr>
<tr class="memdesc:a162918944bb931f6dc9e5e0722dab116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized pubrel message. This function shouold be called before connect.  <a href="#a162918944bb931f6dc9e5e0722dab116">More...</a><br /></td></tr>
<tr class="separator:a162918944bb931f6dc9e5e0722dab116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f28ff652abb51255ba6c15e22000dcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8f28ff652abb51255ba6c15e22000dcc">connected</a> () const</td></tr>
<tr class="memdesc:a8f28ff652abb51255ba6c15e22000dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check connection status.  <a href="#a8f28ff652abb51255ba6c15e22000dcc">More...</a><br /></td></tr>
<tr class="separator:a8f28ff652abb51255ba6c15e22000dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712d30fde32e0145eaf6487e7bf0dac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a712d30fde32e0145eaf6487e7bf0dac6">set_mqtt_message_processed_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a> const &amp;h=<a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a>())</td></tr>
<tr class="memdesc:a712d30fde32e0145eaf6487e7bf0dac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom mqtt_message_processed_handler. The default setting is calling <a class="el" href="classmqtt_1_1endpoint.html#ad6cb098813d109a2aff2b711e35eed61">async_read_control_packet_type()</a>. (See <a class="el" href="classmqtt_1_1endpoint.html#a961a875c2704582bda9a2bc96568d53c" title="Constructor for client.">endpoint()</a> constructor). The typical usecase of this function is delaying the next message reading timing. In order to do that 1) store func parameter of the mqtt_message_processed_handler. 2) call async_read_next_message with the stored func if you are ready to read the next mqtt message.  <a href="#a712d30fde32e0145eaf6487e7bf0dac6">More...</a><br /></td></tr>
<tr class="separator:a712d30fde32e0145eaf6487e7bf0dac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d365117062025ae5ab415e262648b06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8d365117062025ae5ab415e262648b06">async_read_next_message</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func)</td></tr>
<tr class="memdesc:a8d365117062025ae5ab415e262648b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);.  <a href="#a8d365117062025ae5ab415e262648b06">More...</a><br /></td></tr>
<tr class="separator:a8d365117062025ae5ab415e262648b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8420d2ac96c76cecc826ea70a0d88c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa8420d2ac96c76cecc826ea70a0d88c7">set_max_queue_send_count</a> (std::size_t count)</td></tr>
<tr class="memdesc:aa8420d2ac96c76cecc826ea70a0d88c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1.  <a href="#aa8420d2ac96c76cecc826ea70a0d88c7">More...</a><br /></td></tr>
<tr class="separator:aa8420d2ac96c76cecc826ea70a0d88c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c18bccf713654c34a6a38548e1f265a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1c18bccf713654c34a6a38548e1f265a">set_max_queue_send_size</a> (std::size_t <a class="el" href="namespacemqtt.html#aa24e4521fa74b1a541b17ef757e22906">size</a>)</td></tr>
<tr class="memdesc:a1c18bccf713654c34a6a38548e1f265a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0.  <a href="#a1c18bccf713654c34a6a38548e1f265a">More...</a><br /></td></tr>
<tr class="separator:a1c18bccf713654c34a6a38548e1f265a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ac255c3abb807cfd0082d8ee21eab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a41ac255c3abb807cfd0082d8ee21eab6">get_protocol_version</a> () const</td></tr>
<tr class="separator:a41ac255c3abb807cfd0082d8ee21eab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad6cb098813d109a2aff2b711e35eed61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad6cb098813d109a2aff2b711e35eed61">async_read_control_packet_type</a> (<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func)</td></tr>
<tr class="separator:ad6cb098813d109a2aff2b711e35eed61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d91d44cb28cd0bc12b152a242658c0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1d91d44cb28cd0bc12b152a242658c0a">handle_close_or_error</a> (boost::system::error_code const &amp;ec)</td></tr>
<tr class="separator:a1d91d44cb28cd0bc12b152a242658c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3102e66c81910bdf71c853de558b87a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3102e66c81910bdf71c853de558b87a8">set_connect</a> ()</td></tr>
<tr class="separator:a3102e66c81910bdf71c853de558b87a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dab3bd490b5732021b677fcb63ec0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab0dab3bd490b5732021b677fcb63ec0f">set_protocol_version</a> (std::size_t version)</td></tr>
<tr class="separator:ab0dab3bd490b5732021b677fcb63ec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603e33887f77817531c09a42b44a2b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a603e33887f77817531c09a42b44a2b5f">handle_close</a> ()</td></tr>
<tr class="separator:a603e33887f77817531c09a42b44a2b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5777c847bca2c43af7f7c590b84fc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af5777c847bca2c43af7f7c590b84fc61">handle_error</a> (boost::system::error_code const &amp;ec)</td></tr>
<tr class="separator:af5777c847bca2c43af7f7c590b84fc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a12e8ef2b9409123639f03b756a5893b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a12e8ef2b9409123639f03b756a5893b4">clean_session_</a> {false}</td></tr>
<tr class="separator:a12e8ef2b9409123639f03b756a5893b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3b0c60837d4b3509b8d76475ffcc258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c60837d4b3509b8d76475ffcc258b">&#9670;&nbsp;</a></span>async_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7a838b7bc8f903e00c05a725d015165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a838b7bc8f903e00c05a725d015165">&#9670;&nbsp;</a></span>close_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close handler. </p>
<p>This handler is called if the client called <code><a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> and the server closed the socket cleanly. If the socket is closed by other reasons, error_handler is called. </p>

</div>
</div>
<a id="aee4550598ca356a864d9c6ba430ecea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4550598ca356a864d9c6ba430ecea5">&#9670;&nbsp;</a></span>connack_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a> =  std::function&lt;bool(bool session_present, std::uint8_t return_code)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718035">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718035</a><br />
 3.2.2.2 Session Present </td></tr>
    <tr><td class="paramname">return_code</td><td><a class="el" href="namespacemqtt_1_1connect__return__code.html">connect_return_code</a><br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718035">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718035</a><br />
 3.2.2.3 Connect Return code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="acdd6c11f298bc4860cd0739febdbe634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd6c11f298bc4860cd0739febdbe634">&#9670;&nbsp;</a></span>connect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a> =  std::function&lt; bool(std::string const&amp; client_id, mqtt::optional&lt;std::string&gt; const&amp; username, mqtt::optional&lt;std::string&gt; const&amp; password, mqtt::optional&lt;<a class="el" href="classmqtt_1_1will.html">will</a>&gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#a4959f781bc2fbb20a64bc67629b40ddf">clean_session</a>, std::uint16_t keep_alive)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client Identifier.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245</a><br />
 3.1.3.1 Client Identifier </td></tr>
    <tr><td class="paramname">username</td><td>User Name.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349245</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349246">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349246</a><br />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, topic, and message.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349232">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349232</a><br />
 3.1.2.5 Will Flag<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349233">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349233</a><br />
 3.1.2.6 Will QoS<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349234">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349234</a><br />
 3.1.2.7 Will Retain<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349243">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349243</a><br />
 3.1.3.2 Will Topic<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349244">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349244</a><br />
 3.1.3.3 Will Message<br />
 </td></tr>
    <tr><td class="paramname">clean_session</td><td>Clean Session<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349231">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349231</a><br />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349237">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349237</a><br />
 3.1.2.10 Keep Alive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad197af50cca897a66b5b569342145042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad197af50cca897a66b5b569342145042">&#9670;&nbsp;</a></span>disconnect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800463</a><br />
 3.14 DISCONNECT – Disconnect notification. </p>

</div>
</div>
<a id="aac48f7b609189aa01111d2b5dc33ac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac48f7b609189aa01111d2b5dc33ac80">&#9670;&nbsp;</a></span>error_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error handler. </p>
<p>This handler is called if the socket is closed without client's <code><a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a></code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a2715b79875b9b659721ccd712bbd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2715b79875b9b659721ccd712bbd28">&#9670;&nbsp;</a></span>is_valid_length_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a> =  std::function&lt;bool(std::uint8_t control_packet_type, std::size_t <a class="el" href="namespacemqtt.html#aca02f83807fbe2a21419cf6013cfc4aa">remaining_length</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is valid length handler This handler is called when remaining length is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="namespacemqtt_1_1control__packet__type.html">control_packet_type</a></td><td><a class="el" href="namespacemqtt_1_1control__packet__type.html">control_packet_type</a> that has variable length </td></tr>
    <tr><td class="paramname">remaining</td><td>length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if check is success, otherwise false </dd></dl>

</div>
</div>
<a id="ac296e84701849b0309bbe33616314744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac296e84701849b0309bbe33616314744">&#9670;&nbsp;</a></span>mqtt_message_processed_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a> func)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next read handler This handler is called when the current mqtt message has been processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a564cd0242f23b05aaf94e65ad7effd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564cd0242f23b05aaf94e65ad7effd3a">&#9670;&nbsp;</a></span>packet_id_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> =  typename <a class="el" href="structmqtt_1_1packet__id__type.html">packet_id_type</a>&lt;PacketIdBytes&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0d6bdb586acc735d5c784196094c361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d6bdb586acc735d5c784196094c361">&#9670;&nbsp;</a></span>pingreq_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br />
 3.13 PINGREQ – PING request. </p>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad1bb95a7462c4a8466c63c860978b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bb95a7462c4a8466c63c860978b2d9">&#9670;&nbsp;</a></span>pingresp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pingresp handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a><br />
 3.13 PINGRESP – PING response. </p>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a529c52ec7d0ff059cc8bf07c30cfe4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529c52ec7d0ff059cc8bf07c30cfe4e8">&#9670;&nbsp;</a></span>pre_send_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-send handler This handler is called when any mqtt control packet is decided to send. </p>

</div>
</div>
<a id="a56b07e4580973cd48becf78b4ea289ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b07e4580973cd48becf78b4ea289ac">&#9670;&nbsp;</a></span>pub_res_sent_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901026">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901026</a><br />
 2.2.1 Packet Identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21324ca4cb279339cf739bef07007182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21324ca4cb279339cf739bef07007182">&#9670;&nbsp;</a></span>puback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045</a><br />
 3.4.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a97cfc609fd1a72bfe4594d9f0a7d42a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cfc609fd1a72bfe4594d9f0a7d42a8">&#9670;&nbsp;</a></span>pubcomp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718060">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718060</a><br />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a9191dc1774a8eab18da4bfa9f84029e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9191dc1774a8eab18da4bfa9f84029e4">&#9670;&nbsp;</a></span>publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a> =  std::function&lt;bool(std::uint8_t fixed_header, mqtt::optional&lt;<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&gt; packet_id, std::string topic_name, std::string contents)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718038">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718038</a><br />
 3.3.1 Fixed header<br />
 You can check the fixed header using <a class="el" href="namespacemqtt_1_1publish.html">mqtt::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 If received publish's QoS is 0, packet_id is mqtt::nullopt.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718039</a><br />
 3.3.2 Variable header </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">contents</td><td>Published contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ab1c00e6f461f7eaa6f1b61f2011e203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c00e6f461f7eaa6f1b61f2011e203b">&#9670;&nbsp;</a></span>pubrec_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718050">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718050</a><br />
 3.5.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a068ab8287621c9facae754d58e1e9e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068ab8287621c9facae754d58e1e9e90">&#9670;&nbsp;</a></span>pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349791">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349791</a><br />
 3.6.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a7c08d527a83ba699572cb14a4294b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c08d527a83ba699572cb14a4294b392">&#9670;&nbsp;</a></span>serialize_publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, char const* data, std::size_t <a class="el" href="namespacemqtt.html#aa24e4521fa74b1a541b17ef757e22906">size</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the serializing message </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the serializing message </td></tr>
    <tr><td class="paramname">size</td><td>size of the serializing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cfa1defa357702169040bfc7b16fa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfa1defa357702169040bfc7b16fa54">&#9670;&nbsp;</a></span>serialize_publish_message_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a> =  std::function&lt;void(basic_publish_message&lt;PacketIdBytes&gt; msg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753823cea6186f17d19f50b61f706eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753823cea6186f17d19f50b61f706eec">&#9670;&nbsp;</a></span>serialize_pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, char const* data, std::size_t <a class="el" href="namespacemqtt.html#aa24e4521fa74b1a541b17ef757e22906">size</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the serializing message </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the serializing message </td></tr>
    <tr><td class="paramname">size</td><td>size of the serializing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5f6de4972fb8a792fae5000c340d969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f6de4972fb8a792fae5000c340d969">&#9670;&nbsp;</a></span>serialize_pubrel_message_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a> =  std::function&lt;void(basic_pubrel_message&lt;PacketIdBytes&gt; msg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ad8841aa15503d13798ee9f682cba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ad8841aa15503d13798ee9f682cba1">&#9670;&nbsp;</a></span>serialize_remove_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove serialized message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the removing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5737b8a9b39dbe81c74ff2e28ffe492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5737b8a9b39dbe81c74ff2e28ffe492">&#9670;&nbsp;</a></span>serialize_v5_publish_message_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a> =  std::function&lt;void(<a class="el" href="classmqtt_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt;PacketIdBytes&gt; msg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>v5::publish message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25e3f811f69990b8be27e681e00e414c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e3f811f69990b8be27e681e00e414c">&#9670;&nbsp;</a></span>serialize_v5_pubrel_message_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a> =  std::function&lt;void(<a class="el" href="structmqtt_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt;PacketIdBytes&gt; msg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#af26a0e0373f2d767c6702ede2bdf737a" title="Restore serialized publish and pubrel messages. This function should be called before connect.">restore_serialized_message()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e70c3f92c2e16a66b3287bc5349da5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e70c3f92c2e16a66b3287bc5349da5a">&#9670;&nbsp;</a></span>suback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;mqtt::optional&lt;std::uint8_t&gt; &gt; qoss)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718070">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718070</a><br />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">qoss</td><td>Collection of QoS that is corresponding to subscribed topic order.<br />
 If subscription is failure, the value is mqtt::nullopt.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718071</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a4209361313b60fc85a657c9109a91231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4209361313b60fc85a657c9109a91231">&#9670;&nbsp;</a></span>subscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;std::tuple&lt;std::string, std::uint8_t&gt; &gt; entries)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349801">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349801</a><br />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349802">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349802</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a1cb934072e5052d34fdc5810b1abe8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb934072e5052d34fdc5810b1abe8d0">&#9670;&nbsp;</a></span>unsuback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718045</a><br />
 3.11.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ae38cdc0242dbbe0516e391434250c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38cdc0242dbbe0516e391434250c15e">&#9670;&nbsp;</a></span>unsubscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;std::string&gt; topics)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349810">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349810</a><br />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800448">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc384800448</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="acec77935e0706fd72187b340a1a8d4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec77935e0706fd72187b340a1a8d4d5">&#9670;&nbsp;</a></span>v5_auth_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a> =  std::function&lt; bool(std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auth handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217</a><br />
 3.15 AUTH – Authentication exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br />
 3.15.2.2 AUTH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a030b892a8e24eb83a322ee336d411f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030b892a8e24eb83a322ee336d411f36">&#9670;&nbsp;</a></span>v5_connack_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a> =  std::function&lt; bool(bool session_present, std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901078">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901078</a><br />
 3.2.2.1.1 Session Present </td></tr>
    <tr><td class="paramname">reason_code</td><td>Connect Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079</a><br />
 3.2.2.2 Connect Reason code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br />
 3.2.2.3 CONNACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a632d951eddb30b18108d6bc4dbac81c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632d951eddb30b18108d6bc4dbac81c0">&#9670;&nbsp;</a></span>v5_connect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a> =  std::function&lt; bool(std::string const&amp; client_id, mqtt::optional&lt;std::string&gt; const&amp; username, mqtt::optional&lt;std::string&gt; const&amp; password, mqtt::optional&lt;<a class="el" href="classmqtt_1_1will.html">will</a>&gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#afb1dff57ee4ebe5e9b17f70354772d0c">clean_start</a>, std::uint16_t keep_alive, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client Identifier.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br />
 3.1.3.1 Client Identifier </td></tr>
    <tr><td class="paramname">username</td><td>User Name.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, propertied, topic, and message.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901040">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901040</a><br />
 3.1.2.5 Will Flag<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901041">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901041</a><br />
 3.1.2.6 Will QoS<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901042">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901042</a><br />
 3.1.2.7 Will Retain<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901060">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901060</a><br />
 3.1.3.2 Will Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901069">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901069</a><br />
 3.1.3.3 Will Topic<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901070">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901070</a><br />
 3.1.3.3 Will Payload<br />
 </td></tr>
    <tr><td class="paramname">clean_start</td><td>Clean Start<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a2e9d8e8241a0a01307717ce9cac2135e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9d8e8241a0a01307717ce9cac2135e">&#9670;&nbsp;</a></span>v5_disconnect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a> =  std::function&lt; void(std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect handler See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br />
 3.14 DISCONNECT – Disconnect notification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>DISCONNECT Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br />
 3.14.2.2 DISCONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eae1974ed82284cd8deb9f5597b5e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eae1974ed82284cd8deb9f5597b5e56">&#9670;&nbsp;</a></span>v5_puback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901123">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901123</a><br />
 3.4.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br />
 3.4.2.2 PUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a10847e9fe9331cd8ce1fc8a16dba18e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10847e9fe9331cd8ce1fc8a16dba18e3">&#9670;&nbsp;</a></span>v5_pubcomp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901153">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901153</a><br />
 3.7.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br />
 3.7.2.2 PUBCOMP Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="af05b370879b50e3c87fdaf131d587a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05b370879b50e3c87fdaf131d587a78">&#9670;&nbsp;</a></span>v5_publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a> =  std::function&lt; bool(std::uint8_t fixed_header, mqtt::optional&lt;<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&gt; packet_id, std::string topic_name, std::string contents, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901101">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901101</a><br />
 3.3.1 Fixed header<br />
 You can check the fixed header using <a class="el" href="namespacemqtt_1_1publish.html">mqtt::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 If received publish's QoS is 0, packet_id is mqtt::nullopt.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901108">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901108</a><br />
 3.3.2.2 Packet Identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901107">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901107</a><br />
 3.3.2.1 Topic Name<br />
 </td></tr>
    <tr><td class="paramname">contents</td><td>Publish Payload<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901119">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901119</a><br />
 3.3.3 PUBLISH Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ae70bfc06f9c5a565c23380c55ada5ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70bfc06f9c5a565c23380c55ada5ae4">&#9670;&nbsp;</a></span>v5_pubrec_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901133">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901133</a><br />
 3.5.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br />
 3.5.2.2 PUBREC Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ac700f606579048afc30e571f71514836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac700f606579048afc30e571f71514836">&#9670;&nbsp;</a></span>v5_pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::uint8_t reason_code, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901143">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901143</a><br />
 3.6.2 Variable header </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br />
 3.6.2.2 PUBREL Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="af5885dff8fbe5e74fdf99d1cd77d5293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5885dff8fbe5e74fdf99d1cd77d5293">&#9670;&nbsp;</a></span>v5_suback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;std::uint8_t&gt; reasons, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901173">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901173</a><br />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">reasons</td><td>Collection of reason_code.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a1fbcb705b084e7a61e5c54145a636fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbcb705b084e7a61e5c54145a636fab">&#9670;&nbsp;</a></span>v5_subscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;std::tuple&lt;std::string, std::uint8_t&gt; &gt; entries, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901163">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901163</a><br />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901168">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901168</a><br />
 </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="abb50e8b139acb089940258c841731278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb50e8b139acb089940258c841731278">&#9670;&nbsp;</a></span>v5_unsuback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>, std::vector&lt;std::uint8_t&gt; reasons, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901189">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901189</a><br />
 3.11.2 Variable header </td></tr>
    <tr><td class="paramname">reasons</td><td>Collection of reason_code.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a65060d5a517664f63899fcfcc5f39607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65060d5a517664f63899fcfcc5f39607">&#9670;&nbsp;</a></span>v5_unsubscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a> =  std::function&lt; bool(<a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> packet_id, std::vector&lt;std::string&gt; topics, std::vector&lt;<a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a>&gt; props) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901181">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901181</a><br />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901185">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901185</a><br />
 3.10.3 UNSUBSCRIBE Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a961a875c2704582bda9a2bc96568d53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961a875c2704582bda9a2bc96568d53c">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for client. </p>

</div>
</div>
<a id="aea4a6f112dfee3007e3fc2d44ec24f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4a6f112dfee3007e3fc2d44ec24f48">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Socket &gt;&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008a276fc71ddbf2483a3842cdcef417e03d">protocol_version::undetermined</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for server. socket should have already been connected with another endpoint. </p>

</div>
</div>
<a id="acf1cc09e00f54e16e1655851fb544a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1cc09e00f54e16e1655851fb544a68">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83eddccd2328ef084fb5efb3f2edb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83eddccd2328ef084fb5efb3f2edb1a3">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64ee7f28e1714c862c57ce8d055d5c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ee7f28e1714c862c57ce8d055d5c9d">&#9670;&nbsp;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structmqtt_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>packet id </dd></dl>

</div>
</div>
<a id="aa5e181da0361a311b735726b3fc0066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e181da0361a311b735726b3fc0066d">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89211189102aa25d2ea1ed2a27ef2f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89211189102aa25d2ea1ed2a27ef2f7a">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fc2c2877266eaf7ad6fbdaf2e1e20d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2c2877266eaf7ad6fbdaf2e1e20d5">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1700da73f17dcff1fcfb773b5a72e7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1700da73f17dcff1fcfb773b5a72e7d7">&#9670;&nbsp;</a></span>acquired_async_publish() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08d68c1bbd840941ca81a601a09b9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08d68c1bbd840941ca81a601a09b9f1">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96c8e67d6c196cf347592373ce6eae5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c8e67d6c196cf347592373ce6eae5b">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16cf1e9973a3af7a94daeed11103cbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cf1e9973a3af7a94daeed11103cbe8">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae482b270a38ceb3c7ca4615de3b98194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae482b270a38ceb3c7ca4615de3b98194">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24037fd1bf10e5062e804e6742f742c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24037fd1bf10e5062e804e6742f742c1">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef4d86c49edaf4910c2d7edcff6e6695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4d86c49edaf4910c2d7edcff6e6695">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60ea77fddd9cc130c9afc2a8bb5ea252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ea77fddd9cc130c9afc2a8bb5ea252">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d3101edd529ad96c0ee372320aaf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d3101edd529ad96c0ee372320aaf38">&#9670;&nbsp;</a></span>acquired_async_publish_dup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f20161c3920f24163ee71c03b68887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f20161c3920f24163ee71c03b68887">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e2d2c34e5908221fe8b90d8d7d06e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2d2c34e5908221fe8b90d8d7d06e7a">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77f6cbc431cc2ca2c99a9f2903280973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6cbc431cc2ca2c99a9f2903280973">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a39b4e96e1d08daa1ab08ccda037183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a39b4e96e1d08daa1ab08ccda037183">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a358cf52197813c9e456f51ecd89413a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358cf52197813c9e456f51ecd89413a3">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a922a30774801b072244036fee609b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922a30774801b072244036fee609b31d">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea2667a5a25c42daf06fd75982cfc39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2667a5a25c42daf06fd75982cfc39f">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c4d793a5f9ae71ed3a6bfbee530bbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4d793a5f9ae71ed3a6bfbee530bbb8">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a145cff70125f4326932288922691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a145cff70125f4326932288922691d">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d089a72e9364286eb7163cb2d981ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d089a72e9364286eb7163cb2d981ce7">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adceff57062abd8ddcc19080de826cec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceff57062abd8ddcc19080de826cec5">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed3350319184f35c4ca0b86ed19c4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3350319184f35c4ca0b86ed19c4dd">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da9c4cf5ea485d585c7538818a96e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da9c4cf5ea485d585c7538818a96e41">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab785cf0faa04874e70e7f7b4c2f8ee5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab785cf0faa04874e70e7f7b4c2f8ee5d">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33918e8224d46e1909004fd395fd56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33918e8224d46e1909004fd395fd56e4">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac53622e9d0690a5b0a1f2e9033eb14ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53622e9d0690a5b0a1f2e9033eb14ae">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>topic_name </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34f94457610fb3fb2d38e966b5865130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f94457610fb3fb2d38e966b5865130">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1628a6b5c97464ffb35c83f83509f1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1628a6b5c97464ffb35c83f83509f1f1">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6da0d99b2ccd4501c9926bace6a7b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6da0d99b2ccd4501c9926bace6a7b52">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c4e6cf64761b4e76dc7ef91573ea108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4e6cf64761b4e76dc7ef91573ea108">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfdef235db5197c39969edc147a5aba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdef235db5197c39969edc147a5aba3">&#9670;&nbsp;</a></span>acquired_publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab098c5e3eb30065aedd3b5b26de64f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab098c5e3eb30065aedd3b5b26de64f65">&#9670;&nbsp;</a></span>acquired_publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab7f88e8c9c612942523fa07db997def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7f88e8c9c612942523fa07db997def">&#9670;&nbsp;</a></span>acquired_publish_at_least_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac45ef5ec0fc07ae35ac9cceda2347223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45ef5ec0fc07ae35ac9cceda2347223">&#9670;&nbsp;</a></span>acquired_publish_at_least_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3b912be2c99475b000d643ca4dabc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b912be2c99475b000d643ca4dabc39">&#9670;&nbsp;</a></span>acquired_publish_dup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48286ccbfcf8f1d62f56cd093ef765ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48286ccbfcf8f1d62f56cd093ef765ea">&#9670;&nbsp;</a></span>acquired_publish_dup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0acabc70b2dd8e98d28dce706fa7de92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acabc70b2dd8e98d28dce706fa7de92">&#9670;&nbsp;</a></span>acquired_publish_exactly_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6217da64862947352d98d56e641c8fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6217da64862947352d98d56e641c8fcc">&#9670;&nbsp;</a></span>acquired_publish_exactly_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a799bf2aa9a36ef1714e0952428e02f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799bf2aa9a36ef1714e0952428e02f7b">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos.</td></tr>
  </table>
  </dd>
</dl>
<p>You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </p>

</div>
</div>
<a id="aed93fcd23f1333c58071512a122b2f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed93fcd23f1333c58071512a122b2f10">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addbcf2c9c9d1a55fca04ddb18f95f5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbcf2c9c9d1a55fca04ddb18f95f5b9">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eda888186b26358c858a6a24826065f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eda888186b26358c858a6a24826065f">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab67cc59266aec74cde509c02c7110dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67cc59266aec74cde509c02c7110dfa">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a329511b3be22f974810269dfd7e08c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329511b3be22f974810269dfd7e08c60">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60b469fbf436f0acd8d1023713dc8026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b469fbf436f0acd8d1023713dc8026">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d256414e14691cea13770011c0cc5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d256414e14691cea13770011c0cc5c2">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac31cefea6066e2f06a6f6b5089522008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31cefea6066e2f06a6f6b5089522008">&#9670;&nbsp;</a></span>async_auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_auth </td>
          <td>(</td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br />
 3.15.2.2 AUTH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2784a5d25a1bfd6603e15cf1f796503e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2784a5d25a1bfd6603e15cf1f796503e">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf45dc1594c63e911b814317e19e27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf45dc1594c63e911b814317e19e27f">&#9670;&nbsp;</a></span>async_connack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br />
 3.2.2.3 CONNACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a218ebf1af18477a192434573de9d7095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218ebf1af18477a192434573de9d7095">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b5d89685e72378cea501e8ba5cfaa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5d89685e72378cea501e8ba5cfaa3e">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br />
 3.1.2.11 CONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f874efc0ace8b41427bcf8680f3830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f874efc0ace8b41427bcf8680f3830b">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9e9326b8dda7b25ee456b6cc30583a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e9326b8dda7b25ee456b6cc30583a1">&#9670;&nbsp;</a></span>async_disconnect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>DISCONNECT Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br />
 3.14.2.2 DISCONNECT Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11230cd247801c5d6d85efd8e4e4b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11230cd247801c5d6d85efd8e4e4b568">&#9670;&nbsp;</a></span>async_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pingreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e9083fee8e1d585159550fbf85e505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9083fee8e1d585159550fbf85e505f">&#9670;&nbsp;</a></span>async_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pingresp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ee368cd21c8060a5dd276df761c3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ee368cd21c8060a5dd276df761c3d0">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cc0d56eef84a4b9730c283bf094e0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc0d56eef84a4b9730c283bf094e0fa">&#9670;&nbsp;</a></span>async_puback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br />
 3.4.2.2 PUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d9f2a049dfccc2c88007819a4c8f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d9f2a049dfccc2c88007819a4c8f6d">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaca08caa9162d59db52fe0cdb7daed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaca08caa9162d59db52fe0cdb7daed1">&#9670;&nbsp;</a></span>async_pubcomp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br />
 3.7.2.2 PUBCOMP Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9833983e228c66aa115f99686d8cae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9833983e228c66aa115f99686d8cae5">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a1a7c7fb987127c3c500dcca0b59c01ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7c7fb987127c3c500dcca0b59c01ba">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="adf56f436991204cc0cb2bd8544b3db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf56f436991204cc0cb2bd8544b3db35">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aad892eeecf8833c85d823cfee20183d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad892eeecf8833c85d823cfee20183d3">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="afdf9daaf190cd177ba2148e31bc7db31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf9daaf190cd177ba2148e31bc7db31">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="afceca01c1e14f3e1bea87be99959b0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afceca01c1e14f3e1bea87be99959b0dd">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="afe2bf2be0d8a76d4eff06a55e43c9cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2bf2be0d8a76d4eff06a55e43c9cdc">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ab93d7c49f362a7798df5d0b548358d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93d7c49f362a7798df5d0b548358d94">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a640deeafc6f9097f08e045152541a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640deeafc6f9097f08e045152541a503">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aebcf11e590444584b5219a33742cb9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcf11e590444584b5219a33742cb9cb">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="af5e3b7c23c9ddebd0c5fa95c2ee854b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e3b7c23c9ddebd0c5fa95c2ee854b2">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a9a03775a57b335cd32bbfa316f039654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a03775a57b335cd32bbfa316f039654">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a103df82c9a2ca4391bd25168e22c5cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103df82c9a2ca4391bd25168e22c5cf6">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a95b4fa94de568fddd84f5fea07b0fa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b4fa94de568fddd84f5fea07b0fa21">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ac2eccad04139b5c96110b12f1ffd352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eccad04139b5c96110b12f1ffd352f">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ac8228eb186c0dd827ffbc90c276f65ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8228eb186c0dd827ffbc90c276f65ef">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a32fead2a16725e99fe2633356faf2f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fead2a16725e99fe2633356faf2f74">&#9670;&nbsp;</a></span>async_publish_at_most_once() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd544032c17fd7fadd22b99fcb2a604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd544032c17fd7fadd22b99fcb2a604">&#9670;&nbsp;</a></span>async_publish_at_most_once() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80cdd7418f7447d9a31d82e15bef80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80cdd7418f7447d9a31d82e15bef80a">&#9670;&nbsp;</a></span>async_publish_at_most_once() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0 topic_name and contents are reference type. So caller need to keep the lifetime of them until func is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3284712b74ef9ebe38e54dc1f3df4aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3284712b74ef9ebe38e54dc1f3df4aaf">&#9670;&nbsp;</a></span>async_publish_at_most_once() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0 topic_name and contents are reference type. So caller need to keep the lifetime of them until func is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab85f124d5be68a5c0ffd35474cab9b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85f124d5be68a5c0ffd35474cab9b01">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="abae8ae1655623fe8572a03179506f9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae8ae1655623fe8572a03179506f9ae">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ae82fa998b282d19169f2ee52ffd5a518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82fa998b282d19169f2ee52ffd5a518">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">life_keeper</td><td>A object that stays alive until the async operation is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a8917be1a8888bb88b94683cf69f28a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8917be1a8888bb88b94683cf69f28a5b">&#9670;&nbsp;</a></span>async_publish_dup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ae0508571c30b1a4ad9bc50cace564108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0508571c30b1a4ad9bc50cace564108">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a6cef7a5440ee2439fc6ccd054af1cee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cef7a5440ee2439fc6ccd054af1cee9">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aa1649e77478a8b1f3be2823cc57cb9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1649e77478a8b1f3be2823cc57cb9b6">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a06b1eebe57b5ba3bb0c3297214aafa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b1eebe57b5ba3bb0c3297214aafa3e">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a1937a0d5bfafdee2a31de9096cef199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1937a0d5bfafdee2a31de9096cef199f">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="afd3efe36b15caa7b83cdfc3f980aed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3efe36b15caa7b83cdfc3f980aed6f">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a732de6062dffd24d3e375e608ec7703e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732de6062dffd24d3e375e608ec7703e">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a6832d220adfeeb90fbbbf7fccbbf10bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6832d220adfeeb90fbbbf7fccbbf10bf">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a786a5e26b566889a1c6b8f632149d860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786a5e26b566889a1c6b8f632149d860">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a321c7968bc9c44aad9dcdeb2326b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a321c7968bc9c44aad9dcdeb2326b9f">&#9670;&nbsp;</a></span>async_pubrec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br />
 3.5.2.2 PUBREC Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa814c1f25e218fbacb6912208c6f6642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa814c1f25e218fbacb6912208c6f6642">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f0224a7239b0ddfa0f64632f3bb4bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0224a7239b0ddfa0f64632f3bb4bda">&#9670;&nbsp;</a></span>async_pubrel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br />
 3.6.2.2 PUBREL Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6cb098813d109a2aff2b711e35eed61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cb098813d109a2aff2b711e35eed61">&#9670;&nbsp;</a></span>async_read_control_packet_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_read_control_packet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d365117062025ae5ab415e262648b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d365117062025ae5ab415e262648b06">&#9670;&nbsp;</a></span>async_read_next_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_read_next_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trigger next mqtt message manually. If you call this function, you need to set manual receive mode using set_auto_next_read(false);. </p>

</div>
</div>
<a id="a055cdce0175f1bce02ab1f81c8591793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055cdce0175f1bce02ab1f81c8591793">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code The format of args is <code>[option, option, ...,][props,][func]</code><br />
 You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties You can set a callback function that is called when async operation will finish. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8005fa7c219c6e42e35838dbfe2876b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8005fa7c219c6e42e35838dbfe2876b">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00fe2e23301b898410206945c345e995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fe2e23301b898410206945c345e995">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d0e1526a7d82895017268f2edd550d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d0e1526a7d82895017268f2edd550d">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86ed8ff917fbfb34faf502fc190b8ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ed8ff917fbfb34faf502fc190b8ea3">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eca16a3c6f85e5ab855037d87ce62ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eca16a3c6f85e5ab855037d87ce62ab">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a10044aa182827121804834af339058ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10044aa182827121804834af339058ca">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a6642b16c1f176cf6ecaba4d18d03e72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6642b16c1f176cf6ecaba4d18d03e72b">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a2f202861ab13efe6544a45c466c32595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f202861ab13efe6544a45c466c32595">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="abbc5ba17b9186ffc82b10d715c3beac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc5ba17b9186ffc82b10d715c3beac2">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ae252d4539d022728bb79d2bd02a458f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae252d4539d022728bb79d2bd02a458f7">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ac1e721d4e8dbd880a5942591af8ba76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e721d4e8dbd880a5942591af8ba76c">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="af276c5baa6729834f546df75df986ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af276c5baa6729834f546df75df986ed6">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ac6765d88c3832e0241b247b96401b21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6765d88c3832e0241b247b96401b21f">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ab4da37a719954e6c323f34ce145d582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da37a719954e6c323f34ce145d582f">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a59d40b13797ac00c4021009a00af491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d40b13797ac00c4021009a00af491f">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="a5d784f450b7039e748e8732ad4b18348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d784f450b7039e748e8732ad4b18348">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, option, topicname, option, ...,][props,][func]</code><br />
 args should be zero or more pairs of topic_name and option. You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="a478e71e1328eda6966ec735b5f49d399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478e71e1328eda6966ec735b5f49d399">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="aaff974827dfda9a99d35588167ee752c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff974827dfda9a99d35588167ee752c">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ad5bce4c55ec09fcf6dd3052f3e6556d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bce4c55ec09fcf6dd3052f3e6556d1">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ab265cf5d301db95942ff30a5347a466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab265cf5d301db95942ff30a5347a466f">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="ac274b84d7322c92b55e6eb6eb404cfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac274b84d7322c92b55e6eb6eb404cfe5">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a6fa3e7d4e8478a423b2f7a3b3eaeab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa3e7d4e8478a423b2f7a3b3eaeab50">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a48ba40c82db50e6f8aa9d2c7a6459716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ba40c82db50e6f8aa9d2c7a6459716">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a378982884babca66babaee989301756e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378982884babca66babaee989301756e">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and option to subscribe. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="afaa1b64f191519714e8febbfd5724353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa1b64f191519714e8febbfd5724353">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[option, option, ...,][props,][func]</code><br />
 You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties You can set a callback function that is called when async operation will finish. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3073afbfce14cbbd269cb618206fa14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073afbfce14cbbd269cb618206fa14a">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a243c953c02a91d64fdcc9ffb8ef8bd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243c953c02a91d64fdcc9ffb8ef8bd5d">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b179cec296dade14363ab6f88040092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b179cec296dade14363ab6f88040092">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0c0664cf14ee7e4adb3fc1b9d3df7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c0664cf14ee7e4adb3fc1b9d3df7cc">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d5630023d857c3ba948e6c633e7a952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5630023d857c3ba948e6c633e7a952">&#9670;&nbsp;</a></span>async_unsuback() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send ununsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718077</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3d6bc1fae013220a62d3c935318662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3d6bc1fae013220a62d3c935318662">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a0adc91b8fa6c23b4687f8ac41061089d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adc91b8fa6c23b4687f8ac41061089d">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a17af7fdd038c9ef2bf73a4f27a1543c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af7fdd038c9ef2bf73a4f27a1543c2">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aeac5b6145475d0e5e516d5d909041eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac5b6145475d0e5e516d5d909041eeb">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a081ad8d4698b52a10c64f94b7b157642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081ad8d4698b52a10c64f94b7b157642">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a1819d0d9dc391f71991d796dcd42bc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1819d0d9dc391f71991d796dcd42bc3a">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a30cd149702675befb6ec9a1439c28713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cd149702675befb6ec9a1439c28713">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a7b4e882926f184d2513dcea4a7d1aa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4e882926f184d2513dcea4a7d1aa1c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ac87b3cc083ed32b475f93191e8b348f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87b3cc083ed32b475f93191e8b348f9">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a0723563c06d9f938200680434389f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0723563c06d9f938200680434389f65c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ada8c65d2e437c52f4ecb3be863fcf338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8c65d2e437c52f4ecb3be863fcf338">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a6ac96dd36834c2124e486ff9c0bd21b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac96dd36834c2124e486ff9c0bd21b6">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>The format of args is <code>[topic_name, topicname, ... , ][props,][func]</code><br />
 args should be some topic_names to unsubscribe, <br />
 You can set props optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties You can set a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a300604f424d7224ef19d432a5d938f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300604f424d7224ef19d432a5d938f60">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a27a6a306460b1b7d49f664148c794088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a6a306460b1b7d49f664148c794088">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic names to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ae7c722ef52e6e5b2ff15cbbb3f596929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c722ef52e6e5b2ff15cbbb3f596929">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic names to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="aaaa9a7011f029e376353fe1f4dee3c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa9a7011f029e376353fe1f4dee3c32">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
    <tr><td class="paramname">func</td><td>functor object who's operator() will be called when the async operation completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a214a59580f4c6fc57f64c8c140ddccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214a59580f4c6fc57f64c8c140ddccc4">&#9670;&nbsp;</a></span>auth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::auth </td>
          <td>(</td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send auth packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718086</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>AUTH Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901220</a><br />
 3.15.2.1 Authenticate Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901221</a><br />
 3.15.2.2 AUTH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4959f781bc2fbb20a64bc67629b40ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4959f781bc2fbb20a64bc67629b40ddf">&#9670;&nbsp;</a></span>clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::clean_session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean session. </p>
<p>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231</a><br />
 3.1.2.4 Clean Session<br />
 After constructing a endpoint, the clean session is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean session </dd></dl>

</div>
</div>
<a id="afb1dff57ee4ebe5e9b17f70354772d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1dff57ee4ebe5e9b17f70354772d0c">&#9670;&nbsp;</a></span>clean_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::clean_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clean start. </p>
<p>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br />
 3.1.2.4 Clean Start<br />
 After constructing a endpoint, the clean start is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean start </dd></dl>

</div>
</div>
<a id="a20d11dcacb8c97035b4b75baafe794f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d11dcacb8c97035b4b75baafe794f8">&#9670;&nbsp;</a></span>clear_stored_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::clear_stored_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stored publish message that has packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to stored publish </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a291492f077f86217d4b6bc401e701519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291492f077f86217d4b6bc401e701519">&#9670;&nbsp;</a></span>connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">reason_code</td><td>See <a class="el" href="reason__code_8hpp.html">reason_code.hpp</a> and <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901080</a><br />
 3.2.2.3 CONNACK Properties See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9ba0fefb75d423e8a513093163f7da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ba0fefb75d423e8a513093163f7da3">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>The client id to use for this connection<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901059</a><br />
 3.1.3.1 Client Identifier (ClientID) </td></tr>
    <tr><td class="paramname">user_name</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901071</a><br />
 3.1.3.5 User Name </td></tr>
    <tr><td class="paramname">password</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901072</a><br />
 3.1.3.6 Password </td></tr>
    <tr><td class="paramname">w</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982</a><br />
 3.1.2.5 Will Flag </td></tr>
    <tr><td class="paramname">clean_session</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901039</a><br />
 3.1.2.4 Clean Start<br />
 </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc385349238</a> See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc398718028</a> </td></tr>
    <tr><td class="paramname">keep_alive_sec</td><td>Keep Alive<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901045</a><br />
 3.1.2.10 Keep Alive </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901046</a><br />
 3.1.2.11 CONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f28ff652abb51255ba6c15e22000dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f28ff652abb51255ba6c15e22000dcc">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>current connection status </dd></dl>

</div>
</div>
<a id="a4eb6e58ae2d3bec844e15ebc17f59e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb6e58ae2d3bec844e15ebc17f59e7e">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a4eb6e58ae2d3bec844e15ebc17f59e7e" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence....">disconnect()</a>, a will won't send.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901205</a><br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason_code</td><td>DISCONNECT Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208</a><br />
 3.14.2.1 Disconnect Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901209</a><br />
 3.14.2.2 DISCONNECT Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ca56d4103e725936758a86d1c67595e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca56d4103e725936758a86d1c67595e">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(char const *, std::size_t)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(char const*, std::size_t) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf2a947dd1d437bcd87a872a70c5d118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2a947dd1d437bcd87a872a70c5d118">&#9670;&nbsp;</a></span>for_each_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespacemqtt.html#a76c9863f7830ff23b2d56e3db1370a76">message_variant</a> const &amp;)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>applying function. f should be void(message_variant const&amp;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92ff6a5a8c30331e90bd6ae3b36e7ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ff6a5a8c30331e90bd6ae3b36e7ce2">&#9670;&nbsp;</a></span>force_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::force_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a92ff6a5a8c30331e90bd6ae3b36e7ce2" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
 </p>

</div>
</div>
<a id="a73abc104827371983fcb8af0b220b9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73abc104827371983fcb8af0b220b9a5">&#9670;&nbsp;</a></span>get_close_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_close_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get close handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="aacc44cbca5561e4558b4d03c94a617bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc44cbca5561e4558b4d03c94a617bb">&#9670;&nbsp;</a></span>get_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_connack_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connack handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a0bd386317d159f41b6ab21a28927d192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd386317d159f41b6ab21a28927d192">&#9670;&nbsp;</a></span>get_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_connect_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connect handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a217409dab62840d59ef137cb666629c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217409dab62840d59ef137cb666629c9">&#9670;&nbsp;</a></span>get_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_disconnect_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get disconnect handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="ad2737f82e37d85c04afc191c8ed07d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2737f82e37d85c04afc191c8ed07d83">&#9670;&nbsp;</a></span>get_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_error_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get error handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a01e05a3ab36d615db8e8dfd1cf92f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e05a3ab36d615db8e8dfd1cf92f236">&#9670;&nbsp;</a></span>get_is_valid_length_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_is_valid_length_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get check length handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="af21c39872a0536fd810f6de35913d553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21c39872a0536fd810f6de35913d553">&#9670;&nbsp;</a></span>get_pingreq_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pingreq_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pingreq handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a78cf126dc8ec6d16610b3b1cdc750bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cf126dc8ec6d16610b3b1cdc750bbd">&#9670;&nbsp;</a></span>get_pingresp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pingresp_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pingresp handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a8480ad5495be1044208edc96658ae51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8480ad5495be1044208edc96658ae51d">&#9670;&nbsp;</a></span>get_pre_send_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pre_send_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pre-send handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a41ac255c3abb807cfd0082d8ee21eab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ac255c3abb807cfd0082d8ee21eab6">&#9670;&nbsp;</a></span>get_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#aac0c9546769c62226908ecf424bd6008">protocol_version</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dda1f7f42e5e4d8e2edefd8fe3b62db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dda1f7f42e5e4d8e2edefd8fe3b62db">&#9670;&nbsp;</a></span>get_pub_res_sent_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pub_res_sent_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get publish response sent handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a7918e800d3927c9ec56d63f3e24da5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7918e800d3927c9ec56d63f3e24da5f3">&#9670;&nbsp;</a></span>get_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_puback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get puback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a5af863ee97d993e12f4d5465333e29cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af863ee97d993e12f4d5465333e29cf">&#9670;&nbsp;</a></span>get_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pubcomp_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubcomp handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a69e567e76a501e1317708ab5989a284a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e567e76a501e1317708ab5989a284a">&#9670;&nbsp;</a></span>get_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_publish_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set publish handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a4539bdca9db75ab6bb473b5692ce42c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4539bdca9db75ab6bb473b5692ce42c8">&#9670;&nbsp;</a></span>get_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pubrec_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubrec handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a33be9a5c119122023caed6a0700f5200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33be9a5c119122023caed6a0700f5200">&#9670;&nbsp;</a></span>get_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_pubrel_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubrel handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a0fa7cfeb1316cb56900fd9cd45c287cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa7cfeb1316cb56900fd9cd45c287cf">&#9670;&nbsp;</a></span>get_serialize_publish_message_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_serialize_publish_message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get serialize publish handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a510b713463a8008618f99ce1f4cd521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510b713463a8008618f99ce1f4cd521e">&#9670;&nbsp;</a></span>get_serialize_pubrel_message_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_serialize_pubrel_message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get serialize pubrel handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a6eeba1a1c3d324b405517144d5fa27ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeba1a1c3d324b405517144d5fa27ad">&#9670;&nbsp;</a></span>get_serialize_remove_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_serialize_remove_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get serialize remove handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a1f2a3122979eaf1ab78d0136f928c5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2a3122979eaf1ab78d0136f928c5ad">&#9670;&nbsp;</a></span>get_serialize_v5_publish_message_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_serialize_v5_publish_message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get serialize publish handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a1bc383e509fe83245a7d6eb9a8732e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc383e509fe83245a7d6eb9a8732e20">&#9670;&nbsp;</a></span>get_serialize_v5_pubrel_message_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_serialize_v5_pubrel_message_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get serialize pubrel handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a49d9880df0f6df5d806ac786272739a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d9880df0f6df5d806ac786272739a1">&#9670;&nbsp;</a></span>get_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_suback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get suback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a9db0c215c287daec36dd5e249d7a034f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db0c215c287daec36dd5e249d7a034f">&#9670;&nbsp;</a></span>get_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_subscribe_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get subscribe handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a06f7dfac2d8e5951d3e9deb06f4ee106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f7dfac2d8e5951d3e9deb06f4ee106">&#9670;&nbsp;</a></span>get_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_unsuback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get unsuback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="ab313bbd5fe065037be3d890a5bb20180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab313bbd5fe065037be3d890a5bb20180">&#9670;&nbsp;</a></span>get_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get unsubscribe handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a673781bf813e38aa898da18c927d4223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673781bf813e38aa898da18c927d4223">&#9670;&nbsp;</a></span>get_v5_auth_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_auth_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get auth handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="afbfdff9b4ebbeb165a6eaca111cd0edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfdff9b4ebbeb165a6eaca111cd0edc">&#9670;&nbsp;</a></span>get_v5_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_connack_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connack handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a83c4d43e48e8b3eb35cece5f98124358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c4d43e48e8b3eb35cece5f98124358">&#9670;&nbsp;</a></span>get_v5_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_connect_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connect handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a27d1330266d13ff0b170e4c657abb6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d1330266d13ff0b170e4c657abb6de">&#9670;&nbsp;</a></span>get_v5_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_disconnect_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get disconnect handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a4f1644dfe7b9bcdc1686d5d18acc4b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1644dfe7b9bcdc1686d5d18acc4b64">&#9670;&nbsp;</a></span>get_v5_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_puback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get puback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a9570b4057ad94f411edb1e2e277b55dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9570b4057ad94f411edb1e2e277b55dc">&#9670;&nbsp;</a></span>get_v5_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_pubcomp_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubcomp handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a9bb6c7f6eeb3c82349f4537d3ed458e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb6c7f6eeb3c82349f4537d3ed458e9">&#9670;&nbsp;</a></span>get_v5_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_publish_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set publish handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a8397c86d51dda1a9ac6c3c0c2256a830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8397c86d51dda1a9ac6c3c0c2256a830">&#9670;&nbsp;</a></span>get_v5_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_pubrec_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubrec handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a071a92a014d5233238f5ae28152fd986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071a92a014d5233238f5ae28152fd986">&#9670;&nbsp;</a></span>get_v5_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_pubrel_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pubrel handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a38d1f7f25d2c751070b46cb54378a3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d1f7f25d2c751070b46cb54378a3de">&#9670;&nbsp;</a></span>get_v5_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_suback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get suback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="ac16328227abda36b6a1f2545ca93c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16328227abda36b6a1f2545ca93c37e">&#9670;&nbsp;</a></span>get_v5_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_subscribe_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get subscribe handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a9918787471e777e77103597e86f6aaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9918787471e777e77103597e86f6aaf0">&#9670;&nbsp;</a></span>get_v5_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_unsuback_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get unsuback handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a5718b99355d4a38efeb98bb06cf3b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5718b99355d4a38efeb98bb06cf3b680">&#9670;&nbsp;</a></span>get_v5_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a> const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::get_v5_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get unsubscribe handler. </p>
<dl class="section return"><dt>Returns</dt><dd>handler </dd></dl>

</div>
</div>
<a id="a603e33887f77817531c09a42b44a2b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603e33887f77817531c09a42b44a2b5f">&#9670;&nbsp;</a></span>handle_close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::handle_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d91d44cb28cd0bc12b152a242658c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d91d44cb28cd0bc12b152a242658c0a">&#9670;&nbsp;</a></span>handle_close_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::handle_close_or_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5777c847bca2c43af7f7c590b84fc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5777c847bca2c43af7f7c590b84fc61">&#9670;&nbsp;</a></span>handle_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::handle_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16667e5dc589cdfdaa218ebfdfac5d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16667e5dc589cdfdaa218ebfdfac5d6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4092561fca03e915f102636ef86c8f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4092561fca03e915f102636ef86c8f57">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cf3e15fafd93b1b4ff5d21ea0ae2824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf3e15fafd93b1b4ff5d21ea0ae2824">&#9670;&nbsp;</a></span>pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901195</a>. </p>

</div>
</div>
<a id="a7f660a85f6f57610c861ae56c0873474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f660a85f6f57610c861ae56c0873474">&#9670;&nbsp;</a></span>pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901200</a>. </p>

</div>
</div>
<a id="afced92bd371c878c45bf9b357c0d9e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afced92bd371c878c45bf9b357c0d9e99">&#9670;&nbsp;</a></span>puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::puback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBACK Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124</a><br />
 3.4.2.1 PUBACK Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901125</a><br />
 3.4.2.2 PUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93187695d57b90e5c879169216cdaa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93187695d57b90e5c879169216cdaa4a">&#9670;&nbsp;</a></span>pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::pubcomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBCOMP Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901154</a><br />
 3.7.2.1 PUBCOMP Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901155</a><br />
 3.7.2.2 PUBCOMP Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c12f48e7b0fbb01b378dddbe58192fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12f48e7b0fbb01b378dddbe58192fb">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you know ahead of time that qos will be at_most_once, then prefer <a class="el" href="classmqtt_1_1endpoint.html#a098ab1eb391de503160cc3eacd91d7b1" title="Publish QoS0.">publish_at_most_once()</a> over <a class="el" href="classmqtt_1_1endpoint.html#a9c12f48e7b0fbb01b378dddbe58192fb" title="Publish.">publish()</a> as it is slightly more efficent. </dd></dl>

</div>
</div>
<a id="ac7f21b3c942ee014d22834bae3ed3b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f21b3c942ee014d22834bae3ed3b77">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you know ahead of time that qos will be at_most_once, then prefer <a class="el" href="classmqtt_1_1endpoint.html#a098ab1eb391de503160cc3eacd91d7b1" title="Publish QoS0.">publish_at_most_once()</a> over <a class="el" href="classmqtt_1_1endpoint.html#a9c12f48e7b0fbb01b378dddbe58192fb" title="Publish.">publish()</a> as it is slightly more efficent. </dd></dl>

</div>
</div>
<a id="a1a3efe8c8d95e4d75273067b98eb0b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3efe8c8d95e4d75273067b98eb0b76">&#9670;&nbsp;</a></span>publish() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a91c09561f95d0fe2e721b633663480cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c09561f95d0fe2e721b633663480cb">&#9670;&nbsp;</a></span>publish() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a660a7db26317eef7718077bfe68d0df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660a7db26317eef7718077bfe68d0df4">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a77537cee66c89dd2f8ea952e0aaafe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77537cee66c89dd2f8ea952e0aaafe7c">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a531135e53a9f39d976a7140854c8b02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531135e53a9f39d976a7140854c8b02f">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a598f9be4a0929ab22f3082ed76b1459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598f9be4a0929ab22f3082ed76b1459d">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a098ab1eb391de503160cc3eacd91d7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098ab1eb391de503160cc3eacd91d7b1">&#9670;&nbsp;</a></span>publish_at_most_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd2a89c0408ff18be15f31aa8240de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2a89c0408ff18be15f31aa8240de3a">&#9670;&nbsp;</a></span>publish_at_most_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f05a35511d94933ed13564ef33c85ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f05a35511d94933ed13564ef33c85ca">&#9670;&nbsp;</a></span>publish_dup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a0984154e1e1618f6b2db3fdd9ff928ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0984154e1e1618f6b2db3fdd9ff928ed">&#9670;&nbsp;</a></span>publish_dup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a141c7130c2afa94f927af2004529c3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141c7130c2afa94f927af2004529c3a0">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a0f81eb299829767c8f31e5c9f7ba1cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f81eb299829767c8f31e5c9f7ba1cb4">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="aef5d92500fe04217befe3fddd7f241ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d92500fe04217befe3fddd7f241ff">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a97de973ad1d5537fdb71bc5c38dba1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97de973ad1d5537fdb71bc5c38dba1b9">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the async operation is finished. </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901104</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901109</a><br />
 3.3.2.3 PUBLISH Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a26b982f1f1472a467cab3389f7727601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b982f1f1472a467cab3389f7727601">&#9670;&nbsp;</a></span>pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::pubrec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREC Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901134</a><br />
 3.5.2.1 PUBREC Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901135</a><br />
 3.5.2.2 PUBREC Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f6237c9a7bdcce57ffd76f25695e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f6237c9a7bdcce57ffd76f25695e84">&#9670;&nbsp;</a></span>pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::pubrel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::optional&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reason_code</em> = <code>mqtt::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to publish </td></tr>
    <tr><td class="paramname">reason_code</td><td>PUBREL Reason Code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901144</a><br />
 3.6.2.1 PUBREL Reason Code </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901145</a><br />
 3.6.2.2 PUBREL Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42c3eb55085955b355c390dc8f01cb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c3eb55085955b355c390dc8f01cb70">&#9670;&nbsp;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register packet_id to the library. After registering the packet_id, you can call acquired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully registerd then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a0d34346e1c7cb25a8bcad42029e91dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d34346e1c7cb25a8bcad42029e91dd2">&#9670;&nbsp;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release packet_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id to release. only the packet_id gotten by acquire_unique_packet_id, or register_packet_id is permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully released then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="af26a0e0373f2d767c6702ede2bdf737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26a0e0373f2d767c6702ede2bdf737a">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;typename Iterator::value_type, char&gt;::value&gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id of the message </td></tr>
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa710a32bf5d1cd297c30f6233001f6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa710a32bf5d1cd297c30f6233001f6dc">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype">basic_publish_message&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d54f8c6f33c6e5d40cf0cb33d6f1b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d54f8c6f33c6e5d40cf0cb33d6f1b8d">&#9670;&nbsp;</a></span>restore_serialized_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype">basic_pubrel_message&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function should be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abf7a8b0cdf901fc720ca60f838fbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abf7a8b0cdf901fc720ca60f838fbc3">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;typename Iterator::value_type, char&gt;::value&gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id of the message </td></tr>
    <tr><td class="paramname">b</td><td>iterator begin of the message </td></tr>
    <tr><td class="paramname">e</td><td>iterator end of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76d4a070a29cfb96a4da468192e4533c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d4a070a29cfb96a4da468192e4533c">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1v5_1_1basic__publish__message.html">v5::basic_publish_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>publish message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a162918944bb931f6dc9e5e0722dab116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162918944bb931f6dc9e5e0722dab116">&#9670;&nbsp;</a></span>restore_v5_serialized_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::restore_v5_serialized_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmqtt_1_1v5_1_1basic__pubrel__message.html">v5::basic_pubrel_message</a>&lt; PacketIdBytes &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mqtt::any&#160;</td>
          <td class="paramname"><em>life_keeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized pubrel message. This function shouold be called before connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>pubrel message. </td></tr>
    <tr><td class="paramname">life_keeper</td><td>An object that stays alive (but is moved with std::move()) until the stored message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5c24deff5585866eb79b9e66e2629d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c24deff5585866eb79b9e66e2629d6">&#9670;&nbsp;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set auto publish response mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>set value </td></tr>
    <tr><td class="paramname">async</td><td>auto publish ressponse send asynchronous</td></tr>
  </table>
  </dd>
</dl>
<p>When set auto publish response mode to true, puback, pubrec, pubrel,and pub comp automatically send.<br />
 </p>

</div>
</div>
<a id="a7b9182698035a15d040fa02686819188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9182698035a15d040fa02686819188">&#9670;&nbsp;</a></span>set_close_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_close_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ae7a838b7bc8f903e00c05a725d015165">close_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set close handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b4c59c267632d2310994214a3491fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c59c267632d2310994214a3491fcc">&#9670;&nbsp;</a></span>set_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_connack_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aee4550598ca356a864d9c6ba430ecea5">connack_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3102e66c81910bdf71c853de558b87a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3102e66c81910bdf71c853de558b87a8">&#9670;&nbsp;</a></span>set_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7991849053391086331329214cc6fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7991849053391086331329214cc6fef">&#9670;&nbsp;</a></span>set_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_connect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#acdd6c11f298bc4860cd0739febdbe634">connect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a594c81d0aa3c6935bb06aac33909c989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594c81d0aa3c6935bb06aac33909c989">&#9670;&nbsp;</a></span>set_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_disconnect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad197af50cca897a66b5b569342145042">disconnect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set disconnect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb12b84bd8f3e0b64d18d70181fa15f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb12b84bd8f3e0b64d18d70181fa15f4">&#9670;&nbsp;</a></span>set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aac48f7b609189aa01111d2b5dc33ac80">error_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set error handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fc3a33dc1d8e00d524481fec3ab86e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc3a33dc1d8e00d524481fec3ab86e3">&#9670;&nbsp;</a></span>set_is_valid_length_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_is_valid_length_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0a2715b79875b9b659721ccd712bbd28">is_valid_length_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set check length handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8420d2ac96c76cecc826ea70a0d88c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8420d2ac96c76cecc826ea70a0d88c7">&#9670;&nbsp;</a></span>set_max_queue_send_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_count </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum number of concatenating messages. The default value is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>maximum number of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c18bccf713654c34a6a38548e1f265a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c18bccf713654c34a6a38548e1f265a">&#9670;&nbsp;</a></span>set_max_queue_send_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_max_queue_send_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum size of queued message sending. When async message sending function called during asynchronous processing, the message is enqueued. When current asynchronous message is processed, then concatenate queued messages and send it. This value limits the maximum size of concatenating messages. The default value is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>maximum size of queued message sending. 0 means infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a712d30fde32e0145eaf6487e7bf0dac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712d30fde32e0145eaf6487e7bf0dac6">&#9670;&nbsp;</a></span>set_mqtt_message_processed_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_mqtt_message_processed_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ac296e84701849b0309bbe33616314744">mqtt_message_processed_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set custom mqtt_message_processed_handler. The default setting is calling <a class="el" href="classmqtt_1_1endpoint.html#ad6cb098813d109a2aff2b711e35eed61">async_read_control_packet_type()</a>. (See <a class="el" href="classmqtt_1_1endpoint.html#a961a875c2704582bda9a2bc96568d53c" title="Constructor for client.">endpoint()</a> constructor). The typical usecase of this function is delaying the next message reading timing. In order to do that 1) store func parameter of the mqtt_message_processed_handler. 2) call async_read_next_message with the stored func if you are ready to read the next mqtt message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>mqtt_message_processed_handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d1ea159fc6368d4ac01be528d81eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d1ea159fc6368d4ac01be528d81eb7">&#9670;&nbsp;</a></span>set_pingreq_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pingreq_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aa0d6bdb586acc735d5c784196094c361">pingreq_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingreq handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0822d2b2f95d48f35d651a6024ade705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0822d2b2f95d48f35d651a6024ade705">&#9670;&nbsp;</a></span>set_pingresp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pingresp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad1bb95a7462c4a8466c63c860978b2d9">pingresp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingresp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c863cba3f3195e3c4c29be06fa2beca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c863cba3f3195e3c4c29be06fa2beca">&#9670;&nbsp;</a></span>set_pre_send_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pre_send_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a529c52ec7d0ff059cc8bf07c30cfe4e8">pre_send_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pre-send handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0dab3bd490b5732021b677fcb63ec0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dab3bd490b5732021b677fcb63ec0f">&#9670;&nbsp;</a></span>set_protocol_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_protocol_version </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b4b1d3ecbe48f24369c21c7d9fa2b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4b1d3ecbe48f24369c21c7d9fa2b5f">&#9670;&nbsp;</a></span>set_pub_res_sent_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pub_res_sent_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a56b07e4580973cd48becf78b4ea289ac">pub_res_sent_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acae70487ff52d27f7d45d21661097520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae70487ff52d27f7d45d21661097520">&#9670;&nbsp;</a></span>set_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_puback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a21324ca4cb279339cf739bef07007182">puback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a631fd18141650364fae8d43c1351c63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631fd18141650364fae8d43c1351c63b">&#9670;&nbsp;</a></span>set_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pubcomp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a97cfc609fd1a72bfe4594d9f0a7d42a8">pubcomp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abea5620671a58af756f88c97a565baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea5620671a58af756f88c97a565baa2">&#9670;&nbsp;</a></span>set_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_publish_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a9191dc1774a8eab18da4bfa9f84029e4">publish_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a680331c2e7a41eea85aef9345ec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a680331c2e7a41eea85aef9345ec51">&#9670;&nbsp;</a></span>set_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pubrec_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ab1c00e6f461f7eaa6f1b61f2011e203b">pubrec_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a813778af548b866f85cbeb73ae0e7996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813778af548b866f85cbeb73ae0e7996">&#9670;&nbsp;</a></span>set_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_pubrel_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a068ab8287621c9facae754d58e1e9e90">pubrel_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf8bc427d46b88f2ce4d95d1b73728c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf8bc427d46b88f2ce4d95d1b73728c">&#9670;&nbsp;</a></span>set_serialize_handlers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_serialize_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3cfa1defa357702169040bfc7b16fa54">serialize_publish_message_handler</a>&#160;</td>
          <td class="paramname"><em>h_publish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ab5f6de4972fb8a792fae5000c340d969">serialize_pubrel_message_handler</a>&#160;</td>
          <td class="paramname"><em>h_pubrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a>&#160;</td>
          <td class="paramname"><em>h_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set serialize handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_publish</td><td>serialize handler for publish message </td></tr>
    <tr><td class="paramname">h_pubrel</td><td>serialize handler for pubrel message </td></tr>
    <tr><td class="paramname">h_remove</td><td>remove handler for serialized message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a0fc63bf8a29e40b7fba95915ac96a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0fc63bf8a29e40b7fba95915ac96a6">&#9670;&nbsp;</a></span>set_serialize_handlers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_serialize_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a>&#160;</td>
          <td class="paramname"><em>h_publish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h_pubrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a>&#160;</td>
          <td class="paramname"><em>h_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set serialize handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_publish</td><td>serialize handler for publish message </td></tr>
    <tr><td class="paramname">h_pubrel</td><td>serialize handler for pubrel message </td></tr>
    <tr><td class="paramname">h_remove</td><td>remove handler for serialized message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af44bacd086ce8ed70bf72360f124b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af44bacd086ce8ed70bf72360f124b0">&#9670;&nbsp;</a></span>set_serialize_handlers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_serialize_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear serialize handlers. </p>

</div>
</div>
<a id="a95b4bb03ec5e5cf80618390e9d5a7aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b4bb03ec5e5cf80618390e9d5a7aa1">&#9670;&nbsp;</a></span>set_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_suback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a5e70c3f92c2e16a66b3287bc5349da5a">suback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19ac9c540e7e4546f4779c17fb384a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ac9c540e7e4546f4779c17fb384a43">&#9670;&nbsp;</a></span>set_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_subscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a4209361313b60fc85a657c9109a91231">subscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e45217f530112a2af7d9ca20dc86e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e45217f530112a2af7d9ca20dc86e9">&#9670;&nbsp;</a></span>set_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_unsuback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a1cb934072e5052d34fdc5810b1abe8d0">unsuback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afecd32bb7334f6dbc2e012ef030bd8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecd32bb7334f6dbc2e012ef030bd8a3">&#9670;&nbsp;</a></span>set_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ae38cdc0242dbbe0516e391434250c15e">unsubscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf739ddb456257c1c033d0b3d0adc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf739ddb456257c1c033d0b3d0adc7ba">&#9670;&nbsp;</a></span>set_v5_auth_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_auth_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#acec77935e0706fd72187b340a1a8d4d5">v5_auth_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set auth handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db9c1927f33bfa0e3e6b3ebaf963768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db9c1927f33bfa0e3e6b3ebaf963768">&#9670;&nbsp;</a></span>set_v5_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_connack_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a030b892a8e24eb83a322ee336d411f36">v5_connack_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d654d25027b2ff58ee64cbbb30177f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d654d25027b2ff58ee64cbbb30177f2">&#9670;&nbsp;</a></span>set_v5_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_connect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a632d951eddb30b18108d6bc4dbac81c0">v5_connect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8786469e0003b6c7f8022f6a92febb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8786469e0003b6c7f8022f6a92febb0e">&#9670;&nbsp;</a></span>set_v5_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_disconnect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a2e9d8e8241a0a01307717ce9cac2135e">v5_disconnect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set disconnect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfc3fa1f95f31e4985d6eca3c1a844ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc3fa1f95f31e4985d6eca3c1a844ff">&#9670;&nbsp;</a></span>set_v5_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_puback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a7eae1974ed82284cd8deb9f5597b5e56">v5_puback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a083b480ea82750577ef63dd6b99b2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083b480ea82750577ef63dd6b99b2d2a">&#9670;&nbsp;</a></span>set_v5_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_pubcomp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a10847e9fe9331cd8ce1fc8a16dba18e3">v5_pubcomp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0bd780f601f9d861f9651a515f01e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bd780f601f9d861f9651a515f01e07">&#9670;&nbsp;</a></span>set_v5_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_publish_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#af05b370879b50e3c87fdaf131d587a78">v5_publish_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set publish handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a452640ab312e93ef3c91b641ae0eea45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452640ab312e93ef3c91b641ae0eea45">&#9670;&nbsp;</a></span>set_v5_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_pubrec_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ae70bfc06f9c5a565c23380c55ada5ae4">v5_pubrec_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab30ff8232298b2196c185876b361d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab30ff8232298b2196c185876b361d34">&#9670;&nbsp;</a></span>set_v5_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_pubrel_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ac700f606579048afc30e571f71514836">v5_pubrel_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d9c2704b2e3bd6a90c2287c2f9c7a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c2704b2e3bd6a90c2287c2f9c7a64">&#9670;&nbsp;</a></span>set_v5_serialize_handlers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_serialize_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae5737b8a9b39dbe81c74ff2e28ffe492">serialize_v5_publish_message_handler</a>&#160;</td>
          <td class="paramname"><em>h_publish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a25e3f811f69990b8be27e681e00e414c">serialize_v5_pubrel_message_handler</a>&#160;</td>
          <td class="paramname"><em>h_pubrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a>&#160;</td>
          <td class="paramname"><em>h_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set serialize handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_publish</td><td>serialize handler for publish message </td></tr>
    <tr><td class="paramname">h_pubrel</td><td>serialize handler for pubrel message </td></tr>
    <tr><td class="paramname">h_remove</td><td>remove handler for serialized message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e94d3c72c95c6d769ec269cb83d81c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e94d3c72c95c6d769ec269cb83d81c5">&#9670;&nbsp;</a></span>set_v5_serialize_handlers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_serialize_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a7c08d527a83ba699572cb14a4294b392">serialize_publish_handler</a>&#160;</td>
          <td class="paramname"><em>h_publish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a753823cea6186f17d19f50b61f706eec">serialize_pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h_pubrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae5ad8841aa15503d13798ee9f682cba1">serialize_remove_handler</a>&#160;</td>
          <td class="paramname"><em>h_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set serialize handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_publish</td><td>serialize handler for publish message </td></tr>
    <tr><td class="paramname">h_pubrel</td><td>serialize handler for pubrel message </td></tr>
    <tr><td class="paramname">h_remove</td><td>remove handler for serialized message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a183d211deb953ab4d1d5df6516ab91d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183d211deb953ab4d1d5df6516ab91d5">&#9670;&nbsp;</a></span>set_v5_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_suback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#af5885dff8fbe5e74fdf99d1cd77d5293">v5_suback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1756a1b5632ee546097132bf079c861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1756a1b5632ee546097132bf079c861">&#9670;&nbsp;</a></span>set_v5_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_subscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a1fbcb705b084e7a61e5c54145a636fab">v5_subscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f40f2e30f7f20e2cf1de5b91bc09cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f40f2e30f7f20e2cf1de5b91bc09cad">&#9670;&nbsp;</a></span>set_v5_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_unsuback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#abb50e8b139acb089940258c841731278">v5_unsuback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46001164a6cc4e94022ccc7565339999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46001164a6cc4e94022ccc7565339999">&#9670;&nbsp;</a></span>set_v5_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::set_v5_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a65060d5a517664f63899fcfcc5f39607">v5_unsubscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343315ef280f69efadc7be61fe658909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343315ef280f69efadc7be61fe658909">&#9670;&nbsp;</a></span>socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt;&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Socket unique_ptr reference. </p>
<dl class="section return"><dt>Returns</dt><dd>refereence of Socket unique_ptr </dd></dl>

</div>
</div>
<a id="afd2a59f50ac9f19c63ef57a50f0d80ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2a59f50ac9f19c63ef57a50f0d80ca">&#9670;&nbsp;</a></span>socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt; const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Socket unique_ptr const reference. </p>
<dl class="section return"><dt>Returns</dt><dd>const refereence of Socket unique_ptr </dd></dl>

</div>
</div>
<a id="ac29f251407d9db5cc5b3d761fdf74ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29f251407d9db5cc5b3d761fdf74ac7">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::start_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a3b0c60837d4b3509b8d76475ffcc258b">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start session with a connected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>finish handler that is called when the session is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a384515a1105c2efa19a8172797b45590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384515a1105c2efa19a8172797b45590">&#9670;&nbsp;</a></span>suback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c55ff86d5383fde631c78039d519f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55ff86d5383fde631c78039d519f51">&#9670;&nbsp;</a></span>suback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::suback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178</a><br />
 3.9.3 SUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901174</a><br />
 3.9.2.1 SUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12aa1691905481eb92e742dfe733d95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa1691905481eb92e742dfe733d95a">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and option. You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a8b11d79e8db71d62ee9e0eb1683fd0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b11d79e8db71d62ee9e0eb1683fd0c9">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">option</td><td>subscription options<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and option. You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="acecb3cd35541b9f418375799d7314149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecb3cd35541b9f418375799d7314149">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and option pair. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="a4659f80cfc111a4e5d0d2c4acb100a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4659f80cfc111a4e5d0d2c4acb100a0c">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and option pair. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169</a><br />
 3.8.3.1 Subscription Options </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a> </dd></dl>

</div>
</div>
<a id="aa8cd77e26c42dcb3f59d69daa62ac655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cd77e26c42dcb3f59d69daa62ac655">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="aed35731778382040034756d751e23dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed35731778382040034756d751e23dd9">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="a0308c6430ad11699c4e4c47cdbf50880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0308c6430ad11699c4e4c47cdbf50880">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="a5767724773143980305d04bf4ac671b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5767724773143980305d04bf4ac671b8">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; as::const_buffer, std::uint8_t &gt;&gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901164</a><br />
 3.8.2.1 SUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901161</a><br />
 </dd></dl>

</div>
</div>
<a id="a199ecdf3b7c671aa3f2c0993380a634b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199ecdf3b7c671aa3f2c0993380a634b">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec3bada4794beb926418b1e144e0c849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3bada4794beb926418b1e144e0c849">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reason</td><td>reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">args</td><td>additional reason_code You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e17ae6c772649a38ec6bc32e58b7197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e17ae6c772649a38ec6bc32e58b7197">&#9670;&nbsp;</a></span>unsuback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>reasons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet id corresponding to subscribe </td></tr>
    <tr><td class="paramname">reasons</td><td>a collection of reason_code<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194</a><br />
 3.11.3 UNSUBACK Payload </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901190</a><br />
 3.11.2.1 UNSUBACK Properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac76c10839fa3ee9b9b5351def86354bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76c10839fa3ee9b9b5351def86354bb">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a165bb916cd66aa0293d4d485b664d4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165bb916cd66aa0293d4d485b664d4c3">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="afe5e7183594b79954804007f82a25390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5e7183594b79954804007f82a25390">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a81d4df813aaeb1677044593891d9a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d4df813aaeb1677044593891d9a6f0">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a> <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a57967a376162f169a0d5201ab947684e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57967a376162f169a0d5201ab947684e">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a>&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ab4bab39826018e2b4ec82a269b6dd806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bab39826018e2b4ec82a269b6dd806">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">as::const_buffer&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can set props as the last argument optionally. See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="ae9446ef8e8bddaf753278414eb884886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9446ef8e8bddaf753278414eb884886">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt.html#a1e249157423d6f0b6aee2a4bfdf02818">mqtt::string_view</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<a id="a688c011f9283903c3273de2e463e7544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688c011f9283903c3273de2e463e7544">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a564cd0242f23b05aaf94e65ad7effd3a">packet_id_t</a>&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; as::const_buffer &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemqtt_1_1v5.html#ac3a1d8ec4d26da023cc887a4f220328e">v5::property_variant</a> &gt;&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
    <tr><td class="paramname">props</td><td>Properties<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901182</a><br />
 3.10.2.1 UNSUBSCRIBE Properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179">https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901179</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a12e8ef2b9409123639f03b756a5893b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e8ef2b9409123639f03b756a5893b4">&#9670;&nbsp;</a></span>clean_session_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard, std::size_t PacketIdBytes = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard, PacketIdBytes &gt;::clean_session_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/mqtt_cpp/include/mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
