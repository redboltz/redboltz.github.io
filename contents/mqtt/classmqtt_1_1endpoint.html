<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mqtt_cpp: mqtt::endpoint&lt; Socket, Mutex, LockGuard &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mqtt_cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemqtt.html">mqtt</a></li><li class="navelem"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmqtt_1_1endpoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::endpoint&lt; Socket, Mutex, LockGuard &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mqtt::endpoint&lt; Socket, Mutex, LockGuard &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmqtt_1_1endpoint.png" usemap="#mqtt::endpoint_3C_20Socket_2C_20Mutex_2C_20LockGuard_20_3E_map" alt=""/>
  <map id="mqtt::endpoint_3C_20Socket_2C_20Mutex_2C_20LockGuard_20_3E_map" name="mqtt::endpoint_3C_20Socket_2C_20Mutex_2C_20LockGuard_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b6d41af55d98695f2c0006d7c8760f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:a0b6d41af55d98695f2c0006d7c8760f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd2f3ab9044a470bf05361649d29cd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:a6fd2f3ab9044a470bf05361649d29cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4283a3190a40cef9bc8305988fa03332"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a> = std::function&lt; void(boost::system::error_code const  &amp;ec)&gt;</td></tr>
<tr class="separator:a4283a3190a40cef9bc8305988fa03332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c32f3d8b1a1f8b1bc7eb7c32d03f901"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a> = std::function&lt; bool(std::string const  &amp;<a class="el" href="classmqtt_1_1endpoint.html#af3ba768fd77e275700ccdf2f470d9271">client_id</a>, boost::optional&lt; std::string &gt; const  &amp;username, boost::optional&lt; std::string &gt; const  &amp;password, boost::optional&lt; <a class="el" href="classmqtt_1_1will.html">will</a> &gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#a8ba033264e623b3504f3e21704ee852f">clean_session</a>, std::uint16_t keep_alive)&gt;</td></tr>
<tr class="separator:a8c32f3d8b1a1f8b1bc7eb7c32d03f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28b1eafa1224b5584fcd60d5cd46e85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a> = std::function&lt; bool(bool session_present, std::uint8_t return_code)&gt;</td></tr>
<tr class="separator:aa28b1eafa1224b5584fcd60d5cd46e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec521e69b94ffcb12466680fe817b5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a> = std::function&lt; bool(std::uint8_t fixed_header, boost::optional&lt; std::uint16_t &gt; packet_id, std::string topic_name, std::string contents)&gt;</td></tr>
<tr class="separator:a4ec521e69b94ffcb12466680fe817b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf238d6b1125c3f451c0e27135df13c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:a4cf238d6b1125c3f451c0e27135df13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9b7dc0794ccdca635ff74a9cb21684"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:a7a9b7dc0794ccdca635ff74a9cb21684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b303b77abde049f81b590830366db6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:ae7b303b77abde049f81b590830366db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fbf91bb4bfc0d3da01e0fd3cb29194"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a> = std::function&lt; bool(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:ad9fbf91bb4bfc0d3da01e0fd3cb29194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c1deb23deb1e0e30f4e16da8119958"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a> = std::function&lt; void(std::uint16_t packet_id)&gt;</td></tr>
<tr class="separator:ad7c1deb23deb1e0e30f4e16da8119958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603aa05bca6418513bfc57c5c1caf310"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt; &gt; entries)&gt;</td></tr>
<tr class="separator:a603aa05bca6418513bfc57c5c1caf310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc808e9551b6a8bb4e08eb09a237c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; boost::optional&lt; std::uint8_t &gt; &gt; qoss)&gt;</td></tr>
<tr class="separator:aebdc808e9551b6a8bb4e08eb09a237c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ebbb8efccdd96e283637993ddb4f89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a> = std::function&lt; bool(std::uint16_t packet_id, std::vector&lt; std::string &gt; topics)&gt;</td></tr>
<tr class="separator:a80ebbb8efccdd96e283637993ddb4f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b1508ff56344254ddee6f25b72aab8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a> = std::function&lt; bool(std::uint16_t)&gt;</td></tr>
<tr class="separator:ad3b1508ff56344254ddee6f25b72aab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a8b43aee18e3f80f617db4e17bb333"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="separator:a13a8b43aee18e3f80f617db4e17bb333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72955c0d18dba21b99bb63569d0272fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a> = std::function&lt; bool()&gt;</td></tr>
<tr class="separator:a72955c0d18dba21b99bb63569d0272fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237958267803c9866f76ea7ce589cb59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a> = std::function&lt; void()&gt;</td></tr>
<tr class="separator:a237958267803c9866f76ea7ce589cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e0fe1bffe35a0f3e5426b21f825586"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a48e0fe1bffe35a0f3e5426b21f825586">serialize_publish_handler</a> = std::function&lt; void(std::uint16_t, char const  *, std::size_t)&gt;</td></tr>
<tr class="separator:a48e0fe1bffe35a0f3e5426b21f825586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3024a20954122cb70b187094411e1250"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3024a20954122cb70b187094411e1250">serialize_pubrel_handler</a> = std::function&lt; void(std::uint16_t, char const  *, std::size_t)&gt;</td></tr>
<tr class="separator:a3024a20954122cb70b187094411e1250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529d482d78e4733dfe88d729fd8a4778"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a529d482d78e4733dfe88d729fd8a4778">serialize_remove_handler</a> = std::function&lt; void(std::uint16_t)&gt;</td></tr>
<tr class="separator:a529d482d78e4733dfe88d729fd8a4778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5a08d25c50d30485ab88d5cda4643bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae5a08d25c50d30485ab88d5cda4643bf">endpoint</a> ()</td></tr>
<tr class="memdesc:ae5a08d25c50d30485ab88d5cda4643bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for client.  <a href="#ae5a08d25c50d30485ab88d5cda4643bf">More...</a><br /></td></tr>
<tr class="separator:ae5a08d25c50d30485ab88d5cda4643bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855e3b7180ccbecd93b7c041179cc46a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a855e3b7180ccbecd93b7c041179cc46a">endpoint</a> (std::unique_ptr&lt; Socket &gt; &amp;&amp;<a class="el" href="classmqtt_1_1endpoint.html#ae9a39d3dc415bed7c68a62cdd9a0bd48">socket</a>)</td></tr>
<tr class="memdesc:a855e3b7180ccbecd93b7c041179cc46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for server. socket should have already been connected with another endpoint.  <a href="#a855e3b7180ccbecd93b7c041179cc46a">More...</a><br /></td></tr>
<tr class="separator:a855e3b7180ccbecd93b7c041179cc46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc47a7059a05f53efa53167f388dcee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7cc47a7059a05f53efa53167f388dcee">endpoint</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:a7cc47a7059a05f53efa53167f388dcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b52e8785b73dc344dccb856cc4b85cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7b52e8785b73dc344dccb856cc4b85cc">endpoint</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7b52e8785b73dc344dccb856cc4b85cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec958783746c6fae3136161fc08dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad9ec958783746c6fae3136161fc08dd7">operator=</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;)=delete</td></tr>
<tr class="separator:ad9ec958783746c6fae3136161fc08dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec08953e522baa589dcc596b5513aa2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aec08953e522baa589dcc596b5513aa2b">operator=</a> (<a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aec08953e522baa589dcc596b5513aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367310df411f0b1517d7d10231412ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae367310df411f0b1517d7d10231412ab">set_client_id</a> (std::string id)</td></tr>
<tr class="separator:ae367310df411f0b1517d7d10231412ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ba768fd77e275700ccdf2f470d9271"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af3ba768fd77e275700ccdf2f470d9271">client_id</a> () const</td></tr>
<tr class="separator:af3ba768fd77e275700ccdf2f470d9271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff260217fb3474f276e86c1a7f21303e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aff260217fb3474f276e86c1a7f21303e">set_clean_session</a> (bool cs)</td></tr>
<tr class="separator:aff260217fb3474f276e86c1a7f21303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba033264e623b3504f3e21704ee852f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8ba033264e623b3504f3e21704ee852f">clean_session</a> () const</td></tr>
<tr class="separator:a8ba033264e623b3504f3e21704ee852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5912a8486fae2d60e53738538d8ea79b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5912a8486fae2d60e53738538d8ea79b">set_user_name</a> (std::string name)</td></tr>
<tr class="separator:a5912a8486fae2d60e53738538d8ea79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30b4481258c7c4bc1caa444187282ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af30b4481258c7c4bc1caa444187282ea">set_password</a> (std::string password)</td></tr>
<tr class="separator:af30b4481258c7c4bc1caa444187282ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858b242da7b69c635fc459d0085e0721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a858b242da7b69c635fc459d0085e0721">set_will</a> (<a class="el" href="classmqtt_1_1will.html">will</a> w)</td></tr>
<tr class="separator:a858b242da7b69c635fc459d0085e0721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b261bea1cab969cca812a2ddd503b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9b261bea1cab969cca812a2ddd503b29">set_auto_pub_response</a> (bool b=true, bool async=true)</td></tr>
<tr class="separator:a9b261bea1cab969cca812a2ddd503b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c6e70cd0d0a3dc3120f11312d12148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae9c6e70cd0d0a3dc3120f11312d12148">set_close_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a>())</td></tr>
<tr class="memdesc:ae9c6e70cd0d0a3dc3120f11312d12148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set close handler.  <a href="#ae9c6e70cd0d0a3dc3120f11312d12148">More...</a><br /></td></tr>
<tr class="separator:ae9c6e70cd0d0a3dc3120f11312d12148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5f2a2ab14653833f2e763284e6f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1dc5f2a2ab14653833f2e763284e6f8f">set_error_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a>())</td></tr>
<tr class="memdesc:a1dc5f2a2ab14653833f2e763284e6f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error handler.  <a href="#a1dc5f2a2ab14653833f2e763284e6f8f">More...</a><br /></td></tr>
<tr class="separator:a1dc5f2a2ab14653833f2e763284e6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d592c552de6d23134a485ab9f9b34e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a65d592c552de6d23134a485ab9f9b34e">set_connect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a>())</td></tr>
<tr class="memdesc:a65d592c552de6d23134a485ab9f9b34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connect handler.  <a href="#a65d592c552de6d23134a485ab9f9b34e">More...</a><br /></td></tr>
<tr class="separator:a65d592c552de6d23134a485ab9f9b34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044cf23b497ad19cfde32346294b7a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a044cf23b497ad19cfde32346294b7a29">set_connack_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a>())</td></tr>
<tr class="memdesc:a044cf23b497ad19cfde32346294b7a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connack handler.  <a href="#a044cf23b497ad19cfde32346294b7a29">More...</a><br /></td></tr>
<tr class="separator:a044cf23b497ad19cfde32346294b7a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e8e430c7384310ccc48512bba60926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab2e8e430c7384310ccc48512bba60926">set_publish_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a>())</td></tr>
<tr class="memdesc:ab2e8e430c7384310ccc48512bba60926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#ab2e8e430c7384310ccc48512bba60926">More...</a><br /></td></tr>
<tr class="separator:ab2e8e430c7384310ccc48512bba60926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbffccd310664d0ed464bf236109f67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abbffccd310664d0ed464bf236109f67f">set_puback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a>())</td></tr>
<tr class="memdesc:abbffccd310664d0ed464bf236109f67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set puback handler.  <a href="#abbffccd310664d0ed464bf236109f67f">More...</a><br /></td></tr>
<tr class="separator:abbffccd310664d0ed464bf236109f67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fbb227b4b3d1b5845cba0643831813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a79fbb227b4b3d1b5845cba0643831813">set_pubrec_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a>())</td></tr>
<tr class="memdesc:a79fbb227b4b3d1b5845cba0643831813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrec handler.  <a href="#a79fbb227b4b3d1b5845cba0643831813">More...</a><br /></td></tr>
<tr class="separator:a79fbb227b4b3d1b5845cba0643831813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee191bcfd559797248d869fd25e3afb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aee191bcfd559797248d869fd25e3afb0">set_pubrel_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a>())</td></tr>
<tr class="memdesc:aee191bcfd559797248d869fd25e3afb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubrel handler.  <a href="#aee191bcfd559797248d869fd25e3afb0">More...</a><br /></td></tr>
<tr class="separator:aee191bcfd559797248d869fd25e3afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83f74d5986ce4242f2e5d34b71e0051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad83f74d5986ce4242f2e5d34b71e0051">set_pubcomp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a>())</td></tr>
<tr class="memdesc:ad83f74d5986ce4242f2e5d34b71e0051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#ad83f74d5986ce4242f2e5d34b71e0051">More...</a><br /></td></tr>
<tr class="separator:ad83f74d5986ce4242f2e5d34b71e0051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b26c627180a09a6456d605d0f661545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1b26c627180a09a6456d605d0f661545">set_pub_res_sent_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a>())</td></tr>
<tr class="memdesc:a1b26c627180a09a6456d605d0f661545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pubcomp handler.  <a href="#a1b26c627180a09a6456d605d0f661545">More...</a><br /></td></tr>
<tr class="separator:a1b26c627180a09a6456d605d0f661545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bd623a1d7474797f0d49c1eed0ff76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad6bd623a1d7474797f0d49c1eed0ff76">set_subscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a>())</td></tr>
<tr class="memdesc:ad6bd623a1d7474797f0d49c1eed0ff76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subscribe handler.  <a href="#ad6bd623a1d7474797f0d49c1eed0ff76">More...</a><br /></td></tr>
<tr class="separator:ad6bd623a1d7474797f0d49c1eed0ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5952c577be18487ddb6244e20c8cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1d5952c577be18487ddb6244e20c8cfa">set_suback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a>())</td></tr>
<tr class="memdesc:a1d5952c577be18487ddb6244e20c8cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set suback handler.  <a href="#a1d5952c577be18487ddb6244e20c8cfa">More...</a><br /></td></tr>
<tr class="separator:a1d5952c577be18487ddb6244e20c8cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412c27a7710d08a46a843a981a9d0e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a412c27a7710d08a46a843a981a9d0e71">set_unsubscribe_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a>())</td></tr>
<tr class="memdesc:a412c27a7710d08a46a843a981a9d0e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsubscribe handler.  <a href="#a412c27a7710d08a46a843a981a9d0e71">More...</a><br /></td></tr>
<tr class="separator:a412c27a7710d08a46a843a981a9d0e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c05ad6e1c692b83adf1e620fa18ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af3c05ad6e1c692b83adf1e620fa18ae9">set_unsuback_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a>())</td></tr>
<tr class="memdesc:af3c05ad6e1c692b83adf1e620fa18ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set unsuback handler.  <a href="#af3c05ad6e1c692b83adf1e620fa18ae9">More...</a><br /></td></tr>
<tr class="separator:af3c05ad6e1c692b83adf1e620fa18ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6cdc6c0e609ebd842a35d62b9bd78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5f6cdc6c0e609ebd842a35d62b9bd78b">set_pingreq_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a>())</td></tr>
<tr class="memdesc:a5f6cdc6c0e609ebd842a35d62b9bd78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingreq handler.  <a href="#a5f6cdc6c0e609ebd842a35d62b9bd78b">More...</a><br /></td></tr>
<tr class="separator:a5f6cdc6c0e609ebd842a35d62b9bd78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0147fed46ca1bef39d25264f0b058585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0147fed46ca1bef39d25264f0b058585">set_pingresp_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a>())</td></tr>
<tr class="memdesc:a0147fed46ca1bef39d25264f0b058585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pingresp handler.  <a href="#a0147fed46ca1bef39d25264f0b058585">More...</a><br /></td></tr>
<tr class="separator:a0147fed46ca1bef39d25264f0b058585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac462694eb41e63598c3d6cbc3fbbbdc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac462694eb41e63598c3d6cbc3fbbbdc5">set_disconnect_handler</a> (<a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a> h=<a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a>())</td></tr>
<tr class="memdesc:ac462694eb41e63598c3d6cbc3fbbbdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set disconnect handler.  <a href="#ac462694eb41e63598c3d6cbc3fbbbdc5">More...</a><br /></td></tr>
<tr class="separator:ac462694eb41e63598c3d6cbc3fbbbdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051193db6f0bd16f4ec8c6c05547f33a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a051193db6f0bd16f4ec8c6c05547f33a">set_serialize_handlers</a> (<a class="el" href="classmqtt_1_1endpoint.html#a48e0fe1bffe35a0f3e5426b21f825586">serialize_publish_handler</a> h_publish, <a class="el" href="classmqtt_1_1endpoint.html#a3024a20954122cb70b187094411e1250">serialize_pubrel_handler</a> h_pubrel, <a class="el" href="classmqtt_1_1endpoint.html#a529d482d78e4733dfe88d729fd8a4778">serialize_remove_handler</a> h_remove)</td></tr>
<tr class="memdesc:a051193db6f0bd16f4ec8c6c05547f33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serialize handlers.  <a href="#a051193db6f0bd16f4ec8c6c05547f33a">More...</a><br /></td></tr>
<tr class="separator:a051193db6f0bd16f4ec8c6c05547f33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f8cc98b19fa6efb4859afcc7974af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae6f8cc98b19fa6efb4859afcc7974af4">set_serialize_handlers</a> ()</td></tr>
<tr class="memdesc:ae6f8cc98b19fa6efb4859afcc7974af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear serialize handlers.  <a href="#ae6f8cc98b19fa6efb4859afcc7974af4">More...</a><br /></td></tr>
<tr class="separator:ae6f8cc98b19fa6efb4859afcc7974af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8d691bd7c6ad79231945d7cba63dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0b8d691bd7c6ad79231945d7cba63dd8">start_session</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0b8d691bd7c6ad79231945d7cba63dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">start session with a connected endpoint.  <a href="#a0b8d691bd7c6ad79231945d7cba63dd8">More...</a><br /></td></tr>
<tr class="separator:a0b8d691bd7c6ad79231945d7cba63dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4f162ba7875a79c846180447b43ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ada4f162ba7875a79c846180447b43ab8">publish_at_most_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:ada4f162ba7875a79c846180447b43ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#ada4f162ba7875a79c846180447b43ab8">More...</a><br /></td></tr>
<tr class="separator:ada4f162ba7875a79c846180447b43ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bd397b4260ecab66c2a24949e40e3b"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a13bd397b4260ecab66c2a24949e40e3b">publish_at_least_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a13bd397b4260ecab66c2a24949e40e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a13bd397b4260ecab66c2a24949e40e3b">More...</a><br /></td></tr>
<tr class="separator:a13bd397b4260ecab66c2a24949e40e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b1bad31ccc1cbb2b8befe7d1c06743"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a15b1bad31ccc1cbb2b8befe7d1c06743">publish_exactly_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a15b1bad31ccc1cbb2b8befe7d1c06743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a15b1bad31ccc1cbb2b8befe7d1c06743">More...</a><br /></td></tr>
<tr class="separator:a15b1bad31ccc1cbb2b8befe7d1c06743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50a6337d74249b1b89730d8edf5a2ed"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab50a6337d74249b1b89730d8edf5a2ed">publish</a> (std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:ab50a6337d74249b1b89730d8edf5a2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#ab50a6337d74249b1b89730d8edf5a2ed">More...</a><br /></td></tr>
<tr class="separator:ab50a6337d74249b1b89730d8edf5a2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eeee286ecfdf935ff41145516061bf5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3eeee286ecfdf935ff41145516061bf5"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3eeee286ecfdf935ff41145516061bf5">subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:a3eeee286ecfdf935ff41145516061bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a3eeee286ecfdf935ff41145516061bf5">More...</a><br /></td></tr>
<tr class="separator:a3eeee286ecfdf935ff41145516061bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aee9d5020a4d36e8e5b47f239464e3"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a23aee9d5020a4d36e8e5b47f239464e3">subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:a23aee9d5020a4d36e8e5b47f239464e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a23aee9d5020a4d36e8e5b47f239464e3">More...</a><br /></td></tr>
<tr class="separator:a23aee9d5020a4d36e8e5b47f239464e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e1dc447ae3e0afdb9cc0459d67623"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa66e1dc447ae3e0afdb9cc0459d67623"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa66e1dc447ae3e0afdb9cc0459d67623">unsubscribe</a> (std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:aa66e1dc447ae3e0afdb9cc0459d67623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#aa66e1dc447ae3e0afdb9cc0459d67623">More...</a><br /></td></tr>
<tr class="separator:aa66e1dc447ae3e0afdb9cc0459d67623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb83dcd17c92fad43985f7115a9771c1"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeb83dcd17c92fad43985f7115a9771c1">unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:aeb83dcd17c92fad43985f7115a9771c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#aeb83dcd17c92fad43985f7115a9771c1">More...</a><br /></td></tr>
<tr class="separator:aeb83dcd17c92fad43985f7115a9771c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc057e855eb7f05e9296a650c4d490e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7">disconnect</a> ()</td></tr>
<tr class="memdesc:abc057e855eb7f05e9296a650c4d490e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
  <a href="#abc057e855eb7f05e9296a650c4d490e7">More...</a><br /></td></tr>
<tr class="separator:abc057e855eb7f05e9296a650c4d490e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae7f04812bee8468b19e8cb26420901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a5ae7f04812bee8468b19e8cb26420901">force_disconnect</a> ()</td></tr>
<tr class="memdesc:a5ae7f04812bee8468b19e8cb26420901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a5ae7f04812bee8468b19e8cb26420901" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
  <a href="#a5ae7f04812bee8468b19e8cb26420901">More...</a><br /></td></tr>
<tr class="separator:a5ae7f04812bee8468b19e8cb26420901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f9ce7ae62c7be12d6d4546a0344bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a67f9ce7ae62c7be12d6d4546a0344bf3">publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a67f9ce7ae62c7be12d6d4546a0344bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a67f9ce7ae62c7be12d6d4546a0344bf3">More...</a><br /></td></tr>
<tr class="separator:a67f9ce7ae62c7be12d6d4546a0344bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5adbb21de745dd4abae39dee1964569"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad5adbb21de745dd4abae39dee1964569">publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:ad5adbb21de745dd4abae39dee1964569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#ad5adbb21de745dd4abae39dee1964569">More...</a><br /></td></tr>
<tr class="separator:ad5adbb21de745dd4abae39dee1964569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4fcddac86301a827ac2f9f8cec7617"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acf4fcddac86301a827ac2f9f8cec7617">publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:acf4fcddac86301a827ac2f9f8cec7617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#acf4fcddac86301a827ac2f9f8cec7617">More...</a><br /></td></tr>
<tr class="separator:acf4fcddac86301a827ac2f9f8cec7617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60c56d4269548293e21ac7453420388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad60c56d4269548293e21ac7453420388">publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:ad60c56d4269548293e21ac7453420388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#ad60c56d4269548293e21ac7453420388">More...</a><br /></td></tr>
<tr class="separator:ad60c56d4269548293e21ac7453420388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba66b7682d76365889917892549fae61"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aba66b7682d76365889917892549fae61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aba66b7682d76365889917892549fae61">subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:aba66b7682d76365889917892549fae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#aba66b7682d76365889917892549fae61">More...</a><br /></td></tr>
<tr class="separator:aba66b7682d76365889917892549fae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af072282853a43776a6e03eb1990f6dac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af072282853a43776a6e03eb1990f6dac">subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:af072282853a43776a6e03eb1990f6dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#af072282853a43776a6e03eb1990f6dac">More...</a><br /></td></tr>
<tr class="separator:af072282853a43776a6e03eb1990f6dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b8397ae767dfda448bdba5753f6e60"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af5b8397ae767dfda448bdba5753f6e60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af5b8397ae767dfda448bdba5753f6e60">unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:af5b8397ae767dfda448bdba5753f6e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#af5b8397ae767dfda448bdba5753f6e60">More...</a><br /></td></tr>
<tr class="separator:af5b8397ae767dfda448bdba5753f6e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792f54da142010f8eeb4fb75d9d06f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1792f54da142010f8eeb4fb75d9d06f1">unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:a1792f54da142010f8eeb4fb75d9d06f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a1792f54da142010f8eeb4fb75d9d06f1">More...</a><br /></td></tr>
<tr class="separator:a1792f54da142010f8eeb4fb75d9d06f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448af811857b5c44fea310e4edb57e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a448af811857b5c44fea310e4edb57e3f">acquired_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a448af811857b5c44fea310e4edb57e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with already acquired packet identifier.  <a href="#a448af811857b5c44fea310e4edb57e3f">More...</a><br /></td></tr>
<tr class="separator:a448af811857b5c44fea310e4edb57e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd7357cc6d6e7099ab2c952c8f8a907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7cd7357cc6d6e7099ab2c952c8f8a907">acquired_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false)</td></tr>
<tr class="memdesc:a7cd7357cc6d6e7099ab2c952c8f8a907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with already acquired packet identifier.  <a href="#a7cd7357cc6d6e7099ab2c952c8f8a907">More...</a><br /></td></tr>
<tr class="separator:a7cd7357cc6d6e7099ab2c952c8f8a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a46a578370d094fb3f8bc73d88bd6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a67a46a578370d094fb3f8bc73d88bd6b">acquired_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:a67a46a578370d094fb3f8bc73d88bd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with already acquired packet identifier.  <a href="#a67a46a578370d094fb3f8bc73d88bd6b">More...</a><br /></td></tr>
<tr class="separator:a67a46a578370d094fb3f8bc73d88bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b1201af2bdb88e45f4b1ae5b77d300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac4b1201af2bdb88e45f4b1ae5b77d300">acquired_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false)</td></tr>
<tr class="memdesc:ac4b1201af2bdb88e45f4b1ae5b77d300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with already acquired packet identifier.  <a href="#ac4b1201af2bdb88e45f4b1ae5b77d300">More...</a><br /></td></tr>
<tr class="separator:ac4b1201af2bdb88e45f4b1ae5b77d300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c2ffcb56e17fda8a8d71c5794090df"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad9c2ffcb56e17fda8a8d71c5794090df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad9c2ffcb56e17fda8a8d71c5794090df">acquired_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args... args)</td></tr>
<tr class="memdesc:ad9c2ffcb56e17fda8a8d71c5794090df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#ad9c2ffcb56e17fda8a8d71c5794090df">More...</a><br /></td></tr>
<tr class="separator:ad9c2ffcb56e17fda8a8d71c5794090df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9438d6a87bed42f46faaf030f0f8582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ab9438d6a87bed42f46faaf030f0f8582">acquired_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params)</td></tr>
<tr class="memdesc:ab9438d6a87bed42f46faaf030f0f8582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with already acquired packet identifier.  <a href="#ab9438d6a87bed42f46faaf030f0f8582">More...</a><br /></td></tr>
<tr class="separator:ab9438d6a87bed42f46faaf030f0f8582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d1a8f45d0953d4a06a3b6d3a5f9570"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a79d1a8f45d0953d4a06a3b6d3a5f9570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a79d1a8f45d0953d4a06a3b6d3a5f9570">acquired_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args... args)</td></tr>
<tr class="memdesc:a79d1a8f45d0953d4a06a3b6d3a5f9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#a79d1a8f45d0953d4a06a3b6d3a5f9570">More...</a><br /></td></tr>
<tr class="separator:a79d1a8f45d0953d4a06a3b6d3a5f9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5d6fd47f7fb59bcd712ce6cf855af1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aed5d6fd47f7fb59bcd712ce6cf855af1">acquired_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params)</td></tr>
<tr class="memdesc:aed5d6fd47f7fb59bcd712ce6cf855af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with already acquired packet identifier.  <a href="#aed5d6fd47f7fb59bcd712ce6cf855af1">More...</a><br /></td></tr>
<tr class="separator:aed5d6fd47f7fb59bcd712ce6cf855af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0945a20dfeb0ffbc92958e3c92861d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa0945a20dfeb0ffbc92958e3c92861d7">pingreq</a> ()</td></tr>
<tr class="memdesc:aa0945a20dfeb0ffbc92958e3c92861d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a>.  <a href="#aa0945a20dfeb0ffbc92958e3c92861d7">More...</a><br /></td></tr>
<tr class="separator:aa0945a20dfeb0ffbc92958e3c92861d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370157bf41d88daaae3d0fbdee914d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a370157bf41d88daaae3d0fbdee914d4e">pingresp</a> ()</td></tr>
<tr class="memdesc:a370157bf41d88daaae3d0fbdee914d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a>.  <a href="#a370157bf41d88daaae3d0fbdee914d4e">More...</a><br /></td></tr>
<tr class="separator:a370157bf41d88daaae3d0fbdee914d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260deb5058e34f679ea28e66eaa2d871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871">connect</a> (std::uint16_t keep_alive_sec)</td></tr>
<tr class="memdesc:a260deb5058e34f679ea28e66eaa2d871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#a260deb5058e34f679ea28e66eaa2d871">More...</a><br /></td></tr>
<tr class="separator:a260deb5058e34f679ea28e66eaa2d871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364253270c039b9532d9a78f93442021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a364253270c039b9532d9a78f93442021">connack</a> (bool session_present, std::uint8_t return_code)</td></tr>
<tr class="memdesc:a364253270c039b9532d9a78f93442021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#a364253270c039b9532d9a78f93442021">More...</a><br /></td></tr>
<tr class="separator:a364253270c039b9532d9a78f93442021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764a30ddbcb8e7604e32803d989feca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a764a30ddbcb8e7604e32803d989feca7">puback</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a764a30ddbcb8e7604e32803d989feca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a>.  <a href="#a764a30ddbcb8e7604e32803d989feca7">More...</a><br /></td></tr>
<tr class="separator:a764a30ddbcb8e7604e32803d989feca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e82b0efad29a9432a0efccbd2003b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a38e82b0efad29a9432a0efccbd2003b9">pubrec</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a38e82b0efad29a9432a0efccbd2003b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a>.  <a href="#a38e82b0efad29a9432a0efccbd2003b9">More...</a><br /></td></tr>
<tr class="separator:a38e82b0efad29a9432a0efccbd2003b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeada796b151138d042eb3f91a6577ae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeada796b151138d042eb3f91a6577ae8">pubrel</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:aeada796b151138d042eb3f91a6577ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a>.  <a href="#aeada796b151138d042eb3f91a6577ae8">More...</a><br /></td></tr>
<tr class="separator:aeada796b151138d042eb3f91a6577ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa327e865e315a5587ce5b9861e57e1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa327e865e315a5587ce5b9861e57e1a6">pubcomp</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:aa327e865e315a5587ce5b9861e57e1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a>.  <a href="#aa327e865e315a5587ce5b9861e57e1a6">More...</a><br /></td></tr>
<tr class="separator:aa327e865e315a5587ce5b9861e57e1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c11ddcb2c1ff4b3583e856f6fde06ad"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3c11ddcb2c1ff4b3583e856f6fde06ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3c11ddcb2c1ff4b3583e856f6fde06ad">suback</a> (std::uint16_t packet_id, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3c11ddcb2c1ff4b3583e856f6fde06ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos  args additional qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>.  <a href="#a3c11ddcb2c1ff4b3583e856f6fde06ad">More...</a><br /></td></tr>
<tr class="separator:a3c11ddcb2c1ff4b3583e856f6fde06ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09945d6d771ecef843ff5098ccdd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4d09945d6d771ecef843ff5098ccdd4b">suback</a> (std::uint16_t packet_id, std::vector&lt; std::uint8_t &gt; const &amp;qoss)</td></tr>
<tr class="memdesc:a4d09945d6d771ecef843ff5098ccdd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>.  <a href="#a4d09945d6d771ecef843ff5098ccdd4b">More...</a><br /></td></tr>
<tr class="separator:a4d09945d6d771ecef843ff5098ccdd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c08de51d96da1bdc247a9243662cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1d3c08de51d96da1bdc247a9243662cc">unsuback</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a1d3c08de51d96da1bdc247a9243662cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a>.  <a href="#a1d3c08de51d96da1bdc247a9243662cc">More...</a><br /></td></tr>
<tr class="separator:a1d3c08de51d96da1bdc247a9243662cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2192253faf2f05ae9ad8dbd8dbc2ca89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2192253faf2f05ae9ad8dbd8dbc2ca89">async_publish_at_most_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2192253faf2f05ae9ad8dbd8dbc2ca89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS0.  <a href="#a2192253faf2f05ae9ad8dbd8dbc2ca89">More...</a><br /></td></tr>
<tr class="separator:a2192253faf2f05ae9ad8dbd8dbc2ca89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1522f853c0634f3228318997a46f11ae"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1522f853c0634f3228318997a46f11ae">async_publish_at_least_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1522f853c0634f3228318997a46f11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1.  <a href="#a1522f853c0634f3228318997a46f11ae">More...</a><br /></td></tr>
<tr class="separator:a1522f853c0634f3228318997a46f11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4855008440640d19f443c41b58a1088f"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4855008440640d19f443c41b58a1088f">async_publish_exactly_once</a> (std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4855008440640d19f443c41b58a1088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2.  <a href="#a4855008440640d19f443c41b58a1088f">More...</a><br /></td></tr>
<tr class="separator:a4855008440640d19f443c41b58a1088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fccd161a487dad5079b84c5ffec3d9"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa2fccd161a487dad5079b84c5ffec3d9">async_publish</a> (std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:aa2fccd161a487dad5079b84c5ffec3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish.  <a href="#aa2fccd161a487dad5079b84c5ffec3d9">More...</a><br /></td></tr>
<tr class="separator:aa2fccd161a487dad5079b84c5ffec3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae1f704bc6b0d51fff731ac7097dc91"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0ae1f704bc6b0d51fff731ac7097dc91"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, std::uint16_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0ae1f704bc6b0d51fff731ac7097dc91">async_subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0ae1f704bc6b0d51fff731ac7097dc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a0ae1f704bc6b0d51fff731ac7097dc91">More...</a><br /></td></tr>
<tr class="separator:a0ae1f704bc6b0d51fff731ac7097dc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8566737cdc99dea2373c9f8604ac21b2"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8566737cdc99dea2373c9f8604ac21b2">async_subscribe</a> (std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8566737cdc99dea2373c9f8604ac21b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a8566737cdc99dea2373c9f8604ac21b2">More...</a><br /></td></tr>
<tr class="separator:a8566737cdc99dea2373c9f8604ac21b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee742dadbf29a3fd9e6015191e9b0fd"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9ee742dadbf29a3fd9e6015191e9b0fd">async_subscribe</a> (std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9ee742dadbf29a3fd9e6015191e9b0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a9ee742dadbf29a3fd9e6015191e9b0fd">More...</a><br /></td></tr>
<tr class="separator:a9ee742dadbf29a3fd9e6015191e9b0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bb274bd3f4bda4dee4810cd0f71f30"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a00bb274bd3f4bda4dee4810cd0f71f30"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, std::uint16_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a00bb274bd3f4bda4dee4810cd0f71f30">async_unsubscribe</a> (std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a00bb274bd3f4bda4dee4810cd0f71f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a00bb274bd3f4bda4dee4810cd0f71f30">More...</a><br /></td></tr>
<tr class="separator:a00bb274bd3f4bda4dee4810cd0f71f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214625ab7437877fb8f2dcd3a4bb8d4"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ac214625ab7437877fb8f2dcd3a4bb8d4">async_unsubscribe</a> (std::string const &amp;topic_name, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:ac214625ab7437877fb8f2dcd3a4bb8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#ac214625ab7437877fb8f2dcd3a4bb8d4">More...</a><br /></td></tr>
<tr class="separator:ac214625ab7437877fb8f2dcd3a4bb8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527194ce2b9a89562843b6a3b7af1e48"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a527194ce2b9a89562843b6a3b7af1e48">async_unsubscribe</a> (std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a527194ce2b9a89562843b6a3b7af1e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a527194ce2b9a89562843b6a3b7af1e48">More...</a><br /></td></tr>
<tr class="separator:a527194ce2b9a89562843b6a3b7af1e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3712a44d416e0507f641d354031090f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae3712a44d416e0507f641d354031090f">async_disconnect</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:ae3712a44d416e0507f641d354031090f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect.  <a href="#ae3712a44d416e0507f641d354031090f">More...</a><br /></td></tr>
<tr class="separator:ae3712a44d416e0507f641d354031090f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209bb27782e61791e110b20dad717ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a209bb27782e61791e110b20dad717ac3">async_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a209bb27782e61791e110b20dad717ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a209bb27782e61791e110b20dad717ac3">More...</a><br /></td></tr>
<tr class="separator:a209bb27782e61791e110b20dad717ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a8ef6ad617a50ae8ca5b06ac801032"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a34a8ef6ad617a50ae8ca5b06ac801032">async_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a34a8ef6ad617a50ae8ca5b06ac801032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a34a8ef6ad617a50ae8ca5b06ac801032">More...</a><br /></td></tr>
<tr class="separator:a34a8ef6ad617a50ae8ca5b06ac801032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358a650167f862e6f19632bcae907e7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a358a650167f862e6f19632bcae907e7f">async_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a358a650167f862e6f19632bcae907e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a358a650167f862e6f19632bcae907e7f">More...</a><br /></td></tr>
<tr class="separator:a358a650167f862e6f19632bcae907e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb3583b48db63d6cfa33046ec50f09f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#acdb3583b48db63d6cfa33046ec50f09f">async_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:acdb3583b48db63d6cfa33046ec50f09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#acdb3583b48db63d6cfa33046ec50f09f">More...</a><br /></td></tr>
<tr class="separator:acdb3583b48db63d6cfa33046ec50f09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aacf197ed9b4ffd4c94a273dd9af9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7b1aacf197ed9b4ffd4c94a273dd9af9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7b1aacf197ed9b4ffd4c94a273dd9af9">async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7b1aacf197ed9b4ffd4c94a273dd9af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a7b1aacf197ed9b4ffd4c94a273dd9af9">More...</a><br /></td></tr>
<tr class="separator:a7b1aacf197ed9b4ffd4c94a273dd9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08ebee9aa2ee83193e290a2f1adfc7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af08ebee9aa2ee83193e290a2f1adfc7e">async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:af08ebee9aa2ee83193e290a2f1adfc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#af08ebee9aa2ee83193e290a2f1adfc7e">More...</a><br /></td></tr>
<tr class="separator:af08ebee9aa2ee83193e290a2f1adfc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7f5b35b87e74024e8114a2b863f46b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0c7f5b35b87e74024e8114a2b863f46b">async_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0c7f5b35b87e74024e8114a2b863f46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a0c7f5b35b87e74024e8114a2b863f46b">More...</a><br /></td></tr>
<tr class="separator:a0c7f5b35b87e74024e8114a2b863f46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48813e114e67dcd9ebf0c08666393ff7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a48813e114e67dcd9ebf0c08666393ff7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a48813e114e67dcd9ebf0c08666393ff7">async_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48813e114e67dcd9ebf0c08666393ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe with a manual set packet identifier.  <a href="#a48813e114e67dcd9ebf0c08666393ff7">More...</a><br /></td></tr>
<tr class="separator:a48813e114e67dcd9ebf0c08666393ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af550559820d7199ae8cba5404b28246c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#af550559820d7199ae8cba5404b28246c">async_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:af550559820d7199ae8cba5404b28246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#af550559820d7199ae8cba5404b28246c">More...</a><br /></td></tr>
<tr class="separator:af550559820d7199ae8cba5404b28246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f2cb172e1657c149f2d8686b14436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9f7f2cb172e1657c149f2d8686b14436">acquired_async_publish_at_least_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9f7f2cb172e1657c149f2d8686b14436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS1 with a manual set packet identifier.  <a href="#a9f7f2cb172e1657c149f2d8686b14436">More...</a><br /></td></tr>
<tr class="separator:a9f7f2cb172e1657c149f2d8686b14436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953ded966c12df4b312bba4e34ddc60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0953ded966c12df4b312bba4e34ddc60">acquired_async_publish_exactly_once</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a0953ded966c12df4b312bba4e34ddc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish QoS2 with a manual set packet identifier.  <a href="#a0953ded966c12df4b312bba4e34ddc60">More...</a><br /></td></tr>
<tr class="separator:a0953ded966c12df4b312bba4e34ddc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb0c8181513c1bbdca378f56da2663c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a7bb0c8181513c1bbdca378f56da2663c">acquired_async_publish</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a7bb0c8181513c1bbdca378f56da2663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish with a manual set packet identifier.  <a href="#a7bb0c8181513c1bbdca378f56da2663c">More...</a><br /></td></tr>
<tr class="separator:a7bb0c8181513c1bbdca378f56da2663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014105e055072d05508495bfca56eb0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a014105e055072d05508495bfca56eb0f">acquired_async_publish_dup</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::string const &amp;contents, std::uint8_t qos=<a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, bool retain=false, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a014105e055072d05508495bfca56eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish as dup with a manual set packet identifier.  <a href="#a014105e055072d05508495bfca56eb0f">More...</a><br /></td></tr>
<tr class="separator:a014105e055072d05508495bfca56eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f44693193752462ced28617eb9c7bc1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3f44693193752462ced28617eb9c7bc1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a3f44693193752462ced28617eb9c7bc1">acquired_async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3f44693193752462ced28617eb9c7bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe with a manual set packet identifier.  <a href="#a3f44693193752462ced28617eb9c7bc1">More...</a><br /></td></tr>
<tr class="separator:a3f44693193752462ced28617eb9c7bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180e8399772dc2c3eb52faa590725bbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a180e8399772dc2c3eb52faa590725bbd">acquired_async_subscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a180e8399772dc2c3eb52faa590725bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#a180e8399772dc2c3eb52faa590725bbd">More...</a><br /></td></tr>
<tr class="separator:a180e8399772dc2c3eb52faa590725bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c70b7c73c7da2de9b12300db22042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#adc3c70b7c73c7da2de9b12300db22042">acquired_async_subscribe</a> (std::uint16_t packet_id, std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:adc3c70b7c73c7da2de9b12300db22042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe.  <a href="#adc3c70b7c73c7da2de9b12300db22042">More...</a><br /></td></tr>
<tr class="separator:adc3c70b7c73c7da2de9b12300db22042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddff6cd7859458e2a1ba4fc274fe1dc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaddff6cd7859458e2a1ba4fc274fe1dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aaddff6cd7859458e2a1ba4fc274fe1dc">acquired_async_unsubscribe</a> (std::uint16_t packet_id, std::string const &amp;topic_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaddff6cd7859458e2a1ba4fc274fe1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#aaddff6cd7859458e2a1ba4fc274fe1dc">More...</a><br /></td></tr>
<tr class="separator:aaddff6cd7859458e2a1ba4fc274fe1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e7e890b5d4a8999c53991dfabe98ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a30e7e890b5d4a8999c53991dfabe98ec">acquired_async_unsubscribe</a> (std::uint16_t packet_id, std::vector&lt; std::string &gt; const &amp;params, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a30e7e890b5d4a8999c53991dfabe98ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe.  <a href="#a30e7e890b5d4a8999c53991dfabe98ec">More...</a><br /></td></tr>
<tr class="separator:a30e7e890b5d4a8999c53991dfabe98ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241f6e52a6d2274ea0b466040601b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1241f6e52a6d2274ea0b466040601b89">async_pingreq</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a1241f6e52a6d2274ea0b466040601b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingreq packet.  <a href="#a1241f6e52a6d2274ea0b466040601b89">More...</a><br /></td></tr>
<tr class="separator:a1241f6e52a6d2274ea0b466040601b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e80eac5fa7e6084a9a63447aaa4f060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8e80eac5fa7e6084a9a63447aaa4f060">async_pingresp</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8e80eac5fa7e6084a9a63447aaa4f060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pingresp packet. This function is for broker.  <a href="#a8e80eac5fa7e6084a9a63447aaa4f060">More...</a><br /></td></tr>
<tr class="separator:a8e80eac5fa7e6084a9a63447aaa4f060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebd0cae9e08a3e178a8fd95d92ac63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a90ebd0cae9e08a3e178a8fd95d92ac63">async_connect</a> (std::uint16_t keep_alive_sec, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a90ebd0cae9e08a3e178a8fd95d92ac63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connect packet.  <a href="#a90ebd0cae9e08a3e178a8fd95d92ac63">More...</a><br /></td></tr>
<tr class="separator:a90ebd0cae9e08a3e178a8fd95d92ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9dd19e01363bf1a9fd281890c46785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a9c9dd19e01363bf1a9fd281890c46785">async_connack</a> (bool session_present, std::uint8_t return_code, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a9c9dd19e01363bf1a9fd281890c46785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send connack packet. This function is for broker.  <a href="#a9c9dd19e01363bf1a9fd281890c46785">More...</a><br /></td></tr>
<tr class="separator:a9c9dd19e01363bf1a9fd281890c46785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6d8e8ce369846709ed0f30509cfb97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a8c6d8e8ce369846709ed0f30509cfb97">async_puback</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a8c6d8e8ce369846709ed0f30509cfb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send puback packet.  packet id corresponding to publish.  <a href="#a8c6d8e8ce369846709ed0f30509cfb97">More...</a><br /></td></tr>
<tr class="separator:a8c6d8e8ce369846709ed0f30509cfb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e113fd30c51c10fb626ab42ff56de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a13e113fd30c51c10fb626ab42ff56de3">async_pubrec</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a13e113fd30c51c10fb626ab42ff56de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrec packet.  packet id corresponding to publish.  <a href="#a13e113fd30c51c10fb626ab42ff56de3">More...</a><br /></td></tr>
<tr class="separator:a13e113fd30c51c10fb626ab42ff56de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fca5335d208084629b8a08e747b22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a2e4fca5335d208084629b8a08e747b22">async_pubrel</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a2e4fca5335d208084629b8a08e747b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubrel packet.  packet id corresponding to publish.  <a href="#a2e4fca5335d208084629b8a08e747b22">More...</a><br /></td></tr>
<tr class="separator:a2e4fca5335d208084629b8a08e747b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c153484f5f63a20e7ae17fac94e16fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a4c153484f5f63a20e7ae17fac94e16fe">async_pubcomp</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a4c153484f5f63a20e7ae17fac94e16fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pubcomp packet.  packet id corresponding to publish.  <a href="#a4c153484f5f63a20e7ae17fac94e16fe">More...</a><br /></td></tr>
<tr class="separator:a4c153484f5f63a20e7ae17fac94e16fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d38444dae1dcdfcefee5689fe6f9c2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a95d38444dae1dcdfcefee5689fe6f9c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; sizeof...(Args) !=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a95d38444dae1dcdfcefee5689fe6f9c2">async_suback</a> (std::uint16_t packet_id, std::uint8_t qos, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a95d38444dae1dcdfcefee5689fe6f9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe.  <a href="#a95d38444dae1dcdfcefee5689fe6f9c2">More...</a><br /></td></tr>
<tr class="separator:a95d38444dae1dcdfcefee5689fe6f9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fcc42596fff997940c70996538bfb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a54fcc42596fff997940c70996538bfb8">async_suback</a> (std::uint16_t packet_id, std::uint8_t qos, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a54fcc42596fff997940c70996538bfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos.  <a href="#a54fcc42596fff997940c70996538bfb8">More...</a><br /></td></tr>
<tr class="separator:a54fcc42596fff997940c70996538bfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7d82d8e8905962feaac611712a1bb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aeb7d82d8e8905962feaac611712a1bb0">async_suback</a> (std::uint16_t packet_id, std::vector&lt; std::uint8_t &gt; const &amp;qoss, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:aeb7d82d8e8905962feaac611712a1bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos.  <a href="#aeb7d82d8e8905962feaac611712a1bb0">More...</a><br /></td></tr>
<tr class="separator:aeb7d82d8e8905962feaac611712a1bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c60de7b44e217835a7a41f88db09c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a67c60de7b44e217835a7a41f88db09c6">async_unsuback</a> (std::uint16_t packet_id, <a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func=<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>())</td></tr>
<tr class="memdesc:a67c60de7b44e217835a7a41f88db09c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe.  <a href="#a67c60de7b44e217835a7a41f88db09c6">More...</a><br /></td></tr>
<tr class="separator:a67c60de7b44e217835a7a41f88db09c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb42cabd71aed23973df4a716ec5f46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#afbb42cabd71aed23973df4a716ec5f46">clear_stored_publish</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:afbb42cabd71aed23973df4a716ec5f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear storead publish message that has packet_id.  packet_id packet id corresponding to stored publish.  <a href="#afbb42cabd71aed23973df4a716ec5f46">More...</a><br /></td></tr>
<tr class="separator:afbb42cabd71aed23973df4a716ec5f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a39d3dc415bed7c68a62cdd9a0bd48"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ae9a39d3dc415bed7c68a62cdd9a0bd48">socket</a> ()</td></tr>
<tr class="memdesc:ae9a39d3dc415bed7c68a62cdd9a0bd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Socket unique_ptr reference.  <a href="#ae9a39d3dc415bed7c68a62cdd9a0bd48">More...</a><br /></td></tr>
<tr class="separator:ae9a39d3dc415bed7c68a62cdd9a0bd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d84f68b71144289d884ce49890774"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Socket &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a143d84f68b71144289d884ce49890774">socket</a> () const</td></tr>
<tr class="memdesc:a143d84f68b71144289d884ce49890774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Socket unique_ptr const reference.  <a href="#a143d84f68b71144289d884ce49890774">More...</a><br /></td></tr>
<tr class="separator:a143d84f68b71144289d884ce49890774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8adad30184bf59292cc0f4160c2529"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a0f8adad30184bf59292cc0f4160c2529"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a0f8adad30184bf59292cc0f4160c2529">for_each_store</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a0f8adad30184bf59292cc0f4160c2529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply f to stored messages.  f applying function. f should be void(char const*, std::size_t)  <a href="#a0f8adad30184bf59292cc0f4160c2529">More...</a><br /></td></tr>
<tr class="separator:a0f8adad30184bf59292cc0f4160c2529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f40e3b2a1e1248de087fd1c0269e72"><td class="memItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a88f40e3b2a1e1248de087fd1c0269e72">acquire_unique_packet_id</a> ()</td></tr>
<tr class="memdesc:a88f40e3b2a1e1248de087fd1c0269e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structmqtt_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acuired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="#a88f40e3b2a1e1248de087fd1c0269e72">More...</a><br /></td></tr>
<tr class="separator:a88f40e3b2a1e1248de087fd1c0269e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c14d7cb4ac2351f84b5ab153fe3858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a06c14d7cb4ac2351f84b5ab153fe3858">register_packet_id</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a06c14d7cb4ac2351f84b5ab153fe3858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register packet_id to the library. After registering the packet_id, you can call acuired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it.  <a href="#a06c14d7cb4ac2351f84b5ab153fe3858">More...</a><br /></td></tr>
<tr class="separator:a06c14d7cb4ac2351f84b5ab153fe3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362ac3ec46a40bc0831629791032654a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a362ac3ec46a40bc0831629791032654a">release_packet_id</a> (std::uint16_t packet_id)</td></tr>
<tr class="memdesc:a362ac3ec46a40bc0831629791032654a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release packet_id.  packet_id packet id to release. only the packet_id gotten by acquire_unique_packet_id, or register_packet_id is permitted.  <a href="#a362ac3ec46a40bc0831629791032654a">More...</a><br /></td></tr>
<tr class="separator:a362ac3ec46a40bc0831629791032654a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bde9adba07d37d1a9acc01d872c6a82"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a6bde9adba07d37d1a9acc01d872c6a82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a6bde9adba07d37d1a9acc01d872c6a82">restore_serialized_message</a> (std::uint16_t packet_id, Iterator b, Iterator e)</td></tr>
<tr class="memdesc:a6bde9adba07d37d1a9acc01d872c6a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore serialized publish and pubrel messages. This function shouold be called before connect.  packet_id packet id of the message  b iterator begin of the message  e iterator end of the message.  <a href="#a6bde9adba07d37d1a9acc01d872c6a82">More...</a><br /></td></tr>
<tr class="separator:a6bde9adba07d37d1a9acc01d872c6a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa4e69a001381699ad295d6d5d8fa745f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#aa4e69a001381699ad295d6d5d8fa745f">async_read_control_packet_type</a> (<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;func)</td></tr>
<tr class="separator:aa4e69a001381699ad295d6d5d8fa745f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670666a46556b17c8d944f0e1c3ab7e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a670666a46556b17c8d944f0e1c3ab7e8">connected</a> () const</td></tr>
<tr class="separator:a670666a46556b17c8d944f0e1c3ab7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1280fe8bfb0b1798ba0f32bf09279519"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#a1280fe8bfb0b1798ba0f32bf09279519">handle_close_or_error</a> (boost::system::error_code const &amp;ec)</td></tr>
<tr class="separator:a1280fe8bfb0b1798ba0f32bf09279519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e428202eed9104171d5fd9a0c7a2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1endpoint.html#ad1e428202eed9104171d5fd9a0c7a2c7">set_connect</a> ()</td></tr>
<tr class="separator:ad1e428202eed9104171d5fd9a0c7a2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0b6d41af55d98695f2c0006d7c8760f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6d41af55d98695f2c0006d7c8760f8">&#9670;&nbsp;</a></span>async_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fd2f3ab9044a470bf05361649d29cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd2f3ab9044a470bf05361649d29cd6">&#9670;&nbsp;</a></span>close_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close handler</p>
<p>This handler is called if the client called <code><a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a></code> and the server closed the socket cleanly. If the socket is closed by other reasons, error_handler is called. </p>

</div>
</div>
<a id="aa28b1eafa1224b5584fcd60d5cd46e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28b1eafa1224b5584fcd60d5cd46e85">&#9670;&nbsp;</a></span>connack_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a> =  std::function&lt;bool(bool session_present, std::uint8_t return_code)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connack handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>Session present flag.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035</a><br />
 3.2.2.2 Session Present </td></tr>
    <tr><td class="paramname">return_code</td><td><a class="el" href="namespacemqtt_1_1connect__return__code.html">connect_return_code</a><br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718035</a><br />
 3.2.2.3 Connect Return code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a8c32f3d8b1a1f8b1bc7eb7c32d03f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">&#9670;&nbsp;</a></span>connect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a> =  std::function&lt; bool(std::string const&amp; <a class="el" href="classmqtt_1_1endpoint.html#af3ba768fd77e275700ccdf2f470d9271">client_id</a>, boost::optional&lt;std::string&gt; const&amp; username, boost::optional&lt;std::string&gt; const&amp; password, boost::optional&lt;<a class="el" href="classmqtt_1_1will.html">will</a>&gt; <a class="el" href="classmqtt_1_1will.html">will</a>, bool <a class="el" href="classmqtt_1_1endpoint.html#a8ba033264e623b3504f3e21704ee852f">clean_session</a>, std::uint16_t keep_alive)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>User Name.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">username</td><td>User Name.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349245</a><br />
 3.1.3.4 User Name </td></tr>
    <tr><td class="paramname">password</td><td>Password.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349246">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349246</a><br />
 3.1.3.5 Password </td></tr>
    <tr><td class="paramname">will</td><td>Will. It contains retain, QoS, topic, and message.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349232">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349232</a><br />
 3.1.2.5 Will Flag<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349233">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349233</a><br />
 3.1.2.6 Will QoS<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349234">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349234</a><br />
 3.1.2.7 Will Retain<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349243">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349243</a><br />
 3.1.3.2 Will Topic<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349244">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349244</a><br />
 3.1.3.3 Will Message<br />
 </td></tr>
    <tr><td class="paramname">clean_session</td><td>Clean Session<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349231</a><br />
 3.1.2.4 Clean Session </td></tr>
    <tr><td class="paramname">keep_alive</td><td>Keep Alive<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349237">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349237</a><br />
 3.1.2.10 Keep Alive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a237958267803c9866f76ea7ce589cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237958267803c9866f76ea7ce589cb59">&#9670;&nbsp;</a></span>disconnect_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a> =  std::function&lt;void()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800463">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800463</a><br />
 3.14 DISCONNECT – Disconnect notification </p>

</div>
</div>
<a id="a4283a3190a40cef9bc8305988fa03332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4283a3190a40cef9bc8305988fa03332">&#9670;&nbsp;</a></span>error_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a> =  std::function&lt;void(boost::system::error_code const&amp; ec)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error handler</p>
<p>This handler is called if the socket is closed without client's <code><a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a></code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a8b43aee18e3f80f617db4e17bb333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a8b43aee18e3f80f617db4e17bb333">&#9670;&nbsp;</a></span>pingreq_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pingreq handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718081</a><br />
 3.13 PINGREQ – PING request </p><dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a72955c0d18dba21b99bb63569d0272fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72955c0d18dba21b99bb63569d0272fa">&#9670;&nbsp;</a></span>pingresp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a> =  std::function&lt;bool()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pingresp handler See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a><br />
 3.13 PINGRESP – PING response </p><dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad7c1deb23deb1e0e30f4e16da8119958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c1deb23deb1e0e30f4e16da8119958">&#9670;&nbsp;</a></span>pub_res_sent_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a> =  std::function&lt;void(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish response sent handler This function is called just after puback sent on QoS1, or pubcomp sent on QoS2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060</a><br />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cf238d6b1125c3f451c0e27135df13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf238d6b1125c3f451c0e27135df13c">&#9670;&nbsp;</a></span>puback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045</a><br />
 3.4.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad9fbf91bb4bfc0d3da01e0fd3cb29194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fbf91bb4bfc0d3da01e0fd3cb29194">&#9670;&nbsp;</a></span>pubcomp_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubcomp handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718060</a><br />
 3.7.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a4ec521e69b94ffcb12466680fe817b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec521e69b94ffcb12466680fe817b5d">&#9670;&nbsp;</a></span>publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a> =  std::function&lt;bool(std::uint8_t fixed_header, boost::optional&lt;std::uint16_t&gt; packet_id, std::string topic_name, std::string contents)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_header</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1 Fixed header<br />
 You can check the fixed header using <a class="el" href="namespacemqtt_1_1publish.html">mqtt::publish</a> functions. </td></tr>
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 If received publish's QoS is 0, packet_id is boost::none.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718039">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718039</a><br />
 3.3.2 Variable header </td></tr>
    <tr><td class="paramname">topic_name</td><td>Topic name </td></tr>
    <tr><td class="paramname">contents</td><td>Published contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a7a9b7dc0794ccdca635ff74a9cb21684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9b7dc0794ccdca635ff74a9cb21684">&#9670;&nbsp;</a></span>pubrec_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubrec handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718050">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718050</a><br />
 3.5.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ae7b303b77abde049f81b590830366db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b303b77abde049f81b590830366db6">&#9670;&nbsp;</a></span>pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a> =  std::function&lt;bool(std::uint16_t packet_id)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pubrel handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349791">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349791</a><br />
 3.6.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a48e0fe1bffe35a0f3e5426b21f825586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e0fe1bffe35a0f3e5426b21f825586">&#9670;&nbsp;</a></span>serialize_publish_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a48e0fe1bffe35a0f3e5426b21f825586">serialize_publish_handler</a> =  std::function&lt;void(std::uint16_t, char const*, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize publish handler You can serialize the publish message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#a6bde9adba07d37d1a9acc01d872c6a82" title="Restore serialized publish and pubrel messages. This function shouold be called before connect...">restore_serialized_message()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the serializing message </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the serializing message </td></tr>
    <tr><td class="paramname">size</td><td>size of the serializing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3024a20954122cb70b187094411e1250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3024a20954122cb70b187094411e1250">&#9670;&nbsp;</a></span>serialize_pubrel_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a3024a20954122cb70b187094411e1250">serialize_pubrel_handler</a> =  std::function&lt;void(std::uint16_t, char const*, std::size_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize pubrel handler You can serialize the pubrel message. If your storage has already had the publish message that has the same packet_id, then you need to replace the publish message to pubrel message. To restore the message, use <a class="el" href="classmqtt_1_1endpoint.html#a6bde9adba07d37d1a9acc01d872c6a82" title="Restore serialized publish and pubrel messages. This function shouold be called before connect...">restore_serialized_message()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the serializing message </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the serializing message </td></tr>
    <tr><td class="paramname">size</td><td>size of the serializing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a529d482d78e4733dfe88d729fd8a4778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529d482d78e4733dfe88d729fd8a4778">&#9670;&nbsp;</a></span>serialize_remove_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a529d482d78e4733dfe88d729fd8a4778">serialize_remove_handler</a> =  std::function&lt;void(std::uint16_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove serialized message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier of the removing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebdc808e9551b6a8bb4e08eb09a237c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc808e9551b6a8bb4e08eb09a237c4">&#9670;&nbsp;</a></span>suback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;boost::optional&lt;std::uint8_t&gt; &gt; qoss)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718070">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718070</a><br />
 3.9.2 Variable header </td></tr>
    <tr><td class="paramname">qoss</td><td>Collection of QoS that is corresponding to subscribed topic order.<br />
 If subscription is failure, the value is boost::none.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718071">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718071</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a603aa05bca6418513bfc57c5c1caf310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603aa05bca6418513bfc57c5c1caf310">&#9670;&nbsp;</a></span>subscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;std::tuple&lt;std::string, std::uint8_t&gt; &gt; entries)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349801">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349801</a><br />
 3.8.2 Variable header </td></tr>
    <tr><td class="paramname">entries</td><td>Collection of a pair of Topic Filter and QoS.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349802">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349802</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="ad3b1508ff56344254ddee6f25b72aab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b1508ff56344254ddee6f25b72aab8">&#9670;&nbsp;</a></span>unsuback_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a> =  std::function&lt;bool(std::uint16_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsuback handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718045</a><br />
 3.11.2 Variable header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<a id="a80ebbb8efccdd96e283637993ddb4f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ebbb8efccdd96e283637993ddb4f89">&#9670;&nbsp;</a></span>unsubscribe_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a> =  std::function&lt;bool(std::uint16_t packet_id, std::vector&lt;std::string&gt; topics)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsubscribe handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349810">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349810</a><br />
 3.10.2 Variable header </td></tr>
    <tr><td class="paramname">topics</td><td>Collection of Topic Filters<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800448">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800448</a><br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler returns true, then continue receiving, otherwise quit. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5a08d25c50d30485ab88d5cda4643bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a08d25c50d30485ab88d5cda4643bf">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for client. </p>

</div>
</div>
<a id="a855e3b7180ccbecd93b7c041179cc46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855e3b7180ccbecd93b7c041179cc46a">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Socket &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for server. socket should have already been connected with another endpoint. </p>

</div>
</div>
<a id="a7cc47a7059a05f53efa53167f388dcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc47a7059a05f53efa53167f388dcee">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b52e8785b73dc344dccb856cc4b85cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b52e8785b73dc344dccb856cc4b85cc">&#9670;&nbsp;</a></span>endpoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::<a class="el" href="classmqtt_1_1endpoint.html">endpoint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88f40e3b2a1e1248de087fd1c0269e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f40e3b2a1e1248de087fd1c0269e72">&#9670;&nbsp;</a></span>acquire_unique_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquire_unique_packet_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the new unique packet id. If all packet ids are already in use, then throw <a class="el" href="structmqtt_1_1packet__id__exhausted__error.html">packet_id_exhausted_error</a> exception. After acquiring the packet id, you can call acuired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>packet id </dd></dl>

</div>
</div>
<a id="a7bb0c8181513c1bbdca378f56da2663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb0c8181513c1bbdca378f56da2663c">&#9670;&nbsp;</a></span>acquired_async_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7f2cb172e1657c149f2d8686b14436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7f2cb172e1657c149f2d8686b14436">&#9670;&nbsp;</a></span>acquired_async_publish_at_least_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a014105e055072d05508495bfca56eb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014105e055072d05508495bfca56eb0f">&#9670;&nbsp;</a></span>acquired_async_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0953ded966c12df4b312bba4e34ddc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0953ded966c12df4b312bba4e34ddc60">&#9670;&nbsp;</a></span>acquired_async_publish_exactly_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f44693193752462ced28617eb9c7bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f44693193752462ced28617eb9c7bc1">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, void &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be some pairs of topic_name and qos to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180e8399772dc2c3eb52faa590725bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180e8399772dc2c3eb52faa590725bbd">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3c70b7c73c7da2de9b12300db22042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3c70b7c73c7da2de9b12300db22042">&#9670;&nbsp;</a></span>acquired_async_subscribe() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaddff6cd7859458e2a1ba4fc274fe1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddff6cd7859458e2a1ba4fc274fe1dc">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0 &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e7e890b5d4a8999c53991dfabe98ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e7e890b5d4a8999c53991dfabe98ec">&#9670;&nbsp;</a></span>acquired_async_unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67a46a578370d094fb3f8bc73d88bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a46a578370d094fb3f8bc73d88bd6b">&#9670;&nbsp;</a></span>acquired_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a448af811857b5c44fea310e4edb57e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448af811857b5c44fea310e4edb57e3f">&#9670;&nbsp;</a></span>acquired_publish_at_least_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4b1201af2bdb88e45f4b1ae5b77d300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b1201af2bdb88e45f4b1ae5b77d300">&#9670;&nbsp;</a></span>acquired_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. If qos == <a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a>, packet_id must be 0. But not checked in release mode due to performance. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cd7357cc6d6e7099ab2c952c8f8a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7357cc6d6e7099ab2c952c8f8a907">&#9670;&nbsp;</a></span>acquired_publish_exactly_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c2ffcb56e17fda8a8d71c5794090df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c2ffcb56e17fda8a8d71c5794090df">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9438d6a87bed42f46faaf030f0f8582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9438d6a87bed42f46faaf030f0f8582">&#9670;&nbsp;</a></span>acquired_subscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79d1a8f45d0953d4a06a3b6d3a5f9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d1a8f45d0953d4a06a3b6d3a5f9570">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed5d6fd47f7fb59bcd712ce6cf855af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5d6fd47f7fb59bcd712ce6cf855af1">&#9670;&nbsp;</a></span>acquired_unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::acquired_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with already acquired packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier. It should be acquired by acquire_unique_packet_id, or register_packet_id. The ownership of the packet_id moves to the library. </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c9dd19e01363bf1a9fd281890c46785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9dd19e01363bf1a9fd281890c46785">&#9670;&nbsp;</a></span>async_connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>return_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90ebd0cae9e08a3e178a8fd95d92ac63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ebd0cae9e08a3e178a8fd95d92ac63">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3712a44d416e0507f641d354031090f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3712a44d416e0507f641d354031090f">&#9670;&nbsp;</a></span>async_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1241f6e52a6d2274ea0b466040601b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241f6e52a6d2274ea0b466040601b89">&#9670;&nbsp;</a></span>async_pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_pingreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e80eac5fa7e6084a9a63447aaa4f060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e80eac5fa7e6084a9a63447aaa4f060">&#9670;&nbsp;</a></span>async_pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_pingresp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c6d8e8ce369846709ed0f30509cfb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6d8e8ce369846709ed0f30509cfb97">&#9670;&nbsp;</a></span>async_puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_puback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c153484f5f63a20e7ae17fac94e16fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c153484f5f63a20e7ae17fac94e16fe">&#9670;&nbsp;</a></span>async_pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_pubcomp </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2fccd161a487dad5079b84c5ffec3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fccd161a487dad5079b84c5ffec3d9">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a358a650167f862e6f19632bcae907e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358a650167f862e6f19632bcae907e7f">&#9670;&nbsp;</a></span>async_publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a1522f853c0634f3228318997a46f11ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522f853c0634f3228318997a46f11ae">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a209bb27782e61791e110b20dad717ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209bb27782e61791e110b20dad717ac3">&#9670;&nbsp;</a></span>async_publish_at_least_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a2192253faf2f05ae9ad8dbd8dbc2ca89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2192253faf2f05ae9ad8dbd8dbc2ca89">&#9670;&nbsp;</a></span>async_publish_at_most_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdb3583b48db63d6cfa33046ec50f09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb3583b48db63d6cfa33046ec50f09f">&#9670;&nbsp;</a></span>async_publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a4855008440640d19f443c41b58a1088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4855008440640d19f443c41b58a1088f">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a34a8ef6ad617a50ae8ca5b06ac801032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a8ef6ad617a50ae8ca5b06ac801032">&#9670;&nbsp;</a></span>async_publish_exactly_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a13e113fd30c51c10fb626ab42ff56de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e113fd30c51c10fb626ab42ff56de3">&#9670;&nbsp;</a></span>async_pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_pubrec </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4fca5335d208084629b8a08e747b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4fca5335d208084629b8a08e747b22">&#9670;&nbsp;</a></span>async_pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_pubrel </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet.  packet id corresponding to publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4e69a001381699ad295d6d5d8fa745f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e69a001381699ad295d6d5d8fa745f">&#9670;&nbsp;</a></span>async_read_control_packet_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_read_control_packet_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d38444dae1dcdfcefee5689fe6f9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d38444dae1dcdfcefee5689fe6f9c2">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0 &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>args should be some qos corresponding to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54fcc42596fff997940c70996538bfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fcc42596fff997940c70996538bfb8">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb7d82d8e8905962feaac611712a1bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7d82d8e8905962feaac611712a1bb0">&#9670;&nbsp;</a></span>async_suback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>qoss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ae1f704bc6b0d51fff731ac7097dc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae1f704bc6b0d51fff731ac7097dc91">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, std::uint16_t &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be some pairs of topic_name and qos to subscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a8566737cdc99dea2373c9f8604ac21b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8566737cdc99dea2373c9f8604ac21b2">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a9ee742dadbf29a3fd9e6015191e9b0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee742dadbf29a3fd9e6015191e9b0fd">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a7b1aacf197ed9b4ffd4c94a273dd9af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1aacf197ed9b4ffd4c94a273dd9af9">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, bool &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="af08ebee9aa2ee83193e290a2f1adfc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08ebee9aa2ee83193e290a2f1adfc7e">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a0c7f5b35b87e74024e8114a2b863f46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7f5b35b87e74024e8114a2b863f46b">&#9670;&nbsp;</a></span>async_subscribe() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the pair of topic_name and qos to subscribe. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a67c60de7b44e217835a7a41f88db09c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c60de7b44e217835a7a41f88db09c6">&#9670;&nbsp;</a></span>async_unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsuback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00bb274bd3f4bda4dee4810cd0f71f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bb274bd3f4bda4dee4810cd0f71f30">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, std::uint16_t &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names to unsubscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="ac214625ab7437877fb8f2dcd3a4bb8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac214625ab7437877fb8f2dcd3a4bb8d4">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a527194ce2b9a89562843b6a3b7af1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527194ce2b9a89562843b6a3b7af1e48">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a48813e114e67dcd9ebf0c08666393ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48813e114e67dcd9ebf0c08666393ff7">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; sizeof...(Args) != 0, bool &gt;::type <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names to unsubscribe, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="af550559820d7199ae8cba5404b28246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af550559820d7199ae8cba5404b28246c">&#9670;&nbsp;</a></span>async_unsubscribe() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::async_unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>A collection of the topic name to unsubscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be some topic_names, <br />
 and the last one is a callback function that is called when async operation will finish. </td></tr>
    <tr><td class="paramname">func</td><td>A callback function that is called when async operation will finish. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a8ba033264e623b3504f3e21704ee852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba033264e623b3504f3e21704ee852f">&#9670;&nbsp;</a></span>clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::clean_session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get clean session.</p>
<p>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029</a><br />
 3.1.2.4 Clean Session<br />
 After constructing a endpoint, the clean session is set to false. </p><dl class="section return"><dt>Returns</dt><dd>clean session </dd></dl>

</div>
</div>
<a id="afbb42cabd71aed23973df4a716ec5f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb42cabd71aed23973df4a716ec5f46">&#9670;&nbsp;</a></span>clear_stored_publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::clear_stored_publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear storead publish message that has packet_id.  packet_id packet id corresponding to stored publish. </p>

</div>
</div>
<a id="af3ba768fd77e275700ccdf2f470d9271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ba768fd77e275700ccdf2f470d9271">&#9670;&nbsp;</a></span>client_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::client_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get client id.</p>
<p>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.1 Client Identifier </p><dl class="section return"><dt>Returns</dt><dd>client id </dd></dl>

</div>
</div>
<a id="a364253270c039b9532d9a78f93442021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364253270c039b9532d9a78f93442021">&#9670;&nbsp;</a></span>connack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::connack </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>session_present</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>return_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connack packet. This function is for broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session_present</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349255</a> </td></tr>
    <tr><td class="paramname">return_code</td><td>See <a class="el" href="connect__return__code_8hpp.html">connect_return_code.hpp</a> and <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349256</a> See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718033</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a260deb5058e34f679ea28e66eaa2d871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260deb5058e34f679ea28e66eaa2d871">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>keep_alive_sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send connect packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keep_alive_sec</td><td>See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349238</a> See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718028</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a670666a46556b17c8d944f0e1c3ab7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670666a46556b17c8d944f0e1c3ab7e8">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc057e855eb7f05e9296a650c4d490e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc057e855eb7f05e9296a650c4d490e7">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence. The broker disconnects the endpoint after receives the disconnect packet.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>, a will won't send.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718090</a><br />
 </p>

</div>
</div>
<a id="a0f8adad30184bf59292cc0f4160c2529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8adad30184bf59292cc0f4160c2529">&#9670;&nbsp;</a></span>for_each_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::for_each_store </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply f to stored messages.  f applying function. f should be void(char const*, std::size_t) </p>

</div>
</div>
<a id="a5ae7f04812bee8468b19e8cb26420901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae7f04812bee8468b19e8cb26420901">&#9670;&nbsp;</a></span>force_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::force_disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.<br />
 When the endpoint disconnects using <a class="el" href="classmqtt_1_1endpoint.html#a5ae7f04812bee8468b19e8cb26420901" title="Disconnect by endpoint Force disconnect. It is not a clean disconnect sequence.  When the endpoint di...">force_disconnect()</a>, a will will send.<br />
 </p>

</div>
</div>
<a id="a1280fe8bfb0b1798ba0f32bf09279519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1280fe8bfb0b1798ba0f32bf09279519">&#9670;&nbsp;</a></span>handle_close_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::handle_close_or_error </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code const &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9ec958783746c6fae3136161fc08dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ec958783746c6fae3136161fc08dd7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec08953e522baa589dcc596b5513aa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec08953e522baa589dcc596b5513aa2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1endpoint.html">endpoint</a>&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html">this_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0945a20dfeb0ffbc92958e3c92861d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0945a20dfeb0ffbc92958e3c92861d7">&#9670;&nbsp;</a></span>pingreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::pingreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingreq packet. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a>. </p>

</div>
</div>
<a id="a370157bf41d88daaae3d0fbdee914d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370157bf41d88daaae3d0fbdee914d4e">&#9670;&nbsp;</a></span>pingresp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::pingresp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pingresp packet. This function is for broker. See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718086</a>. </p>

</div>
</div>
<a id="a764a30ddbcb8e7604e32803d989feca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764a30ddbcb8e7604e32803d989feca7">&#9670;&nbsp;</a></span>puback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::puback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send puback packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718043</a>. </p>

</div>
</div>
<a id="aa327e865e315a5587ce5b9861e57e1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa327e865e315a5587ce5b9861e57e1a6">&#9670;&nbsp;</a></span>pubcomp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::pubcomp </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubcomp packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718058</a>. </p>

</div>
</div>
<a id="ab50a6337d74249b1b89730d8edf5a2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50a6337d74249b1b89730d8edf5a2ed">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. If qos is set to at_most_once, return 0. packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="acf4fcddac86301a827ac2f9f8cec7617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4fcddac86301a827ac2f9f8cec7617">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a13bd397b4260ecab66c2a24949e40e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bd397b4260ecab66c2a24949e40e3b">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="a67f9ce7ae62c7be12d6d4546a0344bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f9ce7ae62c7be12d6d4546a0344bf3">&#9670;&nbsp;</a></span>publish_at_least_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_at_least_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS1 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="ada4f162ba7875a79c846180447b43ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4f162ba7875a79c846180447b43ab8">&#9670;&nbsp;</a></span>publish_at_most_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_at_most_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad60c56d4269548293e21ac7453420388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60c56d4269548293e21ac7453420388">&#9670;&nbsp;</a></span>publish_dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_dup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em> = <code><a class="el" href="namespacemqtt_1_1qos.html#a596b177cc163724d87eefa3202b84314">qos::at_most_once</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish as dup with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents don't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a15b1bad31ccc1cbb2b8befe7d1c06743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b1bad31ccc1cbb2b8befe7d1c06743">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id packet_id is automatically generated. </dd></dl>

</div>
</div>
<a id="ad5adbb21de745dd4abae39dee1964569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5adbb21de745dd4abae39dee1964569">&#9670;&nbsp;</a></span>publish_exactly_once() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::publish_exactly_once </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish QoS2 with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to publish </td></tr>
    <tr><td class="paramname">contents</td><td>The contents to publish </td></tr>
    <tr><td class="paramname">retain</td><td>A retain flag. If set it to true, the contents is retained.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038</a><br />
 3.3.1.3 RETAIN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and contents doesn't publish, otherwise return true and contents publish. </dd></dl>

</div>
</div>
<a id="a38e82b0efad29a9432a0efccbd2003b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e82b0efad29a9432a0efccbd2003b9">&#9670;&nbsp;</a></span>pubrec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::pubrec </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrec packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718048</a>. </p>

</div>
</div>
<a id="aeada796b151138d042eb3f91a6577ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeada796b151138d042eb3f91a6577ae8">&#9670;&nbsp;</a></span>pubrel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::pubrel </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pubrel packet.  packet id corresponding to publish See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718053</a>. </p>

</div>
</div>
<a id="a06c14d7cb4ac2351f84b5ab153fe3858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c14d7cb4ac2351f84b5ab153fe3858">&#9670;&nbsp;</a></span>register_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::register_packet_id </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register packet_id to the library. After registering the packet_id, you can call acuired_* functions. The ownership of packet id is moved to the library. Or you can call release_packet_id to release it. </p>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully registerd then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a362ac3ec46a40bc0831629791032654a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362ac3ec46a40bc0831629791032654a">&#9670;&nbsp;</a></span>release_packet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::release_packet_id </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release packet_id.  packet_id packet id to release. only the packet_id gotten by acquire_unique_packet_id, or register_packet_id is permitted. </p>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is successfully released then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a6bde9adba07d37d1a9acc01d872c6a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bde9adba07d37d1a9acc01d872c6a82">&#9670;&nbsp;</a></span>restore_serialized_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::restore_serialized_message </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore serialized publish and pubrel messages. This function shouold be called before connect.  packet_id packet id of the message  b iterator begin of the message  e iterator end of the message. </p>

</div>
</div>
<a id="a9b261bea1cab969cca812a2ddd503b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b261bea1cab969cca812a2ddd503b29">&#9670;&nbsp;</a></span>set_auto_pub_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_auto_pub_response </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set auto publish response mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>set value</td></tr>
  </table>
  </dd>
</dl>
<p>When set auto publish response mode to true, puback, pubrec, pubrel,and pub comp automatically send.<br />
 </p>

</div>
</div>
<a id="aff260217fb3474f276e86c1a7f21303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff260217fb3474f276e86c1a7f21303e">&#9670;&nbsp;</a></span>set_clean_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_clean_session </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set clean session. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>clean session</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718029</a><br />
 3.1.2.4 Clean Session<br />
 After constructing a endpoint, the clean session is set to false. </p>

</div>
</div>
<a id="ae367310df411f0b1517d7d10231412ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae367310df411f0b1517d7d10231412ab">&#9670;&nbsp;</a></span>set_client_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_client_id </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set client id. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>client id</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.1 Client Identifier </p>

</div>
</div>
<a id="ae9c6e70cd0d0a3dc3120f11312d12148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c6e70cd0d0a3dc3120f11312d12148">&#9670;&nbsp;</a></span>set_close_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_close_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a6fd2f3ab9044a470bf05361649d29cd6">close_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set close handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044cf23b497ad19cfde32346294b7a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044cf23b497ad19cfde32346294b7a29">&#9670;&nbsp;</a></span>set_connack_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_connack_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aa28b1eafa1224b5584fcd60d5cd46e85">connack_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connack handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1e428202eed9104171d5fd9a0c7a2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e428202eed9104171d5fd9a0c7a2c7">&#9670;&nbsp;</a></span>set_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d592c552de6d23134a485ab9f9b34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d592c552de6d23134a485ab9f9b34e">&#9670;&nbsp;</a></span>set_connect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_connect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a8c32f3d8b1a1f8b1bc7eb7c32d03f901">connect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac462694eb41e63598c3d6cbc3fbbbdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac462694eb41e63598c3d6cbc3fbbbdc5">&#9670;&nbsp;</a></span>set_disconnect_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_disconnect_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a237958267803c9866f76ea7ce589cb59">disconnect_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set disconnect handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dc5f2a2ab14653833f2e763284e6f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5f2a2ab14653833f2e763284e6f8f">&#9670;&nbsp;</a></span>set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a4283a3190a40cef9bc8305988fa03332">error_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set error handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30b4481258c7c4bc1caa444187282ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30b4481258c7c4bc1caa444187282ea">&#9670;&nbsp;</a></span>set_password()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_password </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>password</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set password. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>password</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.5 Password </p>

</div>
</div>
<a id="a5f6cdc6c0e609ebd842a35d62b9bd78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6cdc6c0e609ebd842a35d62b9bd78b">&#9670;&nbsp;</a></span>set_pingreq_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pingreq_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a13a8b43aee18e3f80f617db4e17bb333">pingreq_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingreq handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0147fed46ca1bef39d25264f0b058585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0147fed46ca1bef39d25264f0b058585">&#9670;&nbsp;</a></span>set_pingresp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pingresp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a72955c0d18dba21b99bb63569d0272fa">pingresp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pingresp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b26c627180a09a6456d605d0f661545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b26c627180a09a6456d605d0f661545">&#9670;&nbsp;</a></span>set_pub_res_sent_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pub_res_sent_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad7c1deb23deb1e0e30f4e16da8119958">pub_res_sent_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbffccd310664d0ed464bf236109f67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbffccd310664d0ed464bf236109f67f">&#9670;&nbsp;</a></span>set_puback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_puback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a4cf238d6b1125c3f451c0e27135df13c">puback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83f74d5986ce4242f2e5d34b71e0051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83f74d5986ce4242f2e5d34b71e0051">&#9670;&nbsp;</a></span>set_pubcomp_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pubcomp_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad9fbf91bb4bfc0d3da01e0fd3cb29194">pubcomp_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubcomp handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2e8e430c7384310ccc48512bba60926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e8e430c7384310ccc48512bba60926">&#9670;&nbsp;</a></span>set_publish_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_publish_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a4ec521e69b94ffcb12466680fe817b5d">publish_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set puback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79fbb227b4b3d1b5845cba0643831813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fbb227b4b3d1b5845cba0643831813">&#9670;&nbsp;</a></span>set_pubrec_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pubrec_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a7a9b7dc0794ccdca635ff74a9cb21684">pubrec_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrec handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee191bcfd559797248d869fd25e3afb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee191bcfd559797248d869fd25e3afb0">&#9670;&nbsp;</a></span>set_pubrel_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_pubrel_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ae7b303b77abde049f81b590830366db6">pubrel_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pubrel handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a051193db6f0bd16f4ec8c6c05547f33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051193db6f0bd16f4ec8c6c05547f33a">&#9670;&nbsp;</a></span>set_serialize_handlers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_serialize_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a48e0fe1bffe35a0f3e5426b21f825586">serialize_publish_handler</a>&#160;</td>
          <td class="paramname"><em>h_publish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a3024a20954122cb70b187094411e1250">serialize_pubrel_handler</a>&#160;</td>
          <td class="paramname"><em>h_pubrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a529d482d78e4733dfe88d729fd8a4778">serialize_remove_handler</a>&#160;</td>
          <td class="paramname"><em>h_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set serialize handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h_publish</td><td>serialize handler for publish message </td></tr>
    <tr><td class="paramname">h_pubrel</td><td>serialize handler for pubrel message </td></tr>
    <tr><td class="paramname">h_remove</td><td>remove handler for serialized message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f8cc98b19fa6efb4859afcc7974af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f8cc98b19fa6efb4859afcc7974af4">&#9670;&nbsp;</a></span>set_serialize_handlers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_serialize_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear serialize handlers. </p>

</div>
</div>
<a id="a1d5952c577be18487ddb6244e20c8cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5952c577be18487ddb6244e20c8cfa">&#9670;&nbsp;</a></span>set_suback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_suback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#aebdc808e9551b6a8bb4e08eb09a237c4">suback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set suback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6bd623a1d7474797f0d49c1eed0ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bd623a1d7474797f0d49c1eed0ff76">&#9670;&nbsp;</a></span>set_subscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_subscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a603aa05bca6418513bfc57c5c1caf310">subscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set subscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3c05ad6e1c692b83adf1e620fa18ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c05ad6e1c692b83adf1e620fa18ae9">&#9670;&nbsp;</a></span>set_unsuback_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_unsuback_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#ad3b1508ff56344254ddee6f25b72aab8">unsuback_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsuback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a412c27a7710d08a46a843a981a9d0e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412c27a7710d08a46a843a981a9d0e71">&#9670;&nbsp;</a></span>set_unsubscribe_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_unsubscribe_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a80ebbb8efccdd96e283637993ddb4f89">unsubscribe_handler</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set unsubscribe handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5912a8486fae2d60e53738538d8ea79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5912a8486fae2d60e53738538d8ea79b">&#9670;&nbsp;</a></span>set_user_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_user_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set username. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>username</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871" title="Send connect packet. ">connect()</a>.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718031</a><br />
 3.1.3.4 User Name </p>

</div>
</div>
<a id="a858b242da7b69c635fc459d0085e0721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858b242da7b69c635fc459d0085e0721">&#9670;&nbsp;</a></span>set_will()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::set_will </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1will.html">will</a>&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set will. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>will</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called before calling <a class="el" href="classmqtt_1_1endpoint.html#a260deb5058e34f679ea28e66eaa2d871" title="Send connect packet. ">connect()</a>.<br />
 'will' would be send when endpoint is disconnected without calling <a class="el" href="classmqtt_1_1endpoint.html#abc057e855eb7f05e9296a650c4d490e7" title="Disconnect Send a disconnect packet to the connected broker. It is a clean disconnecting sequence...">disconnect()</a>. </p>

</div>
</div>
<a id="ae9a39d3dc415bed7c68a62cdd9a0bd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a39d3dc415bed7c68a62cdd9a0bd48">&#9670;&nbsp;</a></span>socket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt;&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Socket unique_ptr reference. </p>
<dl class="section return"><dt>Returns</dt><dd>refereence of Socket unique_ptr </dd></dl>

</div>
</div>
<a id="a143d84f68b71144289d884ce49890774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143d84f68b71144289d884ce49890774">&#9670;&nbsp;</a></span>socket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Socket&gt; const&amp; <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Socket unique_ptr const reference. </p>
<dl class="section return"><dt>Returns</dt><dd>const refereence of Socket unique_ptr </dd></dl>

</div>
</div>
<a id="a0b8d691bd7c6ad79231945d7cba63dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8d691bd7c6ad79231945d7cba63dd8">&#9670;&nbsp;</a></span>start_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::start_session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="classmqtt_1_1endpoint.html#a0b6d41af55d98695f2c0006d7c8760f8">async_handler_t</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start session with a connected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>finish handler that is called when the session is finished </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c11ddcb2c1ff4b3583e856f6fde06ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c11ddcb2c1ff4b3583e856f6fde06ad">&#9670;&nbsp;</a></span>suback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qos adjusted qos  args additional qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>. </p>

</div>
</div>
<a id="a4d09945d6d771ecef843ff5098ccdd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d09945d6d771ecef843ff5098ccdd4b">&#9670;&nbsp;</a></span>suback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::suback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>qoss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send suback packet. This function is for broker.  packet_id packet id corresponding to subscribe  qoss a collection of adjusted qos See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718068</a>. </p>

</div>
</div>
<a id="a3eeee286ecfdf935ff41145516061bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eeee286ecfdf935ff41145516061bf5">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a23aee9d5020a4d36e8e5b47f239464e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aee9d5020a4d36e8e5b47f239464e3">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="aba66b7682d76365889917892549fae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba66b7682d76365889917892549fae61">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">qos</td><td><a class="el" href="namespacemqtt_1_1qos.html">mqtt::qos</a> </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more pairs of topic_name and qos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="af072282853a43776a6e03eb1990f6dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af072282853a43776a6e03eb1990f6dac">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, std::uint8_t &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a vector of the topic_filter and qos pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't subscribe, otherwise return true and subscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a><br />
 </dd></dl>

</div>
</div>
<a id="a1d3c08de51d96da1bdc247a9243662cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3c08de51d96da1bdc247a9243662cc">&#9670;&nbsp;</a></span>unsuback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::unsuback </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send unsuback packet. This function is for broker.  packet_id packet id corresponding to unsubscribe See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718077</a>. </p>

</div>
</div>
<a id="aa66e1dc447ae3e0afdb9cc0459d67623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66e1dc447ae3e0afdb9cc0459d67623">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="aeb83dcd17c92fad43985f7115a9771c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb83dcd17c92fad43985f7115a9771c1">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>a collection of topic_filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet_id. packet_id is automatically generated.<br />
 You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="af5b8397ae767dfda448bdba5753f6e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b8397ae767dfda448bdba5753f6e60">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>topic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">topic_name</td><td>A topic name to subscribe </td></tr>
    <tr><td class="paramname">args</td><td>args should be zero or more topics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<a id="a1792f54da142010f8eeb4fb75d9d06f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1792f54da142010f8eeb4fb75d9d06f1">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Socket, typename Mutex = std::mutex, template&lt; typename... &gt; class LockGuard = std::lock_guard&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1endpoint.html">mqtt::endpoint</a>&lt; Socket, Mutex, LockGuard &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>packet_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribe with a manual set packet identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet_id</td><td>packet identifier </td></tr>
    <tr><td class="paramname">params</td><td>a collection of topic_filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If packet_id is used in the publishing/subscribing sequence, then returns false and doesn't unsubscribe, otherwise return true and unsubscribes. You can subscribe multiple topics all at once.<br />
 See <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718066</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/kondo/work/mqtt_cpp/include/mqtt/<a class="el" href="endpoint_8hpp_source.html">endpoint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
